#***************************************************************************
#    copyright            : (C) 2006 Thomas Moenicke
#    email                : tm@ippfp.org
#    author               : Thomas Moenicke
#***************************************************************************/

#/***************************************************************************
# *                                                                         *
# *   This program is free software; you can redistribute it and/or modify  *
# *   it under the terms of the GNU General Public License as published by  *
# *   the Free Software Foundation; either version 2 of the License, or     *
# *   (at your option) any later version.                                   *
# *                                                                         *
#***************************************************************************/

# sub cplusplusToZEND               $cplusplusType
# sub cplusplusToZENDType           $cplusplusType
# sub cplusplusToPInvoke            $cplusplusType
# sub cplusplusToMacro              $class, $cnode

# sub writeDoc                      $lib, $rootnode, $outputdir, $opt
# sub writeClassDoc                 $node


package kalyptusCxxToPHP;

use File::Path;
use File::Basename;

use Carp;
use Ast;
use kdocAstUtil;
use kdocUtil;
use Iter;
use kalyptusDataDict;

#use strict;
no strict "subs";

use vars qw/
    @clist
    $host $who $now $gentext %functionId $docTop
	$lib $rootnode $outputdir $opt $debug $typeprefix $eventHandlerCount
	$pastaccess $pastname $pastreturn $pastparams $nullctor $ctorCount @properties @functions @constructors

    %methods

    $classname;
    *CLASS
    *HEADER

    *AG_ZEND_CLASS_ENTRY
    *AG_EXTERN_ZEND_CLASS_ENTRY
    *AG_VOID_REGISTER
    *AG_ZEND_PHP_QT
    *AG_CONFIGM4
    *AG_QT_MINIT
    *AG_PHP_QT_CPP

    *QTCTYPES
    *KDETYPES
    /;


BEGIN
{
    @clist = ();

    # Page footer

	$who = kdocUtil::userName();
	$host = kdocUtil::hostName();
	$now = localtime;
	$gentext = "$who using kalyptus $main::Version.";

	$docTop =<<EOF
 * begin           : $now
 * generated by    : $gentext
 */
EOF
}

#   for all header files

#   $lib            not used
#   $rootnode       rootnode of Ast
#   $outputdir      string of dirname
#   $opt            not used

sub writeDoc
{
	my ( $lib, $rootnode, $outputdir_, $opt ) = @_;

    $outputdir = $outputdir_;

#    kdocAstUtil::dumpAst($rootnode);

    openAllFiles();

	# Document all compound nodes
	Iter::LocalCompounds( $rootnode, sub { writeClassDoc( shift ); } );

    closeAllFiles();

}

# for one class

sub writeClassDoc
{
	my( $class ) = @_;
    $classname = $class->{astNodeName};

    openClassFile($class);

    checkIncludes($class);
    writeAllFiles($class);

    DerivedClass($class);

    handleAllMethods($class);
    Inheritance($class);

    closeClassFile();

}

# all methods of this class

sub handleAllMethods
{
    my ($class) = @_;

    %methods = ();

	Iter::MembersByType ($class,sub{},
		sub
        {
            my ($class, $kid ) = @_;
            if ($kid->{NodeType} eq "property" )
            {
                push @properties, $kid;
            }
            if($kid->{NodeType} eq "method")
            {
                mergeMethods($kid);
            }
        },sub {}
	);

    foreach my $key (keys %methods)
    {
        $method = %methods->{$key};

        writeMethodDoc($method);
        handleMethod($method);

    }
}

# all args of this method
#
# every method has a list of arguments from overloaded methods
#
sub handleMethod
{
    my ( $method ) = @_;

    my $methodname = $method->{astNodeName};
    $methodname = "__construct" if($methodname eq $classname);

    print CLASS "ZEND_METHOD(".$classname.",".$methodname."){";
    print CLASS "PHP_QT_FETCH_ARGS();";

    my $first = "true";
    # get _all_ arg
    ARGLIST: foreach my $overloadedmethod (@{$method->{"argList"}})
    {
        if($first eq "true"){
            $first = "false";
            next;
        }

        my @cargs = kdocUtil::splitUnnested(",", $overloadedmethod->{Params});
        my $params;     # collect args for every try

        my $zend_args_query;        # parameter for the type check statement
        my $ce_ptr_query;           # parameter for the class check statement
        my $count_args=0;
        my @stack = ();             # argument stack, regular parameters
        my @stack_optional = ();    # argument stack, optional parameters

        my @ifdef_stack = ();       # object safety

        # check whether agument is optional or regular
        foreach my $cpp_arg ( @cargs ) {

            if($cpp_arg =~ /=/){
                push(@stack_optional,$cpp_arg);
            } else {
                push(@stack,$cpp_arg);
            }
        }

        #
        # all regular args
        #
        foreach $cpp_arg (@stack){

            $params .= $cpp_arg.","; # collect args for this try
            $zend_arg = cplusplusToZVAL($cpp_arg);

            # intercept unknown types
            if($zend_arg eq "unknown"){
                print CLASS "\n// notice: unknown argument ".$cpp_arg.", skipped\n";
                next ARGLIST;
            }

            $zend_args_query .= " && Z_TYPE_P(args[".$count_args."]) == IS_".$zend_arg;
            if($zend_arg eq "OBJECT"){
                if($count_args > 1){
                    $ce_ptr_query .= "&& ";
                }
                $ce_ptr_query .= "Z_OBJCE_P(args[".$count_args."]) == ".unwrapClassType($cpp_arg)."_ce_ptr";
                push(@ifdef_stack,unwrapClassType($cpp_arg));
            }
            $count_args++;
        }

        # type check
        print CLASS "\n\t///".$overloadedmethod->{Params}."\n";

        # ifdef
        print CLASS "#ifdef PHP_QT_".unwrapClassType($method->{ReturnType})." // return type\n\n"
            if cplusplusToZVAL($method->{ReturnType}) eq "OBJECT";

        print CLASS "if(ZEND_NUM_ARGS() == ".$count_args.$zend_args_query."){";

        # class check if object
        if($ce_ptr_query ne ""){
            print CLASS "".expandIfdefs(@ifdef_stack);  # ifdef PHP_QT_QString
            print CLASS " if(".$ce_ptr_query."){";
            handleArguments($params,$method->{ReturnType},$method->{Flags}, $methodname); # argument handling
            print CLASS "}\n";
            print CLASS "".expandEndifs(@ifdef_stack);  # endif

        # simple types
        } else {
            handleArguments($params,$method->{ReturnType},$method->{Flags}, $methodname); # argument handling
        }
        print CLASS "}";

        #
        # for all optional parameters
        #
        foreach $cpp_arg (@stack_optional){

            $params .= $cpp_arg.","; # collect args for this try
            $zend_arg = cplusplusToZVAL($cpp_arg);

            # intercept unknown types
            if($zend_arg eq "unknown"){
                print CLASS "\n// notice: unknown argument ".$cpp_arg.", skipped\n";
                next ARGLIST;
            }

            $zend_args_query .= " && Z_TYPE_P(args[".$count_args++."]) == IS_".$zend_arg;

            # type check
            print CLASS "if(ZEND_NUM_ARGS() == ".$count_args.$zend_args_query."){";

            # if object
            if($ce_ptr_query ne ""){
                print CLASS "".expandIfdefs(@ifdef_stack);  # ifdef PHP_QT_QString
                print CLASS " if(".$ce_ptr_query."){";  # ask object types
                handleArguments($params,$method->{ReturnType},$method->{Flags}, $methodname); # argument handling
                print CLASS "}\n";
                print CLASS "".expandEndifs(@ifdef_stack);  # endif
            # if simple type
            } else {
                # argument handling
                handleArguments($params,$method->{ReturnType},$method->{Flags}, $methodname);
            }
            print CLASS "}"; # end type check

        } # stack_optional

        # ifdef
        print CLASS "#endif // return type\n\n" if cplusplusToZVAL($method->{ReturnType}) eq "OBJECT";
    }

    print CLASS "php_error(E_ERROR,\"could not parse argument\");";
    print CLASS "}\n";

}

#
# prepare and invoke args for a try
#

sub handleArguments
{
    my ( $params, $return, $flags, $methodname ) = @_;

    my $returnType = cplusplusToZVAL($return);      # example: BOOL, LONG, DOUBLE, STRING, OBJECT
    if($returnType eq "unknown"){
        print CLASS "php_error(E_ERROR,\"unsupported return type ".$return."\");";
        return;
    }

    if($flags =~ /s/){
    } else {
        print CLASS "if(getThis() == NULL){php_error(E_ERROR,\"method '".$methodname."' is not static\"); RETURN_NULL;}";
    }


    my $preparation;    # invoke zend to cpp, prepare return object if necessary
    my $cpp_call_params;    # the args passed to Qt method
    my $count_args = 0;
    my @cargs = kdocUtil::splitUnnested(",", $params);  # fetch args

    $preparation .= "\n\t/// try ".$params."\n";
    $preparation .= "if(getThis != NULL){".$classname." *selfpointer = static_cast<".$classname."*>(PHP_QT_FETCH());}";

    # argument handling
    foreach $arg (@cargs) {

        $argType = cplusplusToZVAL($arg);

        # should never happen, checked above
        if($argType eq "unknown"){
            print CLASS "\n// unknown, skipped: ".$arg."\n";
            return; # return arg handling
        }

        # for all arg types, e.g. bool*
        $classType = unwrapClassType($arg);

        # handling of pointers, references
        my $postfix, $prefix, $prefix_ZVAL;
        if(checkRPN($arg) eq "reference"){
            $postfix = "&"; # cast (old c cast)
            $prefix = "*";  # dereferencing the pointer
        } elsif (checkRPN($arg) eq "pointer"){
            $postfix = "*"; # cast
            $prefix = "";   # nothing, is already a pointer
            $prefix_ZVAL = "&";
        } elsif (checkRPN($arg) eq "normal"){
            $prefix = "*";  # dereferencing the pointer
            $postfix = "";  # nothing to do here
        }

        $cpp_call_params .= "(".checkConst($arg)." ".$classType.$postfix.")";

        if($argType eq "OBJECT"){
            # example: QString *cpp_arg_0 = static_cast<QString*>(php_qt_fetch(args[0]);
            $preparation .= $classType." *cpp_arg_".$count_args." = static_cast<".$classType."*>(php_qt_fetch(args[".$count_args."]));\n";
            $cpp_call_params .= $prefix."cpp_arg_".$count_args." ";
        } else {
            # example: Z_LVAL_P(arg_0), Z_STRVAL(arg_0)
            $cpp_call_params .= $prefix_ZVAL."Z_".invokeTypeToZ_XVAL($argType)."VAL_P(args[".$count_args."]) ";
        }

        $cpp_call_params .= ",";
        $count_args++;
    }

    chop($cpp_call_params); # remove last comma

    print CLASS $preparation;   # printout declaration

    # return handling
    my $returnClassName = unwrapClassType($return); # example: QString (from QString &c)
    my $prefix, $postfix, $infix;

    if(checkRPN($return) eq "reference"){       # tested
        $prefix = $returnClassName."&";
        $infix = "&";
    } elsif (checkRPN($return) eq "pointer"){
        $prefix = $returnClassName."* ";
    } elsif (checkRPN($return) eq "normal"){    # tested with non-objects
        # allocate memory on the heap
        if($returnType eq "OBJECT"){
            print CLASS $returnClassName." *return_object = new ".$returnClassName.";\n";
        }
        $prefix = "*";
    }

    if($returnType eq "OBJECT"){
        if($flags =~ /s/){
            print CLASS "if(getThis() == NULL){".$prefix." return_object = static_cast<"                .$returnClassName.$infix.">(".$classname."::".$method->{astNodeName}."(".$cpp_call_params."));} else {print CLASS "                .$prefix." return_object = static_cast<"               .$returnClassName.$infix.">(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));}";
        } else {
            print CLASS $prefix." return_object = static_cast<"
                .$returnClassName.$infix.">(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));";
        }
        print CLASS "zend_class_entry *ce;";
        print CLASS "object_init_ex(return_value, QString_ce_ptr);";
        print CLASS "zend_rsrc_list_entry le;";
        print CLASS "le.ptr = (void*) ".$infix."return_object;";
        print CLASS "php_qt_register(return_value,le);";
        print CLASS "return;";
    } else {
        if($method->{astNodeName} eq $classname){
            print CLASS "PHP_QT_REGISTER(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));";
        } else {
            if($flags =~ /s/){
                print CLASS "if(getThis() == NULL){RETURN_".$returnType."(".$classname."::"
                    .$method->{astNodeName}."(".$cpp_call_params."));} else {RETURN_"
                    .$returnType."(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));}";
            } else {
                print CLASS "RETURN_".$returnType."(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));";
            }
        }
    }
}

# group and merge methods by name, for argument handling

sub mergeMethods
{
	my ( $method )  = @_;

    # looking for existing list
    foreach my $key ( %methods ) {
        if ( $key->{astNodeName} eq $method->{astNodeName} ) {
            #add to existing list
            push(@{$methods{ $method->{astNodeName} }->{"argList"}},$method);
	        return;
 		}
    }

    # add new list
    $methods{ $method->{astNodeName} } = $method;

    my $methodlist = ();
    $methods{ $method->{astNodeName} }->AddProp("methodname", $method->{astNodeName});
    $methods{ $method->{astNodeName} }->AddPropList("argList", $methodlist);

    push(@{$methods{ $method->{astNodeName} }->{"argList"}},$method);

}

# write documentation for method

sub writeMethodDoc
{
    my ( $method ) = @_;

        print CLASS "/*!\n";
        print CLASS " * method ".$method->{astNodeName}."\n";
        print CLASS " * \n";

        foreach my $overloadedmethod (@{$method->{"argList"}})
        {
            my @cargs = kdocUtil::splitUnnested(",", $overloadedmethod->{Params});

            # mark as overloaded
            if(@cargs>0) {
                print CLASS " * \n";
                print CLASS " * overloaded args:\n";
            } else {
                print CLASS " * \@param: -\n";
            }

            foreach my $arg ( @cargs ) {
                print CLASS " * \@param\t".$arg."\n";
            }

        }

        print CLASS " * \n";
        print CLASS " * \@access\t".$method->{Access}."\n";
        print CLASS " * \@return\t".$method->{ReturnType}."\n";
        print CLASS " * \@flags\t".$method->{Flags}."\n";
        print CLASS " */\n\n"

}

################################################################################
#                                                                              #
#   HELPER FUNCTIONS                                                           #
#                                                                              #
################################################################################

sub openAllFiles
{

	mkpath( $outputdir ) unless -f $outputdir;
    mkpath( $outputdir."/classes/" ) unless -f $outputdir."/classes/";

    # AG_ZEND_CLASS_ENTRY
    my $file_ag_zend_class_entry = "$outputdir/ag_zend_class_entry.inc";
    open( AG_ZEND_CLASS_ENTRY, ">$file_ag_zend_class_entry" ) || die "Couldn't create $file_ag_zend_class_entry\n";
    $file_ag_zend_class_entry =~ s/\.h/.h/;

    # AG_EXTERN_ZEND_CLASS_ENTRY
    my $file_ag_extern_zend_class_entry = "$outputdir/ag_extern_zend_class_entry.inc";
    open( AG_EXTERN_ZEND_CLASS_ENTRY, ">$file_ag_extern_zend_class_entry" ) || die "Couldn't create $file_ag_extern_zend_class_entry\n";
    $file_ag_extern_zend_class_entry =~ s/\.h/.h/;

    # AG_ZEND_PHP_QT
    my $file_ag_zend_php_qt = "$outputdir/ag_zend_php_qt.inc";
    open( AG_ZEND_PHP_QT, ">$file_ag_zend_php_qt" ) || die "Couldn't create $file_ag_zend_php_qt\n";
    $file_ag_zend_php_qt =~ s/\.h/.h/;

    # AG_CONFIGM4
    my $file_ag_configm4 = "$outputdir/ag_configm4.inc";
    open( AG_CONFIGM4, ">$file_ag_configm4" ) || die "Couldn't create $file_ag_configm4\n";
    $file_ag_configm4 =~ s/\.h/.h/;

    # AG_QT_MINIT
    my $file_ag_qt_minit = "$outputdir/ag_qt_minit.inc";
    open( AG_QT_MINIT, ">$file_ag_qt_minit" ) || die "Couldn't create $file_ag_qt_minit\n";
    $file_ag_qt_minit =~ s/\.h/.h/;

    # AG_PHP_QT_CPP
    my $file_ag_php_qt_cpp = "$outputdir/ag_php_qt_cpp.inc";
    open( AG_PHP_QT_CPP, ">$file_ag_php_qt_cpp" ) || die "Couldn't create $file_ag_php_qt_cpp\n";
    $file_ag_php_qt_cpp =~ s/\.h/.h/;

    print AG_PHP_QT_MINIT "\n";
    print AG_ZEND_PHP_QT "/*
 * PHP-Qt - The PHP language bindings for Qt
 *
 * Copyright (C) 2006
 * Thomas Moenicke <tm\@ippfp.org>,
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#ifndef PHP_PHP_QT_H
#define PHP_PHP_QT_H

extern zend_module_entry php_qt_module_entry;
#define phpext_php_qt_ptr &php_qt_module_entry

#ifdef ZTS
#include \"TSRM.h\"
#endif

PHP_MINIT_FUNCTION(php_qt);
PHP_MSHUTDOWN_FUNCTION(php_qt);
PHP_RINIT_FUNCTION(php_qt);
PHP_RSHUTDOWN_FUNCTION(php_qt);
PHP_MINFO_FUNCTION(php_qt);

PHP_FUNCTION(confirm_php_qt_compiled);	/* For testing, remove later. */

/* emulate SIGNAL(), SLOT() macros */
PHP_FUNCTION(SIGNAL);
PHP_FUNCTION(SLOT);
    \n\n";

}

# write stuff to files
sub writeAllFiles
{
    my ($node) = @_;

    print AG_ZEND_CLASS_ENTRY "zend_class_entry *",$node->{astNodeName},"_ce_ptr;\n";
    print AG_ZEND_CLASS_ENTRY "#ifndef PHP_QT_".$classname."\n#define PHP_QT_".$classname."\n\n";

    print AG_CONFIGM4 "\tqt/classes/",lc($node->{astNodeName}),".cpp \\ \n";
    print AG_EXTERN_ZEND_CLASS_ENTRY "extern zend_class_entry *",$node->{astNodeName},"_ce_ptr;\n";
    print AG_EXTERN_ZEND_CLASS_ENTRY "void \t_register_",$node->{astNodeName},"();\n";


    print PHP_QT_MINIT "\n\t_register_",$node->{astNodeName},"(TSRMLS_C);\n";
    print AG_QT_MINIT "\n\t_register_",$node->{astNodeName},"(TSRMLS_C);\n";

}

sub closeAllFiles
{

    print AG_ZEND_PHP_QT "\n/*
  	Declare any global variables you may need between the BEGIN
	and END macros here:

ZEND_BEGIN_MODULE_GLOBALS(php_qt)
	long  global_value;
	char *global_string;
ZEND_END_MODULE_GLOBALS(php_qt)
*/

#ifdef ZTS
#define PHP_QT_G(v) TSRMG(php_qt_globals_id, zend_php_qt_globals *, v)
#else
#define PHP_QT_G(v) (php_qt_globals.v)
#endif

#endif	/* PHP_PHP_QT_H */
\n
    ";

    close AG_ZEND_CLASS_ENTRY;
    close AG_EXTERN_ZEND_CLASS_ENTRY;
    close AG_ZEND_PHP_QT;
    close AG_CONFIGM4;
    close AG_QT_MINIT;
    close AG_PHP_QT_CPP;
}

sub openClassFile
{

    my ( $node ) = @_;

	my $file = join("__", kdocAstUtil::heritage($node)).".cpp";
    $file = $outputdir."/classes/".lc($file);

	if( $#{$node->{Kids}} < 0 || $node->{Access} eq "private") {
		return;
	}
	open( CLASS, ">$file" ) || die "Couldn't create $file\n";
	$file =~ s/\.h/.cpp/;

print CLASS "/*
 * PHP-Qt - The PHP language bindings for Qt
 *
 * Copyright (C) 2006
 * Thomas Moenicke <tm\@ippfp.org>,
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
";

	print CLASS " * ", $node->{astNodeName}, ".cpp - ", $node->{astNodeName}, " PHP implementation.\n";
	print CLASS $docTop;

    print CLASS "
#include <iostream>
using namespace std;\n";

    print CLASS "#include \"../php_qt.h\"\n\n";
    print CLASS "\n#include <$node->{astNodeName}>\n";

}

# check additional header files
# hardcoded
sub checkIncludes(){
    my ($class) = @_;
    my $return;

    if($class->{astNodeName} eq "QFont") {
        $return .= "#include <QStringList>\n";
    }
    if($class->{astNodeName} eq "QPainter") {
        $return .= "#include <QPainterPath>\n";
    }
    if($class->{astNodeName} eq "QApplication") {
        $return .= "#include <QPalette>\n#include <QFontMetrics>\n#include <QIcon>\n";
    }
    if($class->{astNodeName} eq "QCoreApplication") {
        $return .= "#include <QStringList>\n";
    }
    if($class->{astNodeName} eq "QWidget") {
        $return .= "#include <QIcon>\n";
    }

    print CLASS $return;
}

sub DerivedClass
{
    my ($node) = @_;

    print CLASS "#include <QMetaMethod>
    class ".$classname."_php_qt : public ".$classname."{

    public:
        ".$classname."_php_qt(zval* zend_ptr);

        zval* zend_ptr;
        QMetaObject* dynamicMetaObject;

        const QMetaObject* metaObject() const;
        int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
    };
    PHP_QT_MOC(".$classname.");
";
# TODO:
# virtual and private classes

}

#

sub Inheritance
{
    my ($node) = @_;

    # find ancestors
    my @ancestors = ();
	Iter::Ancestors( $node, $rootnode, undef, undef,
		sub {
			my ( $ances, $name, $type, $template ) = @_;
            push @ancestors, $name;
		},
		undef
	);

    # print mainfile stuff
    print AG_PHP_QT_CPP "
    {NULL,NULL,NULL}
};\n";

    my $zend_inherit = $node->{astNodeName}."_ce_ptr = zend_register_internal_class(&ce TSRMLS_CC);";
    my $ancestor;

    my $first = 1;
	foreach $ancestor ( @ancestors ) {
        if($first) {
            $zend_inherit = $node->{astNodeName}."_ce_ptr = zend_register_internal_class_ex(&ce TSRMLS_CC, ".$ancestor."_ce_ptr,NULL TSRMLS_CC);\n";
            $first = 0;
        } else {
           $zend_inherit .= "\tzend_do_inheritance(".$node->{astNodeName}."_ce_ptr, ".$ancestor."_ce_ptr TSRMLS_CC);\n";
        }
	}

    print AG_PHP_QT_CPP "
void _register_",$node->{astNodeName},"(TSRMLS_D)
{
    zend_class_entry ce;
    INIT_CLASS_ENTRY(ce,\"",$node->{astNodeName},"\",",$node->{astNodeName},"_methods);
    ",$zend_inherit,"
";

# 	Iter::MembersByType ( $node,
# 		sub { print CLASS "", $_[0], ""; print CLASS "", $_[0], "";  },
# 		sub {	my ($node, $kid ) = @_;
#             if ($kid->{NodeType} eq "property"){
#                 print AG_PHP_QT_CPP "\tPHP_QT_DECLARE_PROPERTY(\"$kid->{astNodeName}\");\n";
#             }
#         },
# 		sub { print CLASS ""; print JNISOURCE ""; }
# 	);

    print AG_PHP_QT_CPP "
}\n";


}

sub closeClassFile
{
    close CLASS;
}

sub cplusplusToZVAL
{
	my ( $cplusplusType )  = @_;

	if ( $cplusplusType =~ /bool/) {
		return "BOOL";
	} elsif ( $cplusplusType =~ /\s*void\s*\**/ ) {
		return "NULL";
	} elsif ( $cplusplusType =~ /\s*::\s*/) {
		return "LONG";
	} elsif ( $cplusplusType =~ /\s*\bint\s*\&*/) {
		return "LONG";
	} elsif ( $cplusplusType =~ /\s*int\s*\&*/) {
		return "LONG";
	} elsif ( $cplusplusType =~ /\s*short\s*\&*/) {
		return "LONG";
	} elsif ( $cplusplusType =~ /\s*char\s*\*\*/ ) {
		return "STRING";
	} elsif ( $cplusplusType =~ /\s*char\s*\**/ ) {
		return "STRING";
	} elsif ( $cplusplusType =~ /\s*unsigned int\s*\**/ ) {
		return "LONG";
	} elsif ( $cplusplusType =~ /\s*unsigned short\s*\**/ ) {
        return "LONG";
	} elsif ( $cplusplusType =~ /\s*unsigned long\s*\**/ ) {
		return "LONG";
	} elsif ( $cplusplusType =~ /\s*float\s*\**/ ) {
        return "DOUBLE";
	} elsif ( $cplusplusType =~ /\s*double\s*\**/ ) {
        return "DOUBLE";
	} elsif ( $cplusplusType =~ /\s*unsigned char\s*\**/ ) {
		return "STRING";
	} elsif ( $cplusplusType =~ /Q/ ) {
        return "OBJECT";
	} else {
        return "unknown";
    }
}

# helper: unwraps the classtype from arg string
sub unwrapClassType
{
    my ($argString) = @_;

    $argString =~ s/const//;
    $argString =~ s/\*//;
    $argString =~ s/\&//;

    # skip spaces
    @c = split(/ /,$argString);
    foreach(@c){
        if($_ ne ""){
            return $_;
        }
    }

    return $c[0];

}

# checks for references, pointers, objects

sub checkRPN
{
    my ($e) = @_;

    my $rpo;

    if($e =~ /\*/){
        $rpo = "pointer";
    } elsif ($e =~ /\&/) {
        $rpo = "reference";
    } else {
        $rpo = "normal";
    }

    return $rpo;

}

# checks for const
sub checkConst
{
    my ($e) = @_;
    if($e =~ /const/){
        return "const";
    }
    return "";
}

# invokes types for the Z_XVAL macro
sub invokeTypeToZ_XVAL
{
    my ($type) = @_;
    my $Z_VAL = substr($type,0,1);
    if($Z_VAL eq "S"){
        return "STR";
    }
    # due problems with references
    if($Z_VAL eq "B"){
        return "L";
    }

    return $Z_VAL;
}

#
# expand #ifdef PHP_QT_QString ... #endif statements
#

sub expandIfdefs
{
    my (@ifdef_stack) = @_;
    my $ifdef;
    foreach $def (@ifdef_stack){
        $ifdef .= "#ifdef PHP_QT_".$def."\n";
    }
    return $ifdef;
}

sub expandEndifs
{
    my (@ifdef_stack) = @_;
    my $endif;
    foreach $def (@ifdef_stack){
        $endif .= "#endif\n\n";
    }
    return $endif;
}

1;
