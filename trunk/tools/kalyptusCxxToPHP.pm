#***************************************************************************
#    copyright            : (C) 2005 Thomas Moenicke
#    email                : tm@ippfp.org
#    author               : Thomas Moenicke, based on the CSharp generation code
#                            by Adam Treat & Richard Dale.
#***************************************************************************/

#/***************************************************************************
# *                                                                         *
# *   This program is free software; you can redistribute it and/or modify  *
# *   it under the terms of the GNU General Public License as published by  *
# *   the Free Software Foundation; either version 2 of the License, or     *
# *   (at your option) any later version.                                   *
# *                                                                         *
#***************************************************************************/

# TODO
#   - support for all types in method calls
#   - fit cplusplusToZEND, cplusplusToInvoke, cplusplusToMacro
#   - setter methods support only one php property (adequate, I believe)
#   - marshalling method arguments

package kalyptusCxxToPHP;

use File::Path;
use File::Basename;

use Carp;
use Ast;
use kdocAstUtil;
use kdocUtil;
use Iter;
use kalyptusDataDict;

use strict;
no strict "subs";

use vars qw/ @clist $host $who $now $gentext %functionId $docTop
	$lib $rootnode $outputdir $opt $debug $typeprefix $eventHandlerCount
	$pastaccess $pastname $pastreturn $pastparams $nullctor $ctorCount @properties @functions @constructors %methods *CLASS *ZEND_PHP_QT *HEADER *QTCTYPES *KDETYPES /;

BEGIN
{
    @clist = ();

    # Page footer

	$who = kdocUtil::userName();
	$host = kdocUtil::hostName();
	$now = localtime;
	$gentext = "$who using kalyptus $main::Version.";

	$docTop =<<EOF
 * begin           : $now
 * generated by    : $gentext
 */
EOF
}

# TODO here:
# one is needed for php types, one for zend types (e.q. zval)
sub cplusplusToZEND
{
	my ( $cplusplusType )  = @_;
	if ( $cplusplusType =~ /bool/ && kalyptusDataDict::ctypemap($cplusplusType) eq "int" ) {
		return "bool";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*void\s*\**/ ) {
		return "NULL";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*int\s*\&*/ ) {
		return "long";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*int\s*\*/) {
		return "int[]";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*double\s*\*/ ) {
		return "double[]";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*short\s*\*/ ) {
		return "short[]";
	} elsif ( $cplusplusType =~ /QByteArray/ || $cplusplusType =~ /QBitArray/ ) {
		return "byte[]";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\*\*/ ) {
		return "char";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\**/ ) {
		return "char* ";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned int\s*\**/ ) {
		return "uint";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned short\s*\**/ ) {
		return "ushort";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned long\s*\**/ ) {
		return "ulong";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned char\s*\**/ ) {
		return "string";
	} elsif ( $cplusplusType =~ /^GUID/ ) {
		return "System.Guid";
	} elsif ( $cplusplusType =~ /^FILE/ ) {
		return "string";
	} elsif ( $cplusplusType =~ /^_NPStream/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^QPtrCollection/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^QStyleHintReturn/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^type/i ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^Key/ || $cplusplusType =~ /^key_type/ || $cplusplusType =~ /^K/) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^QUnknownInterface/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^GDHandle/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^QTextParag/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^QDiskFont/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^QDomNodePrivate/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^Display/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^QUuid/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^Q_REFCOUNT/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^EventRef/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^MSG/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^QWSEvent/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^XEvent/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^CGContextRef/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^QWSDecoration/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^QTextFormat/ || $cplusplusType =~ /^QTextDocument/ || $cplusplusType =~ /^QTextCursor/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^QSqlRecordPrivate/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^Text/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^Event/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /^NavDirection/ ) {
		return "IntPtr";
	} elsif (
			$cplusplusType =~ /^pointer$/
			 || $cplusplusType =~/T\*$/
			 || $cplusplusType =~/T\&*$/
			 || $cplusplusType =~/T1\&*$/
			 || $cplusplusType =~/T2\&*$/
			 || $cplusplusType =~/^Iterator/i
			 || $cplusplusType =~/^_iterator/i
			 || $cplusplusType =~/^reference/
			 || $cplusplusType =~/^_reference/) {
		return "IntPtr";
	} elsif ($cplusplusType =~ /::/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /::/ ||
			 $cplusplusType =~ /&$/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /&$/ ||
			 $cplusplusType =~ /\*/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /\*/) {

#		$cplusplusType =~ s/::/./g;
#		$cplusplusType =~ s/&//g;
#		$cplusplusType =~ s/\*//g;
#		return $cplusplusType;
        return "zval*";

	} else {
 		return kalyptusDataDict::ctypemap($cplusplusType);
	}
}

# zend.h:
#/* data types */
#/* All data types <= IS_BOOL have their constructor/destructors skipped */
#define IS_NULL		0
#define IS_LONG		1
#define IS_DOUBLE	2
#define IS_BOOL		3
#define IS_ARRAY	4
#define IS_OBJECT	5
#define IS_STRING	6
#define IS_RESOURCE	7
#define IS_CONSTANT	8
#define IS_CONSTANT_ARRAY	9


sub cplusplusToZENDType
{
	my ( $cplusplusType )  = @_;
	if ( $cplusplusType =~ /bool/ && kalyptusDataDict::ctypemap($cplusplusType) eq "int" ) {
		return "BOOL";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*void\s*\**/ ) {
		return "NULL";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*int\s*\&*/ ) {
		return "LONG";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*int\s*\*/) {
		return "ARRAY";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*double\s*\*/ ) {
		return "ARRAY";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*short\s*\*/ ) {
		return "ARRAY";
	} elsif ( $cplusplusType =~ /QByteArray/ || $cplusplusType =~ /QBitArray/ ) {
		return "ARRAY";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\*\*/ ) {
		return "STRING";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\**/ ) {
		return "STRING";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned int\s*\**/ ) {
		return "LONG";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned short\s*\**/ ) {
		return "LONG";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned long\s*\**/ ) {
		return "LONG";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned char\s*\**/ ) {
		return "STRING";
	} elsif ( $cplusplusType =~ /^GUID/ ) {
		return "System.Guid";
	} elsif ( $cplusplusType =~ /^FILE/ ) {
		return "STRING";
	} elsif ( $cplusplusType =~ /^_NPStream/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^QPtrCollection/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^QStyleHintReturn/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^type/i ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^Key/ || $cplusplusType =~ /^key_type/ || $cplusplusType =~ /^K/) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^QUnknownInterface/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^GDHandle/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^QTextParag/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^QDiskFont/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^QDomNodePrivate/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^Display/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^QUuid/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^Q_REFCOUNT/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^EventRef/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^MSG/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^QWSEvent/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^XEvent/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^CGContextRef/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^QWSDecoration/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^QTextFormat/ || $cplusplusType =~ /^QTextDocument/ || $cplusplusType =~ /^QTextCursor/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^QSqlRecordPrivate/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^Text/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^Event/ ) {
		return "OBJECT";
	} elsif ( $cplusplusType =~ /^NavDirection/ ) {
		return "OBJECT";
	} elsif (
			$cplusplusType =~ /^pointer$/
			 || $cplusplusType =~/T\*$/
			 || $cplusplusType =~/T\&*$/
			 || $cplusplusType =~/T1\&*$/
			 || $cplusplusType =~/T2\&*$/
			 || $cplusplusType =~/^Iterator/i
			 || $cplusplusType =~/^_iterator/i
			 || $cplusplusType =~/^reference/
			 || $cplusplusType =~/^_reference/) {
		return "OBJECT";
	} elsif ($cplusplusType =~ /::/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /::/ ||
			 $cplusplusType =~ /&$/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /&$/ ||
			 $cplusplusType =~ /\*/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /\*/) {

#		$cplusplusType =~ s/::/./g;
#		$cplusplusType =~ s/&//g;
#		$cplusplusType =~ s/\*//g;
#		return $cplusplusType;
        return "OBJECT";

	} else {
 		return kalyptusDataDict::ctypemap($cplusplusType);
	}
}


sub cplusplusToPInvoke
{
	my ( $cplusplusType )  = @_;
	if ( $cplusplusType =~ /bool/ && kalyptusDataDict::ctypemap($cplusplusType) eq "int" ) {
		return "bool";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*void\s*\*/ ) {
		return "int";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*int\s*\&*/ ) {
		return "int";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*int\s*\*/) {
		return "int[]";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*double\s*\*/ ) {
		return "double[]";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*short\s*\*/ ) {
		return "short[]";
	} elsif ( $cplusplusType =~ /QByteArray/ || $cplusplusType =~ /QBitArray/ ) {
		return "byte[]";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\*\*/ ) {
		return "string[]";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*char\s*\**/ ) {
		return "string";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned int\s*\**/ ) {
		return "uint";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned short\s*\**&*/ ) {
		return "ushort";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned long\s*\**/ ) {
		return "ulong";
	} elsif ( kalyptusDataDict::ctypemap($cplusplusType) =~ /\s*unsigned char\s*\**/ ) {
		return "string";
	} elsif ( $cplusplusType =~ /^GUID/ ) {
		return "System.Guid";
	} elsif ( $cplusplusType =~ /^FILE/ ) {
		return "string";
	} elsif ( $cplusplusType =~ /^_NPStream/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^QPtrCollection/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^QStyleHintReturn/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^type/i ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^Key/ || $cplusplusType =~ /^key_type/ || $cplusplusType =~ /^K/) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^QUnknownInterface/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^GDHandle/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^QTextParag/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^QDiskFont/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^QDomNodePrivate/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^Display/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^QUuid/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^Q_REFCOUNT/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^EventRef/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^MSG/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^QWSEvent/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^XEvent/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^CGContextRef/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^QWSDecoration/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^QTextFormat/ || $cplusplusType =~ /^QTextDocument/ || $cplusplusType =~ /^QTextCursor/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^QSqlRecordPrivate/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^Text/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^Event/ ) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /^NavDirection/ ) {
		return "RawObject";
	} elsif (
			$cplusplusType =~ /^pointer$/
			 || $cplusplusType =~/T\*$/
			 || $cplusplusType =~/T\&*$/
			 || $cplusplusType =~/T1\&*$/
			 || $cplusplusType =~/T2\&*$/
			 || $cplusplusType =~/^iterator/i
			 || $cplusplusType =~/^_iterator/i
			 || $cplusplusType =~/^reference/
			 || $cplusplusType =~/^_reference/) {
		return "RawObject";
	} elsif ( $cplusplusType =~ /&$/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /&$/ ) {
		return "IntPtr";
	} elsif ( $cplusplusType =~ /\*/ || kalyptusDataDict::ctypemap($cplusplusType) =~ /\*/ ) {
		return "IntPtr";
	} else {
		return kalyptusDataDict::ctypemap($cplusplusType);
	}
}

sub cplusplusToMacro
{
	my ( $class, $cnode )  = @_;

    my $functionname = $cnode->{astNodeName};
    my $classname = $class->{astNodeName};

    my $function = $cnode;  # for better reading
    my $access = $function->{Access};
    my $returntype = $function->{ReturnType};

# skip
    if ($functionname eq "qObject") {
        print CLASS "// skip ",$functionname,"\n";
        return;
    }

# make sure that this function will be added only at one time
    my $mark = 0;
    my $func;
    foreach $func ( @functions ) {
        if ( $func eq $functionname ) {
            print CLASS "// marked for overloading: ",$functionname,"\n";
            $mark = 1;
        }
    }

# print doc in phpDocumentor style
    if(!$mark){

        my $c = @functions;
        if($c>0){
            print CLASS "\t}\n";
            print CLASS "}\n";
        }

        push @functions, $functionname;
        print CLASS "

/*********************************
 *    class     ",$classname,"
 *    function  ",$functionname,"
 *    flags:    ",$function->{Flags},"
 *\n";

        my $count = 0;
        foreach $b ( @{$cnode->{ParamList}} ) {
            print CLASS " *    \@param   ",$b->{ArgType},"\n";
        }
        if (!$count) {
            print CLASS " *    \@param   -\n";
        }

        print CLASS "
 *    \@access   ",$access,"
 *    \@return   ",$returntype,"
*********************************/
";
    } else {
        print CLASS "\t}\n";
    }

    # skip virtuals
    if ( $function->{Flags} =~ /v/ ){
        print CLASS "ZEND_METHOD(",$classname,", ",$functionname,"){\n";
        print CLASS "// marked as virtual, skipped\n";
        print CLASS "\tphp_printf(\"%s(): virtual functions are not yet implemented",'\n',"\",get_active_function_name(TSRMLS_C));\n";
        print CLASS "}\n";
        return;
    }

    if(!$mark){
        print CLASS "ZEND_METHOD(",$classname,", ",$functionname,"){\n";
    }

    my $p = @{$cnode->{ParamList}};
    print CLASS "\tif (ZEND_NUM_ARGS() == ",$p,"){\n";

    my $count = 0;
    my $paratype; # for zend
    my $short = ",\"";
    my $paraf;  # for qt
    my @objects;

# write method implementation
    foreach $b ( @{$cnode->{ParamList}} ) {

        if($count > 0){
            $paraf .= ", ";
        }
        print CLASS "\t// ",$b->{DefaultValue},"\n";
# todo: long, double
        if ( $b->{ArgType} =~ /char/ ) {
            print CLASS "\t\tchar* var_",$count,";\n";
            print CLASS "\t\tint* len_",$count,";\n\n";
            $paratype .= ", &var_".$count.", &len_".$count;
            $paraf .= " var_".$count;
            $short .= "s";
        } elsif ( $b->{ArgType} =~ /int/ ) {
            print CLASS "\t\tlong var_",$count,";\n";
            $paratype .= ", &var_".$count;
            $paraf .= "(".$b->{ArgType}.") var_".$count;
            $short .= "l";
        } elsif ( $b->{ArgType} =~ /bool/ ) {
            print CLASS "\t\tbool* var_",$count,";\n";
            $paratype .= ", &var_".$count;
            $paraf .= "(".$b->{ArgType}.") var_".$count;
            $short .= "b";
        }
        else {
            print CLASS "\t\tzval* var_",$count,";\n\n";
            $paratype .= ", &var_".$count;
            $paraf .= " var_".$count;
            $short .= "o";
            push @objects, "var_".$count;
        }

        $count++;
    }
    $short .= "\"";



    if( $count ) {
        print CLASS "\t\tif(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC",$short,$paratype,") == FAILURE) {\n";
        print CLASS "\t\t\tRETURN_FALSE;\n";
        print CLASS "\t\t}\n";
    }

# properties:
    # we have a nxn relation
    my $prop;
    my $obj_tmp;

    foreach $prop ( @properties ) {

       if ( $prop->{WRITE} =~ /$functionname/ ) {
        foreach $obj_tmp ( @properties ) {
            # mostly these methods are setmethods with only one argument
            # maybe source of error
# todo: test with QLCDNumber
            my $postfix = cplusplusToZEND($prop->{type});
            $postfix =~ s/zval\*//;
            if ( $postfix ) {
                $postfix = "_".cplusplusToZEND($prop->{type});
            }

            print CLASS  "\t\tzend_update_property",$postfix,"(Z_OBJCE_P(getThis()),getThis(),\"",$prop->{astNodeName},"\",strlen(\"",$prop->{astNodeName},"\"),var_0 TSRMLS_CC);\n";
            print CLASS "\t}\n";
            return;
        }
       }
    }

    my $rt = cplusplusToZEND($returntype);

    my $obj;

        foreach $obj ( @objects ) {
            print CLASS "\t\tQObject* tmp_",$obj," = (QObject*) php_qt_fetch(",$obj,");\n";
            $paraf =~ s/$obj/tmp_$obj/;
        }

        print CLASS "\t\t$classname *o = ($classname*) PHP_QT_FETCH();\n";


        if ( $rt eq "NULL" ) {
            print CLASS "\t\to->",$functionname,"(",$paraf,");\n";
            print CLASS "\t\tRETURN_NULL();\n";
        } elsif ( $rt =~ /zval/ ) {

# TODO: consider 'const',
# and non-pointer types, pointer types
            print CLASS "\t\t",$returntype," obj = (",$returntype,") o->",$functionname,"(",$paraf,");\n";
            print CLASS "\t\tzend_class_entry *ce;                                   \n";
#            print CLASS "\tif(obj != NULL) {                                       \n";
            print CLASS "\t\t    object_init_ex(return_value, ",$classname,"_ce_ptr);     \n";
            print CLASS "\t\t    zend_rsrc_list_entry le;                            \n";
            print CLASS "\t\t    le.ptr = &obj;                                       \n";
            print CLASS "\t\t    php_qt_register(return_value,le);                   \n";
            print CLASS "\t\t    return;                                             \n";
#            print CLASS "\t}                                                       \n";
#            print CLASS "\telse                                                    \n";
#            print CLASS "\t    RETURN_NULL();                                      \n";

        } else {
            print CLASS "\t\tRETURN_",uc($rt),"(o->",$functionname,"(",$paraf,"));\n" if defined $rt;
        }

    if( $cnode->{Flags} =~ /s/ ){
        $access .= "|ZEND_ACC_STATIC";
    }

    print ZEND_PHP_QT "\nZEND_METHOD(",$class->{astNodeName},", ",$functionname,");";
# code snippets for php_qt.cpp here
    $access = uc($access);
    $access =~ s/_SLOTS//;
    $access =~ s/_SIGNALS//;
    print PHP_QT_CPP "\tZEND_ME(",$classname,",",$functionname,",NULL,ZEND_ACC_",$access,")\n";

}

sub writeDoc
{
	( $lib, $rootnode, $outputdir, $opt ) = @_;

	$debug = $main::debuggen;

	mkpath( $outputdir ) unless -f $outputdir;

    # make zend_php_qt.h header file
	my $file_zend_php_qt = "$outputdir/zend_php_qt.h";
	open( ZEND_PHP_QT, ">$file_zend_php_qt" ) || die "Couldn't create $file_zend_php_qt\n";
	$file_zend_php_qt =~ s/\.h/.h/;

    print ZEND_PHP_QT "/*
  +----------------------------------------------------------------------+
  | PHP Version 5                                                        |
  +----------------------------------------------------------------------+
  | Copyright (c) 1997-2004 The PHP Group                                |
  +----------------------------------------------------------------------+
  | This source file is subject to version 3.0 of the PHP license,       |
  | that is bundled with this package in the file LICENSE, and is        |
  | available through the world-wide-web at the following url:           |
  | http://www.php.net/license/3_0.txt.                                  |
  | If you did not receive a copy of the PHP license and are unable to   |
  | obtain it through the world-wide-web, please send a note to          |
  | license\@php.net so we can mail you a copy immediately.               |
  +----------------------------------------------------------------------+
  | Author:                                                              |
  +----------------------------------------------------------------------+
*/
/*
 * Copyright (C) 2005
 * Thomas Moenicke <tm\@ippfp.org>,
 * Jean-Luc Gyger <jean_luc.gyger\@freesurf.ch>
 *
*/
/* \$Id: header,v 1.15 2004/01/08 16:46:52 sniper Exp \$ */

#ifndef PHP_PHP_QT_H
#define PHP_PHP_QT_H

extern zend_module_entry php_qt_module_entry;
#define phpext_php_qt_ptr &php_qt_module_entry

#ifdef ZTS
#include \"TSRM.h\"
#endif

PHP_MINIT_FUNCTION(php_qt);
PHP_MSHUTDOWN_FUNCTION(php_qt);
PHP_RINIT_FUNCTION(php_qt);
PHP_RSHUTDOWN_FUNCTION(php_qt);
PHP_MINFO_FUNCTION(php_qt);

PHP_FUNCTION(confirm_php_qt_compiled);	/* For testing, remove later. */

/* emulate SIGNAL(), SLOT() macros */
PHP_FUNCTION(SIGNAL);
PHP_FUNCTION(SLOT);
    \n\n";

    # make zend_php.cpp snippets file
	my $file_php_qt_cpp = "$outputdir/php_qt.snippets.cpp";
	open( PHP_QT_CPP, ">$file_php_qt_cpp" ) || die "Couldn't create $file_php_qt_cpp\n";
	$file_php_qt_cpp =~ s/\.h/.h/;

    print PHP_QT_CPP "/**/\n";

    # make zend_php.cpp second snippets file PHP_MINIT_FUNCTION
	my $file_php_qt_minit = "$outputdir/php_qt.snippets2.cpp";
	open( PHP_QT_MINIT, ">$file_php_qt_minit" ) || die "Couldn't create $file_php_qt_minit\n";
	$file_php_qt_minit =~ s/\.h/.h/;

    print PHP_QT_CPP "\n";
    print PHP_QT_MINIT "\n";


	# Document all compound nodes
	Iter::LocalCompounds( $rootnode, sub { writeClassDoc( shift ); } );

    print ZEND_PHP_QT "\n/*
  	Declare any global variables you may need between the BEGIN
	and END macros here:

ZEND_BEGIN_MODULE_GLOBALS(php_qt)
	long  global_value;
	char *global_string;
ZEND_END_MODULE_GLOBALS(php_qt)
*/

/* In every utility function you add that needs to use variables
   in php_php_qt_globals, call TSRMLS_FETCH(); after declaring other
   variables used by that function, or better yet, pass in TSRMLS_CC
   after the last function argument and declare your utility function
   with TSRMLS_DC after the last declared argument.  Always refer to
   the globals in your function as PHP_QT_G(variable).  You are
   encouraged to rename these macros something shorter, see
   examples in any other php module directory.
*/

#ifdef ZTS
#define PHP_QT_G(v) TSRMG(php_qt_globals_id, zend_php_qt_globals *, v)
#else
#define PHP_QT_G(v) (php_qt_globals.v)
#endif

#endif	/* PHP_PHP_QT_H */


/*
 * Local variables:
 * tab-width: 4
 * c-basic-offset: 4
 * End:
 * vim600: noet sw=4 ts=4 fdm=marker
 * vim<600: noet sw=4 ts=4
 */\n
    ";
    close ZEND_PHP_QT;

    print PHP_QT_CPP "\n";
    close PHP_QT_CPP;

}

sub writeClassDoc
{
	my( $node ) = @_;

    $ctorCount = 0;

	print "Enter: $node->{astNodeName}\n" if $debug;
	if( exists $node->{ExtSource} ) {
		warn "Trying to write doc for ".$node->{AstNodeName}.
			" from ".$node->{ExtSource}."\n";
		return;
	}

	my $typeName = $node->{astNodeName}."*";

	if ( kalyptusDataDict::ctypemap($typeName) eq "" ) {
		$typeprefix = ($typeName =~ /^Q/ ? "qt_" : "kde_");
		kalyptusDataDict::setctypemap($typeName, $typeprefix.$node->{astNodeName}."*");
		print "'$typeName' => '$typeprefix$typeName',\n";
	} elsif ( kalyptusDataDict::ctypemap($typeName) =~ /^qt_/ ) {
		$typeprefix = "qt_";
	} elsif ( kalyptusDataDict::ctypemap($typeName) =~ /^kde_/ ) {
		$typeprefix = "kde_";
	} else {
		$typeprefix = "kde_";
	}
# make the class file
	my $file = join("__", kdocAstUtil::heritage($node)).".cpp";
    $file = "$outputdir/".lc($file);
	my $docnode = $node->{DocNode};
	my @list = ();
	my $version = undef;
	my $author = undef;

	if( $#{$node->{Kids}} < 0 || $node->{Access} eq "private") {
		return;
	}

	open( CLASS, ">$file" ) || die "Couldn't create $file\n";
	$file =~ s/\.h/.cpp/;

	my $short = "";
	my $extra = "";

print CLASS "/*
 * PHP-Qt - The PHP language bindings for Qt
 *
 * Copyright (C) 2005
 * Thomas Moenicke <tm\@ippfp.org>,
 * Jean-Luc Gyger <jean_luc.gyger\@freesurf.ch>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
";

	print CLASS " * ", $node->{astNodeName}, ".cpp - ", $node->{astNodeName}, " PHP implementation.\n";
	print CLASS $docTop;

    print CLASS "
#include <iostream>
using namespace std;

#include \"../php_qt.h\"\n";

# php_qt.cpp
    print PHP_QT_CPP "static zend_function_entry ",$node->{astNodeName},"_methods[] = {\n";
    print PHP_QT_MINIT "\n\t_register_",$node->{astNodeName},"(TSRMLS_C);\n";

	# ancestors
	my @ancestors = ();
	Iter::Ancestors( $node, $rootnode, undef, undef,
		sub { # print
			my ( $ances, $name, $type, $template ) = @_;
			push @ancestors, $name;
			},
			undef
		);

	if ( $#ancestors < 0 ) {
# INTERFACE
		if ( kalyptusDataDict::interfacemap($node->{astNodeName}) ne () ) {
			$file = "$outputdir/".join("__", kdocAstUtil::heritage($node)).".cpp";
			my $interfaceName = kalyptusDataDict::interfacemap($node->{astNodeName});
			$file =~ s/$node->{astNodeName}/$interfaceName/;
			open( INTERFACE, ">$file" ) || die "Couldn't create $file\n";
			print INTERFACE "// ", kalyptusDataDict::interfacemap($node->{astNodeName}), ".cpp - ", kalyptusDataDict::interfacemap($node->{astNodeName}), " PHP implementation.";
			print INTERFACE $docTop;	# header
print INTERFACE "
/*
 * PHP-Qt - The PHP language bindings for Qt
 *
 * Copyright (C) 2005
 * Thomas Moenicke <tm\@ippfp.org>,
 * Jean-Luc Gyger <jean_luc.gyger\@freesurf.ch>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#include <iostream>
using namespace std;

#include \"../php_qt.h\"
";
		}

# CLASS
	} else {

        print CLASS "\n#include <$node->{astNodeName}>\n\n";
        print ZEND_PHP_QT "\n\n/* $node->{astNodeName} */";

	}
# JNISOURCE? seems to be from JNI
	Iter::MembersByType ( $node,
		sub { print CLASS "", $_[0], ""; print JNISOURCE "", $_[0], "";  },
		sub {	my ($node, $kid ) = @_;
                 generateClassMethodForEnum( $node, $kid );
               },
		sub { print CLASS ""; print JNISOURCE ""; }
	);

	Iter::MembersByType ( $node,
		sub { print CLASS "", $_[0], ""; print CLASS "", $_[0], "";  },
		sub {	my ($node, $kid ) = @_;
            if ($kid->{NodeType} eq "property"){
                push @properties, $kid;
            }
        },
		sub { print CLASS ""; print CLASS ""; }
	);

# methods
	%functionId = ();
	$eventHandlerCount = 0;

	Iter::MembersByType ( $node,
		sub { print CLASS "", $_[0], ""; print CLASS "", $_[0], ""; },
		sub {	my ($node, $kid ) = @_;
                               listMember( $node, $kid );
                         },
		sub { print CLASS ""; print CLASS ""; }
	);

    # traverse
    foreach my $key (keys %methods){
        my $node_ = $methods{ $key };
        my @methods_ = $node_->{"method"};
# group
        my @one;
        my @two;
        my @three;
        my @four;
        my @five;

        print CLASS "
/*********************************
 *    class     ",$node->{astNodeName}," */\n";

        my $first = 1;

        foreach my $m_ (@methods_){
            foreach my $n_ (@{$m_}){

            if($first == 1){
                $first = 0;
                print CLASS "/*
 *    function  ",$n_->{astNodeName},"
 *    flags:    ",$n_->{Flags},"
 */\n";
                print CLASS "ZEND_METHOD(",$node->{astNodeName},", ",$n_->{astNodeName},"){\n";
            }


                my $count = 0;
                foreach $b ( @{$n_->{ParamList}} ) {
                    $count++;
                }
# copy
                if($count == 0){
                    print CLASS createReturn($node->{astNodeName}, $n_,"");
                } elsif($count == 1){
                    push @one, $n_;
                } elsif($count == 2){
                    push @two, $n_;
                } elsif($count == 3){
                    push @three, $n_;
                } elsif($count == 4){
                    push @four, $n_;
                } elsif($count == 5){
                    push @five, $n_;
                } else {
                    print "error, too much args: ",$count," ",$node->{astNodeName}," ",$n_->{astNodeName},"\n";
                }
            }

            my %one_ = mergeEquals($node->{astNodeName},1,@one);
            print CLASS marshal($node->{astNodeName},1,%one_);

            my %two_ = mergeEquals($node->{astNodeName},2,@two);
            print CLASS marshal($node->{astNodeName},2,%two_);

            my %three_ = mergeEquals($node->{astNodeName},3,@three);
            print CLASS marshal($node->{astNodeName},3,%three_);

            my %four_ = mergeEquals($node->{astNodeName},4,@four);
            print CLASS marshal($node->{astNodeName},4,%four_);

            my %five_ = mergeEquals($node->{astNodeName},5,@five);
            print CLASS marshal($node->{astNodeName},5,%five_);

#            print CLASS "}\n"; # ZEND_METHOD

        }
        print CLASS "}\n";
    }

    print CLASS "\n";

# creating the constructor
    my $function = $node->{astNodeName};

    print CLASS "\n\nZEND_METHOD(",$function, ",__construct){\n";
    print CLASS "\n\t",$function, " *",$function,"_ptr = new ",$function,"();\n";

    my $pc = 0;
    foreach my $constructor (@constructors){

        my $PHPzend_parse_parameters_s;
        my $PHPzend_parse_parameters_vars;

        my @ctor_params = @{$constructor};
        my $pCount = @ctor_params;
        print CLASS "\n";

        do {
                print CLASS "\tif(ZEND_NUM_ARGS() == ",$pCount,"){\n";

                my $typeCount = 0;
                foreach my $info ( @ctor_params ) {
                    print CLASS "\t\tzval* param_",$typeCount++,";\n";
                    $PHPzend_parse_parameters_s .= "z";
                    $PHPzend_parse_parameters_vars .= ", &param_$typeCount";
                } #if defined @{$info};

                print CLASS "\t\tif(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,\"",$PHPzend_parse_parameters_s,"\"",$PHPzend_parse_parameters_vars,") == FAILURE) {\n";
                print CLASS "\t\t\treturn;\n","\t\t}\n";

                $typeCount = 0;
                foreach my $info ( @ctor_params ) {
                 do {
                    print CLASS "\t\t /*",@{$info}[0]," ",@{$info}[1]," ",@{$info}[2],"*/\n";
                    print CLASS "\t\tif(Z_TYPE_P(param_",$typeCount,") == IS_",cplusplusToZENDType(@{$info}[2]),") {\n";
                    print CLASS "\t\t\t",@{$info}[2]," tmp(Z_STRVAL_P(param_",$typeCount++,"));\n";
                    print CLASS "\t\t\t",$function,"_ptr = new ",$function,"(tmp);\n";
                    print CLASS "\t\t}\n";
                    } if defined @{$info};
                }
                print CLASS "\t}\n";
    } if defined @ctor_params;

}
    print CLASS "\n\tPHP_QT_REGISTER(",$function,"_ptr);\n";
    print CLASS "\tRETURN_NULL();\n";
	print CLASS "}\n";
# destructor
    print CLASS "\nPHP_QT_DESTRUCT(",$function,");\n\n";

	close CLASS;
	$nullctor = 0;

# php_qt.cpp
    print PHP_QT_CPP "
	{NULL,NULL,NULL}
};\n";

# inheritance
    my $zend_inherit = $node->{astNodeName}."_ce_ptr = zend_register_internal_class(&ce TSRMLS_CC);";
    my $ancestor;

    my $first = 1;
	foreach $ancestor ( @ancestors ) {
        if($first) {
            $zend_inherit = $node->{astNodeName}."_ce_ptr = zend_register_internal_class_ex(&ce TSRMLS_CC, ".$ancestor."_ce_ptr,NULL TSRMLS_CC);\n";
            $first = 0;
        } else {
           $zend_inherit .= "\tzend_do_inheritance(".$node->{astNodeName}."_ce_ptr, ".$ancestor."_ce_ptr TSRMLS_CC);\n";
        }
	}

    print PHP_QT_CPP "
void _register_",$node->{astNodeName},"(TSRMLS_D)
{
    zend_class_entry ce;
    INIT_CLASS_ENTRY(ce,\"",$node->{astNodeName},"\",",$node->{astNodeName},"_methods);
    ",$zend_inherit,"
";

	Iter::MembersByType ( $node,
		sub { print CLASS "", $_[0], ""; print CLASS "", $_[0], "";  },
		sub {	my ($node, $kid ) = @_;
            if ($kid->{NodeType} eq "property"){
                print PHP_QT_CPP
#                    "zend_declare_property_string(",$node->{astNodeName},"_ce_ptr,\"",$kid->{astNodeName},"\",strlen(\"",$kid->{astNodeName},"\"),\"\",ZEND_ACC_PROTECTED TSRMLS_CC);";
                     "\tPHP_QT_DECLARE_PROPERTY(\"$kid->{astNodeName}\");\n";
            }
        },
		sub { print CLASS ""; print JNISOURCE ""; }
	);

    print PHP_QT_CPP "
}\n";

	if ( kalyptusDataDict::interfacemap($node->{astNodeName}) ne () ) {
		close INTERFACE;
    }

    undef @properties;
    undef @functions;
    undef @constructors;
    undef %methods;
}

# for every node
sub listMember
{
	my( $class, $m, $ancestorCount) = @_;
	my $name;
    my $function;
	my $PHPaccess;
	my $PHPparams;
    my $pCount;

    my @ctor_params;
	my $returnType;

	$name = $m->{astNodeName} ;
	my $type = $m->{NodeType};
	my $docnode = $m->{DocNode};

	if ( $m->{ReturnType} =~ /~/ ) {
		$name = "~".$name;
	}

#print_r($m);

    $function = $name;

	$function =~ s/~//;

	if( $type eq "method" && $m->{Access} ne "private" && $m->{Access} ne "private_slots" && $m->{Access} ne "signals" ) {
		if ( $m->{ReturnType} =~ /[<>]/ || $m->{Params} =~ /[<>]/  || $m->{Params} =~ /\.\.\./ || $m->{Params} =~ /Impl/
				|| $m->{ReturnType} =~ /QAuBucket/ || $m->{Params} =~ /QAuBucket/
				|| $m->{ReturnType} =~ /QMember/ || $m->{Params} =~ /QMember/   ) {
			return;
		}

# returntype
		$returnType = $m->{ReturnType};
		$returnType =~ s/const\s*//;
		$returnType =~ s/inline\s*//;
		$returnType =~ s/\s*([,\*\&])\s*/$1/;
		$returnType =~ s/^\s*//;
		$returnType =~ s/\s*$//;

		if ( $returnType ne "" && cplusplusToPInvoke($returnType) eq () ) {
			$returnType =~ s/^.*::.*$/int/;
		} else {
			$returnType = cplusplusToPInvoke($returnType);
		}

		if ( $returnType eq "RawObject") {
			$returnType = "IntPtr";
		}

		my $cparams = $m->{Params};
		my $cplusplusparams;
		my $pinvokeparams;
		my $pinvokeargs;

		# TODO port to $m->{ParamList}
		$cparams =~ s/\s+/ /g;
		$cparams =~ s/\s*([,\*\&])\s*/$1 /g;
		$cparams =~ s/^\s*void\s*$//;
		my $argId = 0;
		my @cargs = kdocUtil::splitUnnested(",", $cparams);
		$cparams = "";
		foreach my $arg ( @cargs ) {
			my $argType;
			my $cargType;
			my $PHPargType;
			my $pinvokeargType;
			if ( $arg =~ /^\s*$/ ) {
				next;
			}

			# A '<arg> = <value>' default parameter
			$arg =~ s/\s*([^\s].*[^\s])\s*/$1/;
			$arg =~ s/(\w+)\[\]/\* $1/;
			$arg =~ s/=\s*(("[^\"]*")|(\'.\')|(([-\w:.]*)\s*(\|\s*[-\w]*)*(\(\w*\))?))//;

			if ( $arg =~ /^(.*)\s+(\w+)\s*$/ ) {
				$argType = $1;
				$arg = $2;
			} else {
				$argType = $arg;
				$argId++;
				$arg = "arg".$argId;
			}
			$arg =~ s/^id$/identifier/;
			$argType =~ s/\s*([^\s].*[^\s])\s*/$1/;
			$argType =~ s/\s*const//g;
			$argType =~ s/^\s*//;
			$argType =~ s/([\*\&])\s*([\*\&])/$1$2/;
			$cargType = kalyptusDataDict::ctypemap($argType);
			$PHPargType = cplusplusToZEND($argType);
			$pinvokeargType = cplusplusToPInvoke($argType);

			if ( $PHPargType eq "" ) {
				$PHPargType = $argType;
				$PHPargType =~ s/\&/\*/;
				$PHPargType =~ s/^.*::.*$/int/;
			}
			if ( $pinvokeargType eq "" ) {
				$pinvokeargType = $argType;
				$pinvokeargType =~ s/\&/\*/;
				$pinvokeargType =~ s/^.*::.*$/int/;
			}

			if ( $pinvokeargType =~ /IntPtr/ ) {
				$pinvokeargs .= "$arg.Ptr, ";
 			} elsif ( $PHPargType =~ /\./ ) {
				$pinvokeargs .= "($pinvokeargType)$arg, ";
			} else {
				$pinvokeargs .= "$arg, ";
			}

			if ( $pinvokeargType =~ /RawObject/ ) {
				 $pinvokeargType =~ s/RawObject/IntPtr/;
			}

# save these attributes for ctor
            @ctor_params[$pCount++] = [$PHPargType,$arg,$argType];

            $PHPparams .= "$PHPargType $arg, ";
            $pinvokeparams .= "$pinvokeargType $arg, ";
		}
		$cparams =~ s/, $//;
		$cplusplusparams =~ s/, $//;
		$PHPparams =~ s/, $//;
		$pinvokeparams =~ s/, $//;
		$pinvokeargs =~ s/, $//;

		my $flags = $m->{Flags};

		if ( !defined $flags ) {
			warn "Method ".$m->{astNodeName}.  " has no flags\n";
		}


		my $extra = "";
		$extra .= "static " if $flags =~ "s";

		if ( $name =~ /operator/  ) {
			return;
		}

		if ( $m->{Access} =~ /protected/ && $name ne $class->{astNodeName}  ) {
			if ( $class->{Pure} ) {
				return;
			}

			$name = "protected_".$name;
		}

		$m->{Access} =~ /([^_]*)(.*)?\s*/;
		$PHPaccess = $1;
		if ( $extra =~ /static/ ) {
			$PHPaccess .= " static";
		}

		if ( $name eq $class->{astNodeName} && $class->{Pure} ) {
			return;
		}

		if ( defined $docnode ) {
			if ( defined $docnode->{Text} ) {
				print CLASS "\n/** ";
				my $node;
				my $line;
				foreach $node ( @{$docnode->{Text}} ) {
					next if $node->{NodeType} ne "DocText";
					$line = $node->{astNodeName};
					print CLASS $line, "\n";
				}
				print CLASS "*/\n";
			}
		}

		#This is to make sure we have no duplicate methods...
		my $currentmethod .= "$name $returnType $PHPparams";
		my $pastmethod .= "$pastname $pastreturn $pastparams";
		if($currentmethod ne $pastmethod) {

# make the cpp file
# constructor
		    if ( $name eq $class->{astNodeName} ) {
                @constructors[$ctorCount++] = [@ctor_params];
# ?
			    if ($PHPparams eq () ) {
				    $nullctor = 1;
			    }
# methods
		    } else {
			    if ( $name =~ /.*Event$/ ) {
				    return;
			    }
# prepare arguments
                mergeNumbers($class,$m);
# deprecated
#                cplusplusToMacro($class,$m);
   		    }
	    }
	}
	#Part of the duplicate methods check.
	$pastname = $name;
	$pastreturn = $returnType;
	$pastparams = $PHPparams;

	$PHPparams = "";

}

sub generateClassMethodForEnum
{
	my( $class, $m ) = @_;
	my $enum = $m->{astNodeName};
	my $PHPaccess;

	$m->{Access} =~ /([^_]*)(.*)?\s*/;
	$PHPaccess = $1;

	if( $m->{NodeType} eq "enum" ) {
		my $enum = $m->{astNodeName};
		my @enums = split(",", $m->{Params});
		my $enumCount = 0;

		if($enum ne " ") {
			print CLASS "\n\n/*\t\t$PHPaccess enum", $enum,":long {";

			foreach my $enum_ ( @enums ) {
				$enum_ =~ s/\s//g;
				$enum_ =~ s/::/./g;
				if($#enums == $enumCount){

					if ( $enum_ =~ /(.*)=(.*)/ ) {
						print CLASS "\n\t\t\t$1 = $2";
					} else {
						print CLASS "\n\t\t\t$enum = $enumCount";
					}

				} else {

					if ( $enum_ =~ /(.*)=(.*)/ ) {
						print CLASS "\n\t\t\t$1 = $2,";
					} else {
						print CLASS "\n\t\t\t$enum = $enumCount,";
					}

				}
#                $enum =~ s/=//g;
                my @constant = split(/=/,$enum_);
                print PHP_QT_MINIT "\t	REGISTER_LONG_CONSTANT(\"",uc($class->{astNodeName}),"_",uc($enum),"_",uc($constant[0]),"\", ",$class->{astNodeName},"::",$constant[0],", CONST_CS | CONST_PERSISTENT);\n";
				$enumCount++;

			}

			print CLASS "\n\t\t}\n*/";
		}
	}
}

sub print_r
{
    my ( $cnode ) = @_;

    my @n = Ast::GetProps($cnode);
    foreach $a ( @n ) {
        print CLASS ">",$a,": ",$cnode->{$a},"\n";
    }
}

# diese Methode gruppiert alle Argumente nach Anzahl

sub mergeNumbers
{
	my ( $class, $cnode )  = @_;

    my $functionname = $cnode->{astNodeName};
    my $classname = $class->{astNodeName};

    foreach my $key ( keys %methods ) {
		if ( $key eq $functionname ) {
            #add to existing
			$methods{ $key }->AddPropList("method", $cnode);
			return;
		}
    }

    # add new
    $methods{ $functionname } = Ast::New( $functionname );
    $methods{ $functionname }->AddPropList("method",$cnode);


}

# finds equal strings and groups them

sub mergeEquals {

    my ($classname, $count, @args) = @_;
    # find all equal strings

    my @param_check;
    my %tmp;
    my $skip = 0;       # helping
# create all strings
    foreach my $method (@args){
        my $paramstring = "";
        foreach my $param ( @{$method->{ParamList}} ) {
            if ( $param->{ArgType} =~ /char/ ) {
                $paramstring .= "s";
            } elsif ( $param->{ArgType} =~ /int/ ) {
                $paramstring .= "l";
            } elsif ( $param->{ArgType} =~ /bool/ ) {
                $paramstring .= "b";
            } else {
                $paramstring .= "o";
            }
        }

        push @param_check, $paramstring;

# check if already available
        foreach my $key ( keys %tmp ) {
# yes: add
            if ( $key eq $paramstring ) {
                #add to existing
                $tmp{ $key }->AddPropList("params", $method);
                $skip = 1;
                last;
            }
        }
# no: create new
        if($skip == 0){
            $tmp{ $paramstring } = Ast::New( $paramstring );
            $tmp{ $paramstring }->AddPropList("params",$method);
        }
        $skip = 0;
# add method name
        $tmp{ $paramstring }->AddProp("methodname",$method->{astNodeName});
        $tmp{ $paramstring }->AddProp("ReturnType",$method->{ReturnType});

    }

    return %tmp;

}

# group by count and strings

sub marshal {

    my ($classname, $count, %args) = @_;
    my $return;

    my $not_empty = %args;
    if($not_empty){
        $return .= "\n\tif (ZEND_NUM_ARGS() == ".$count."){\n";
    }

    my $c = 0;                  # helping variable
    my $run = 0;

# node is the method
    foreach my $key (keys %args){
        # docu
#        foreach $b ( @{$method->{ParamList}} ) {
#            $return .= " *    \@param   ".$b->{ArgType}."\n";
#            $return .= " */\n";
#        }

# handle arguments at first

        # initialize vars and agruments for zend_parse_parameters
        my $d = 0;                  # helping variable
        my $paratype;               # for zend
        my $shortstring = "\"";    # short string for zend function
        my $param_zend_function;    # parameter for zend function
        my @objects;                # object stack
        my $method = $args{$key};   # helping
        my $object_selection = "";
        my $tmp_count = 0;          # helping

# informations about return type

# identical strings grouped
        $return .= "\t\t/* ".$key." */\n";
        $run = $key."_";
# first parameters are static, the others coincides with this
# exception: objects
        my $params = @{$method->{params}}[0];

# parse the first parameters
        foreach my $first_param (@{$params->{ParamList}})  {

            # comma for param_zend_function params
            if($d > 0){
                $param_zend_function .= " ,";
            }

            # the types
# char
            if ( $first_param->{ArgType} =~ /char/ ) {
                $return .= "\t\tchar* var_".$run.$c.";   // default: ".$first_param->{DefaultValue}."\n";
                $return .= "\t\tint* len_".$run.$c.";\n\n";

                $paratype .= ", &var_".$c.", &len_".$c;
                $param_zend_function .= " var_".$c;
                $shortstring .= "s";
# int
            } elsif ( $first_param->{ArgType} =~ /int/ ) {
                $return .= "\t\tlong var_".$run.$c.";    // default: ".$first_param->{DefaultValue}."\n";

                $paratype .= ", &var_".$run.$c;
                $param_zend_function .= "(".$first_param->{ArgType}.") var_".$run.$c;
                $shortstring .= "l";
# bool
            } elsif ( $first_param->{ArgType} =~ /bool/ ) {
                $return .= "\t\tbool* var_".$run.$c.";   // _default: ".$first_param->{DefaultValue}."\n";

                $paratype .= ", &var_".$run.$c;
                $param_zend_function .= "(".$first_param->{ArgType}.") var_".$run.$c;
                $shortstring .= "b";
# objects
            } else {
# while overloading, only one object will be created, query for name

                $return .= "\t\tzval* var_".$run.$c.";   // default: ".$first_param->{DefaultValue}."\n";

                $paratype .= ", &var_".$run.$c;
                $param_zend_function .= "() var_o_".$c; # deprecated
                $shortstring .= "o";
                push @objects, "var_o_".$c;   # ?
                # name query
                $object_selection .= "\t\t\tQString tmp_".$tmp_count++."(var_o_".$c."->metaObject()->className());\n";
            }
            if(exists $first_param->{DefaultValue} != ""){
                $shortstring .= "|";
            }
            $c++;
            $d++;
        }
        $return .= "\n";
# add additional objects
        
        foreach my $params (@{$method->{params}}){
            
            my $skip_first = 1;
            $tmp_count = 0;
            $c = 0;

# skip first, this was already created
            my $object_test;
            my $object_call;
            my $obj_first = 1;
# parse the rest
            foreach my $param ( @{$params->{ParamList}} ) {

                if($skip_first == 1){
                    $object_selection .= "\t\t\t";
                    $skip_first = 0;
                } else {
                    $object_call .= ", ";
                }
# skip all excepting objects
                if ( $param->{ArgType} =~ /char/ ) {
                    $object_call .= "(".$param->{ArgType}.") var_".$run.$c;
                } elsif ( $param->{ArgType} =~ /int/ ) {
                    $object_call .= "(".$param->{ArgType}.") var_".$run.$c;
                } elsif ( $param->{ArgType} =~ /bool/ ) {
                    $object_call .= "(".$param->{ArgType}.") var_".$run.$c;
                } else {
#print_r($method);
                    if($obj_first == 1){
                        $obj_first = 0;
                    } else {
                        $object_test .= " && ";
                    }
                    $object_test .= "tmp_".$tmp_count++." == \"".$param->{ArgType}."\"";
                    $object_call .= "(".$param->{ArgType}.") ".$objects[$c++];
                }
            } # foreach param

            if(!$obj_first){
                $object_selection .= "\n\t\t\tif(".$object_test.") {\n";
                $object_selection .= "\t".createReturn($classname, $method, $object_call);
                $object_selection .=  "\t\t\t}";
            }
        } # foreach params

        $shortstring .= "\"";

# write zend_parse_parameters method
        $return .= "\t\tif(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,".$shortstring.$paratype.") == SUCCESS) {\n";
        $return .= "\t\t\t".$classname." *obj = (".$classname."*) PHP_QT_FETCH();\n";

# objects as return type
        my $obj;
        foreach $obj ( @objects ) {
            $return .= "\t\t\tQObject* ".$obj." = (QObject*) php_qt_fetch(".$obj.");\n";
        }

# add object handling
        my $not_empty = %args;
        if($not_empty){
            $return .= "\n".$object_selection;
            undef $object_selection;
            $return .= "\n";
# $c counts objects, if there is no object the return mechanism has to be created
            if($c>0){
                $return .= "\t\t}\n";
# break run if there are objects
                next;
            }
        }

# return handling
        $return .= createReturn($classname, $method, $param_zend_function);

        $return .= "\t\t}\n";
        $tmp_count=0;
    } # foreach args

    my $not_empty = %args;
    if($not_empty){
        $return .= "\t}\n";
    }

    return $return;
}

sub createReturn {

    my ($classname, $method, $param_zend_function) = @_;
    my $return;

# no arguments, no object created
    if($param_zend_function == ""){
        $return .= "\t\t\t".$classname." *obj = (".$classname.") PHP_QT_FETCH();\n";
    }

    my $methodname;
    if (defined $method->{methodname}) {
        $methodname = $method->{methodname}
    } else {
        $methodname = $method->{astNodeName} if defined $method->{astNodeName};
    }

    my $returntype = $method->{ReturnType};
    my $zend_return_type = cplusplusToZEND($returntype);

# handle return value here
# if no return type specified
        if ( $zend_return_type eq "NULL" ) {
            $return .=  "\t\t\tobj->".$methodname."(".$param_zend_function.");\n";
            $return .=  "\t\t\tRETURN_NULL();\n";
# if return type is an object
        } elsif ( $zend_return_type =~ /zval/ ) {
        # TODO: consider 'const',
        # and non-pointer types, pointer types
            $return .=  "\t\t\t".$returntype." return_object = (".$returntype.") obj->".$methodname."(".$param_zend_function.");\n";
            $return .=  "\t\t\tzend_class_entry *ce;                                   \n";
            $return .=  "\t\t\tobject_init_ex(return_value, ".$classname."_ce_ptr);     \n";
            $return .=  "\t\t\tzend_rsrc_list_entry le;                            \n";
            $return .=  "\t\t\tle.ptr = &return_object;                                       \n";
            $return .=  "\t\t\tphp_qt_register(return_value,le);                   \n";
            $return .=  "\t\t\treturn;                                             \n";
# simple types
        } else {
            $return .=  "\t\t\tRETURN_".uc($zend_return_type)."(obj->".$methodname."(".$param_zend_function."));\n" if defined $zend_return_type;
        }

    return $return;

}

1;

