#***************************************************************************
#    copyright            : (C) 2006 Thomas Moenicke
#    email                : tm@ippfp.org
#    author               : Thomas Moenicke
#***************************************************************************/

#/***************************************************************************
# *                                                                         *
# *   This program is free software; you can redistribute it and/or modify  *
# *   it under the terms of the GNU General Public License as published by  *
# *   the Free Software Foundation; either version 2 of the License, or     *
# *   (at your option) any later version.                                   *
# *                                                                         *
#***************************************************************************/

# sub writeDoc                      $lib, $rootnode, $outputdir, $opt
# sub writeClassDoc                 $node

# support for return types, access (can switch from public to private)

package kalyptusCxxToPHP;

use File::Path;
use File::Basename;

use Carp;
use Ast;
use kdocAstUtil;
use kdocUtil;
use Iter;
use kalyptusDataDict;

#use strict;
no strict "subs";

use vars qw/
    @clist
    $host $who $now $gentext %functionId $docTop
	$lib $rootnode $outputdir $opt $debug $typeprefix $eventHandlerCount
	$pastaccess $pastname $pastreturn $pastparams $nullctor $ctorCount

    $onlyPrivateConstructor
    $classId

    @properties
    @functions
    @constructors

    %methods
    %classes
    @protected
    @virtual
    @addIncludes
    @enums
    @pure

    $classname;
    *CLASS
    *HEADER

    *AG_ZEND_CLASS_ENTRY
    *AG_DEFINES
    *AG_EXTERN_ZEND_CLASS_ENTRY
    *AG_VOID_REGISTER
    *AG_ZEND_PHP_QT
    *AG_CONFIGM4
    *AG_QT_MINIT
    *AG_PHP_QT_CPP
    *INHERITANCE

    *QTCTYPES
    *KDETYPES
    /;


BEGIN
{
    @clist = ();

    # Page footer

	$who = kdocUtil::userName();
	$host = kdocUtil::hostName();
	$now = localtime;
	$gentext = "$who using kalyptus $main::Version.";

	$docTop =<<EOF
 * begin           : $now
 * generated by    : $gentext
 */
EOF
}

#   for all header files

#   $lib            not used
#   $rootnode       rootnode of Ast
#   $outputdir      string of dirname
#   $opt            not used

sub writeDoc
{
	my ( $lib, $rootnode, $outputdir_, $opt ) = @_;

    $outputdir = $outputdir_;
    $global_rootnode = $rootnode;
    $onlyPrivateConstructor = 1;
    $classId = 1;
    %classes = ();

#    kdocAstUtil::dumpAst($rootnode);
    report("reimplementation of protected and virtual methods temporarily disabled");

    openAllFiles();

    generateInheritanceList();

	# Document all compound nodes
	Iter::LocalCompounds( $rootnode, sub { writeClassDoc( shift ); } );

    closeAllFiles();

}

# for one class

sub writeClassDoc
{
	my( $class ) = @_;
    $classname = $class->{astNodeName};

    @addIncludes = ();
    @virtual = ();
    @protected = ();
    @pure = ();
    %methods = ();

    openClassFile($class);

    checkIncludes($class);
    writeAllFiles($class);

    prepareMethods($class);
    DerivedClass($class);

    handleAllMethods($class);
    Inheritance($class);

    closeClassFile();

}

sub prepareMethods
{
    my ($class) = @_;

    %methods = ();
    @enums = ();

	Iter::MembersByType ($class,sub{},
		sub
        {
            my ($class, $kid ) = @_;
            if ($kid->{NodeType} eq "enum" )
            {
                push @enums, $kid;
            }

            if ($kid->{NodeType} eq "property" )
            {
                push @properties, $kid;
            }
            if($kid->{NodeType} eq "method")
            {
                # to handle overloaded methods
                mergeMethods($kid);
            }
        },sub {}
	);

    foreach my $key (%methods){

        $method = %methods->{$key};

        if($method->{Flags} =~ /p/) {
            push(@pure, $method);
        } elsif($method->{Access} eq "protected" || $method->{Flags} =~ /v/){
            if($method->{astNodeName} eq $classname){
                report("protected constructor", 3);
                next;
            }
            push @protected, $method;
        } else {
            report($method->{astNodeName}." skipped in prepareMethods()", 3) if ($method->{astNodeName} ne "" && $method->{astNodeName} =~ /v/);
        }
    }
}

# all methods of this class

sub handleAllMethods
{
    foreach my $key (keys %methods)
    {
        $method = %methods->{$key};

        $method = prepareArgs($method);
        writeMethodDoc($method);
        handleMethod($method);

    }
}

# all args of this method
#
# every method has a list of arguments from overloaded methods
#
sub handleMethod
{
    my ( $method ) = @_;

    my $methodname = $method->{astNodeName};    # for better reading

    if(IshouldSkip($method)){
        return;
    }

    $methodname = "__construct" if($methodname eq $classname);

    print CLASS "ZEND_METHOD(".$classname.",".$methodname."){";

    my $first = "true";
    # get _all_ arg
    ARGLIST: foreach my $overloadedmethod (@{$method->{"argList"}})
    {
        if($first eq "true"){
            $first = "false";
            next;
        }

        my @cargs = kdocUtil::splitUnnested(",", $overloadedmethod->{Params});
        my $params;     # collect args for every try

        my $zend_args_query;        # parameter for the type check statement
        my $ce_ptr_query;           # parameter for the class check statement
        my $count_args = 0;
        my @stack = ();             # argument stack, regular parameters
        my @stack_optional = ();    # argument stack, optional parameters
        my $specialQString;         # converts php strings into QStrings

        my @ifdef_stack = ();       # object safety

        # check whether agument is optional or regular
        foreach my $cpp_arg ( @cargs ) {
            if($cpp_arg =~ /=/){
                push(@stack_optional,$cpp_arg);
            } else {
                push(@stack,$cpp_arg);
            }
        }

        #
        # all regular args
        #
        foreach $cpp_arg (@stack){

            $params .= $cpp_arg.","; # collect args for this try
            $zend_arg = cplusplusToZVAL($cpp_arg);

            # intercept unknown types
            if($zend_arg eq "unknown"){
                print CLASS "\n// notice: unknown argument ".$cpp_arg.", skipped\n";
                next ARGLIST;
            }

            # skip abstract class
            if(isAbstract(unwrapClassType($overloadedmethod->{ReturnType}))){
                print CLASS "\n// notice: abstract class ".unwrapClassType($overloadedmethod->{ReturnType})." cannot be instanciated, skipped\n";
                next ARGLIST;
            }

            $zend_args_query .= " && Z_TYPE_P(arg_".$count_args.") == IS_".$zend_arg;
            if($zend_arg eq "OBJECT"){
                my $classId = %classes->{ unwrapClassType($cpp_arg) };
                if($classId == 0){
                    $classId = "0";
                }
                $ce_ptr_query .= "inherits(Z_OBJCE_P(arg_".$count_args."), ".$classId.")";
                push(@ifdef_stack,unwrapClassType(removeGeneric($cpp_arg)));
                $ce_ptr_query .= "&&";
            }
            if($cpp_arg =~ /QString/){
                $specialQString = "arg_".$count_args." = invokeToQString(arg_".$count_args.");\n";
            }
            $count_args++;
        }

        # remove last '&&'
        chop($ce_ptr_query);
        chop($ce_ptr_query);

        # type check
        print CLASS "\n\t///".$overloadedmethod->{Params}."\n";

        # ifdef
        print CLASS "#ifdef PHP_QT_".unwrapClassType(removeGeneric($overloadedmethod->{ReturnType}))." // return type\n\n"
            if cplusplusToZVAL($overloadedmethod->{ReturnType}) eq "OBJECT";

        print CLASS "if(ZEND_NUM_ARGS() == ".$count_args."){";
        print CLASS "PHP_QT_FETCH_".$count_args."_ARGS();";

        print CLASS $specialQString."\n";
        print CLASS "if(1 ".$zend_args_query."){";

        # class check if object
        if($ce_ptr_query ne ""){
            print CLASS "".expandIfdefs(@ifdef_stack);  # ifdef PHP_QT_QString
            print CLASS " if(".$ce_ptr_query."){";
            handleArguments($params,$overloadedmethod->{ReturnType},$overloadedmethod->{Flags}, $methodname, $overloadedmethod); # argument handling
            print CLASS "}\n";
            print CLASS "".expandEndifs(@ifdef_stack);  # endif

        # simple types
        } else {
            handleArguments($params,$overloadedmethod->{ReturnType},$overloadedmethod->{Flags}, $methodname, $overloadedmethod); # argument handling
        }
        print CLASS "}}"; # end if ZEND_NUM_ARGS

        #
        # for all optional parameters
        #
        foreach $cpp_arg (@stack_optional){

            $params .= $cpp_arg.","; # collect args for this try
            $zend_arg = cplusplusToZVAL($cpp_arg);

            # intercept unknown types
            if($zend_arg eq "unknown"){
                print CLASS "\n// notice: unknown argument ".$cpp_arg.", skipped\n";
                # ifdef
                print CLASS "#endif // return type\n\n" if cplusplusToZVAL($overloadedmethod->{ReturnType}) eq "OBJECT";

                next ARGLIST;
            }

            $zend_args_query .= " && Z_TYPE_P(arg_".$count_args++.") == IS_".$zend_arg;

            # type check
            print CLASS "if(ZEND_NUM_ARGS() == ".$count_args."){";
            print CLASS "PHP_QT_FETCH_".$count_args."_ARGS();";

            # regular arg
            print CLASS $specialQString;

            # optional arg
            if($cpp_arg =~ /QString/){
                print CLASS "arg_".$count_args." = invokeToQString(arg_".$count_args.");\n";
            }
            print CLASS "if(1 ".$zend_args_query."){";

            # if object
            if($ce_ptr_query ne ""){
                print CLASS "".expandIfdefs(@ifdef_stack);  # ifdef PHP_QT_QString
                print CLASS " if(".$ce_ptr_query."){";  # ask object types
                handleArguments($params,$overloadedmethod->{ReturnType},$overloadedmethod->{Flags}, $methodname, , $overloadedmethod); # argument handling
                print CLASS "}\n";
                print CLASS "".expandEndifs(@ifdef_stack);  # endif
            # if simple type
            } else {
                # argument handling
                handleArguments($params,$overloadedmethod->{ReturnType},$overloadedmethod->{Flags}, $methodname, , $overloadedmethod);
            }
            print CLASS "}}"; # end type check

        } # stack_optional

        # ifdef
        print CLASS "#endif // return type\n\n" if cplusplusToZVAL($overloadedmethod->{ReturnType}) eq "OBJECT";
    }

    print CLASS "php_error(E_ERROR,\"could not parse argument in ".$classname."::".$method->{astNodeName}."(...) \");";
    print CLASS "}\n";

}

#
# prepare and invoke args for a try
#

sub handleArguments
{
    my ( $params, $return, $flags, $methodname, $overloadedmethod ) = @_;

    my $returnType = cplusplusToZVAL($return);      # example: BOOL, LONG, DOUBLE, STRING, OBJECT
    my $is_constructor = ($method->{astNodeName} eq $classname);

#    print CLASS "#ifdef MONITOR\n cout << \"(".$classname.")\" << getThis() << \"::".$methodname."(".$params.")\\n\";\n#endif\n";
#    print CLASS "#ifdef MONITOR\n php_error(E_NOTICE, \"".$classname."::".$methodname."(".$params.") accepted.\\n\");\n#endif\n";

    if($returnType eq "unknown"){
        print CLASS "php_error(E_ERROR,\"unsupported return type ".$return."\");";
        return;
    }

    if($overloadedmethod->{Access} eq "protected"){
        print CLASS "\n/// overloaded method is protected, skipped.\n";
        report("overloaded protected method ".$methodname, 3);
        return if ($methodname ne "__construct");
    }

    # QCharRef *selfpointer = new QCharRef(...);
    if($onlyPrivateConstructor || $overloadedmethod->{Access} eq "private"){
        report($classname." has only private constructors", 4);
        print CLASS "\n/// method is private, skip\n";
        print CLASS "php_error(E_ERROR,\"".$classname."::".$methodname."(...) cannot be called with '".$params."'.\");";
        return;
    }


    if($flags =~ /s/){  # static
    } else {
        print CLASS "if(getThis() == NULL){php_error(E_ERROR,\"method '".$methodname."' is not static\"); RETURN_NULL();}";
    }

    my $preparation;    # invoke zend to cpp, prepare return object if necessary
    my $cpp_call_params;    # the args passed to Qt method
    my $count_args = 0;
    my @cargs = kdocUtil::splitUnnested(",", $params);  # fetch args

    $preparation .= "\n\t/// try ".$params."\n";
    if(!$is_constructor){   # fetch self pointer
        $preparation .= "".$classname." *selfpointer; if(getThis() != NULL){selfpointer = static_cast<".$classname."*>(PHP_QT_FETCH());}";
    }

    # argument handling
    foreach $arg (@cargs) {

        $argType = cplusplusToZVAL($arg);

        # should never happen, checked above
        if($argType eq "unknown"){
            print CLASS "\n// unknown, skipped: ".$arg."\n";
            return; # return arg handling
        }

        # Dummy
        if($argType eq "ARRAY"){
            $cpp_call_params .= "new char*[1],";
            next;
        }

        # the Z_STRVAL_P macro delivers char*, but we simply need the first and only char
        my $charSpecial = "[0]" if isChar($arg);

        # for all arg types, e.g. bool*
        $classType = unwrapClassType($arg);

        # handling of pointers, references
        my $postfix, $prefix, $prefix_ZVAL;
        if(checkRPN($arg) eq "reference"){
            $postfix = "&"; # cast (old c cast)
            $prefix = "*";  # dereferencing the pointer
            $prefix_ZVAL = "";
        } elsif (checkRPN($arg) eq "pointer"){
            $postfix = "*"; # cast
            $prefix = "";   # nothing, is already a pointer
            $prefix_ZVAL = "&";
        } elsif (checkRPN($arg) eq "normal"){
            $prefix = "*";  # dereferencing the pointer
            $postfix = "";  # nothing to do here
            $prefix_ZVAL = "";
        }

        $cpp_call_params .= "(".checkConst($arg)." ".$classType.$postfix.")";

        if($argType eq "OBJECT"){
            # example: QString *cpp_arg_0 = static_cast<QString*>(php_qt_fetch(args[0]);
            $preparation .= $classType." *cpp_arg_".$count_args." = static_cast<".$classType."*>(php_qt_fetch(arg_".$count_args."));\n";
            $cpp_call_params .= $prefix."cpp_arg_".$count_args." ";
        } else {
            # example: Z_LVAL_P(arg_0), Z_STRVAL(arg_0)
            $cpp_call_params .= $prefix_ZVAL."Z_".invokeTypeToZ_XVAL($argType)."VAL_P(arg_".$count_args.")".$charSpecial." ";
        }

        $cpp_call_params .= ",";
        $count_args++;
    }

    chop($cpp_call_params); # remove last comma

    print CLASS $preparation;   # printout declaration

    # return handling
    my $returnClassName = unwrapClassType($return); # example: QString (from QString &c)
    my $prefix, my $postfix, my $infix, my $le_ptr;
    my $yrr, my $rxrr, my $pxrr;

    # yrr,rxrr,pxrr defined for prefix
    my $leftAssignment;
    if($returnType eq "OBJECT"){
        print CLASS "zend_class_entry *ce;";
        print CLASS "object_init_ex(return_value, QString_ce_ptr);";
        print CLASS "zend_rsrc_list_entry le;";
        $yrr = "";
    } else {
        $yrr = $returnClassName;
        $rxrr = "&";
        $pxrr = "*";
    }

    # static_cast<...> or const_cast<...>
    my $castWay = "static";
    if($return =~ /const/){
        $castWay = "const";
    }

    my $returnCast;
    $returnCast = "(char*)" if isChar($return);
    $returnCast = "(char*)" if ($returnType eq "STRING");

    if(checkRPN($return) eq "reference"){       # tested
        $prefix = $yrr.$rxrr;
        # const_cast<...> => &const_cast<...>
        $castWay = "&".$castWay;
        $infix = "&";
        $le_ptr = "&";
    } elsif (checkRPN($return) eq "pointer"){
        $prefix = $yrr.$pxrr;
        $infix = "*";    # for static_cast, return_object
        $le_ptr = "";
    } elsif (checkRPN($return) eq "normal"){    # tested with non-objects
        $infix = "";
        $prefix = "*";
        $le_ptr = "";
    }

    # allocate memory on the heap if object
    # QString *return_object = new QString;
    # leftAssignment:
    # *return_object = static_cast<.....
    if($returnType eq "OBJECT"){
        if (checkRPN($return) eq "normal"){
            print CLASS $returnClassName." *return_object = new ".$returnClassName.";\n";
            $leftAssignment = $prefix." return_object";
        } else {
            $leftAssignment = "le.ptr"; #le.ptr
        }
    }

    if($returnType eq "OBJECT"){
        if($flags =~ /s/){  # static
            print CLASS "if(getThis() == NULL){".$leftAssignment." = ".$castWay."_cast<"                .$returnClassName.$infix.">(".$classname."::".$method->{astNodeName}."(".$cpp_call_params."));} else {"
            .$leftAssignment." = ".$castWay."_cast<"               .$returnClassName.$infix.">(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));}";
        } else { #non-static
            print CLASS $leftAssignment." = ".$castWay."_cast<"
                .$returnClassName.$infix.">(selfpointer->".$method->{astNodeName}."(".$cpp_call_params."));";
        }
        # normal
        print CLASS "le.ptr = (void*) ".$le_ptr."return_object;" if (checkRPN($return) eq "normal");
        print CLASS "php_qt_register(return_value,le);";
        print CLASS "return;";

    } else {
        my $for_string;
        if($returnType eq "STRING"){    # RETURN_STRING macro needs 2 params
            $for_string = ", 1";
        }
        if($is_constructor){   # constructor
            my $comma = "," if($cpp_call_params);

            # constructor:
            # QString_php_qt *selfpointer = new QString_php_qt(...);
            # there are two ways: allocate memory on heap or with emalloc

            # cpp-way
            print CLASS $classname."_php_qt *selfpointer = new ".$classname."_php_qt(getThis()".$comma.$cpp_call_params.");";

            # experiment, do not use
#            print CLASS $classname."_php_qt *selfpointer = static_cast<".$classname."_php_qt*>(new ".$classname."(".$cpp_call_params."));";
#            print CLASS "selfpointer->zend_ptr = getThis();";

            # zend-way with emalloc()
#            print CLASS $classname."_php_qt *selfpointer = static_cast<".$classname."_php_qt*>(emalloc(sizeof(".$classname."_php_qt)));";
#            print CLASS "new (selfpointer) ".$classname."_php_qt(getThis()".$comma.$cpp_call_params.");";

            print CLASS "PHP_QT_REGISTER(selfpointer);RETURN_NULL();";
        } else {
            if($flags =~ /s/){  # static
                print CLASS "if(getThis() == NULL){RETURN_".$returnType."(".$classname."::"
                    .$method->{astNodeName}."(".$cpp_call_params.")".$for_string.");} else {RETURN_"
                    .$returnType."(selfpointer->".$method->{astNodeName}."(".$cpp_call_params.")".$for_string.");}";
            } else {
                print CLASS "RETURN_".$returnType."(".$returnCast."selfpointer->".$method->{astNodeName}."(".$cpp_call_params.")".$for_string.");";
            }
        }
    }
}

# group and merge methods by name, for argument handling

sub mergeMethods
{
	my ( $method )  = @_;

    # skip destructor
    if($method->{ReturnType} =~ /~/){
        return;
    }

    # looking for existing list
    foreach my $key ( %methods ) {
        if ( $key->{astNodeName} eq $method->{astNodeName} ) {

            # report
#             if($key->{ReturnType} ne $method->{ReturnType}){
#                 report($classname .", ". $method->{astNodeName} .": <". $key->{ReturnType} ."> <". $method->{ReturnType}.">\n");
#             }

            # add to existing list
            push(@{$methods{ $method->{astNodeName} }->{"argList"}},$method);
	        return;
 		}
    }

    # add new list
    $methods{ $method->{astNodeName} } = $method;

    my $methodlist = ();
    $methods{ $method->{astNodeName} }->AddProp("methodname", $method->{astNodeName});
    $methods{ $method->{astNodeName} }->AddPropList("argList", $methodlist);

    push(@{$methods{ $method->{astNodeName} }->{"argList"}},$method);

}

# write documentation for method

sub writeMethodDoc
{
    my ( $method ) = @_;

        print CLASS "/*!\n";
        print CLASS " * method ".$method->{astNodeName}."\n";
        print CLASS " * \n";

        foreach my $overloadedmethod (@{$method->{"argList"}})
        {
            my @cargs = kdocUtil::splitUnnested(",", $overloadedmethod->{Params});

            # mark as overloaded
            if(@cargs>0) {
                print CLASS " * \n";
                print CLASS " * overloaded args:\n";
            } else {
                print CLASS " * \@param: -\n";
            }

            foreach my $arg ( @cargs ) {
                print CLASS " * \@param\t".$arg."\n";
            }

        }

        print CLASS " * \n";
        print CLASS " * \@access\t".$method->{Access}."\n";
        print CLASS " * \@return\t".$method->{ReturnType}."\n";
        print CLASS " * \@flags\t".$method->{Flags}."\n";
        print CLASS " */\n\n"

}

################################################################################
#                                                                              #
#   HELPER FUNCTIONS                                                           #
#                                                                              #
################################################################################

sub openAllFiles
{

	mkpath( $outputdir ) unless -f $outputdir;
    mkpath( $outputdir."/classes/" ) unless -f $outputdir."/classes/";

    # INHERITANCE
    my $file_inheritance = "$outputdir/inheritance.cpp";
    open( INHERITANCE, ">$file_inheritance" ) || die "Couldn't create $file_inheritance\n";
    $file_inheritance =~ s/\.h/.h/;

    # AG_ZEND_CLASS_ENTRY
    my $file_ag_zend_class_entry = "$outputdir/ag_zend_class_entry.inc";
    open( AG_ZEND_CLASS_ENTRY, ">$file_ag_zend_class_entry" ) || die "Couldn't create $file_ag_zend_class_entry\n";
    $file_ag_zend_class_entry =~ s/\.h/.h/;

    # AG_ZEND_CLASS_ENTRY
    my $file_ag_defines = "$outputdir/defined.h";
    open( AG_DEFINES, ">$file_ag_defines" ) || die "Couldn't create $file_ag_defines\n";
    $file_ag_defines =~ s/\.h/.h/;

    # AG_EXTERN_ZEND_CLASS_ENTRY
    my $file_ag_extern_zend_class_entry = "$outputdir/ag_extern_zend_class_entry.inc";
    open( AG_EXTERN_ZEND_CLASS_ENTRY, ">$file_ag_extern_zend_class_entry" ) || die "Couldn't create $file_ag_extern_zend_class_entry\n";
    $file_ag_extern_zend_class_entry =~ s/\.h/.h/;

    # AG_ZEND_PHP_QT
    my $file_ag_zend_php_qt = "$outputdir/ag_zend_php_qt.inc";
    open( AG_ZEND_PHP_QT, ">$file_ag_zend_php_qt" ) || die "Couldn't create $file_ag_zend_php_qt\n";
    $file_ag_zend_php_qt =~ s/\.h/.h/;

    # AG_CONFIGM4
    my $file_ag_configm4 = "$outputdir/ag_configm4.inc";
    open( AG_CONFIGM4, ">$file_ag_configm4" ) || die "Couldn't create $file_ag_configm4\n";
    $file_ag_configm4 =~ s/\.h/.h/;

    # AG_QT_MINIT
    my $file_ag_qt_minit = "$outputdir/ag_qt_minit.inc";
    open( AG_QT_MINIT, ">$file_ag_qt_minit" ) || die "Couldn't create $file_ag_qt_minit\n";
    $file_ag_qt_minit =~ s/\.h/.h/;

    # AG_PHP_QT_CPP
    my $file_ag_php_qt_cpp = "$outputdir/ag_php_qt_cpp.inc";
    open( AG_PHP_QT_CPP, ">$file_ag_php_qt_cpp" ) || die "Couldn't create $file_ag_php_qt_cpp\n";
    $file_ag_php_qt_cpp =~ s/\.h/.h/;

    print AG_PHP_QT_MINIT "\n";
    print AG_ZEND_PHP_QT "/*
 * PHP-Qt - The PHP language bindings for Qt
 *
 * Copyright (C) 2006
 * Thomas Moenicke <tm\@ippfp.org>,
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#ifndef PHP_PHP_QT_H
#define PHP_PHP_QT_H

extern zend_module_entry php_qt_module_entry;
#define phpext_php_qt_ptr &php_qt_module_entry

#ifdef ZTS
#include \"TSRM.h\"
#endif

PHP_MINIT_FUNCTION(php_qt);
PHP_MSHUTDOWN_FUNCTION(php_qt);
PHP_RINIT_FUNCTION(php_qt);
PHP_RSHUTDOWN_FUNCTION(php_qt);
PHP_MINFO_FUNCTION(php_qt);

PHP_FUNCTION(confirm_php_qt_compiled);	/* For testing, remove later. */

/* emulate SIGNAL(), SLOT() macros */
PHP_FUNCTION(SIGNAL);
PHP_FUNCTION(SLOT);
    \n\n";

}

# write stuff to files
sub writeAllFiles
{
    my ($node) = @_;

    print AG_ZEND_CLASS_ENTRY "zend_class_entry *",$node->{astNodeName},"_ce_ptr;\n";
    print AG_DEFINES "#ifndef PHP_QT_".$classname."\n#define PHP_QT_".$classname."\n#endif\n\n";

    print AG_CONFIGM4 "\tqt/classes/",lc($node->{astNodeName}),".cpp \\ \n";
    print AG_EXTERN_ZEND_CLASS_ENTRY "extern zend_class_entry *",$node->{astNodeName},"_ce_ptr;\n";
    print AG_EXTERN_ZEND_CLASS_ENTRY "void \t_register_",$node->{astNodeName},"();\n";

    print PHP_QT_MINIT "\n\t_register_",$node->{astNodeName},"(TSRMLS_C);\n";
    print AG_QT_MINIT "\n\t_register_",$node->{astNodeName},"(TSRMLS_C);\n";

}

sub closeAllFiles
{

    print AG_ZEND_PHP_QT "\n/*
  	Declare any global variables you may need between the BEGIN
	and END macros here:

ZEND_BEGIN_MODULE_GLOBALS(php_qt)
	long  global_value;
	char *global_string;
ZEND_END_MODULE_GLOBALS(php_qt)
*/

#ifdef ZTS
#define PHP_QT_G(v) TSRMG(php_qt_globals_id, zend_php_qt_globals *, v)
#else
#define PHP_QT_G(v) (php_qt_globals.v)
#endif

#endif	/* PHP_PHP_QT_H */
\n
    ";

    close AG_ZEND_CLASS_ENTRY;
    close AG_DEFINES;
    close AG_EXTERN_ZEND_CLASS_ENTRY;
    close AG_ZEND_PHP_QT;
    close AG_CONFIGM4;
    close AG_QT_MINIT;
    close AG_PHP_QT_CPP;
    close INHERITANCE;
}

sub openClassFile
{

    my ( $node ) = @_;

	my $file = join("__", kdocAstUtil::heritage($node)).".cpp";
    $file = $outputdir."/classes/".lc($file);

	if( $#{$node->{Kids}} < 0 || $node->{Access} eq "private") {
		return;
	}
	open( CLASS, ">$file" ) || die "Couldn't create $file\n";
	$file =~ s/\.h/.cpp/;

print CLASS "/*
 * PHP-Qt - The PHP language bindings for Qt
 *
 * Copyright (C) 2006
 * Thomas Moenicke <tm\@ippfp.org>,
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
";

	print CLASS " * ", $node->{astNodeName}, ".cpp - ", $node->{astNodeName}, " PHP implementation.\n";
	print CLASS $docTop;

    print CLASS "
#include <iostream>
using namespace std;\n";

    print CLASS "#include \"../php_qt.h\"\n\n";
    print CLASS "\n#include <$node->{astNodeName}>\n";

}

# check additional header files
# hardcoded
sub checkIncludes(){
    my ($class) = @_;
    my $return;

    if($class->{astNodeName} eq "QFont") {
        $return .= "#include <QStringList>\n";
    }
    if($class->{astNodeName} eq "QPainter") {
        $return .= "#include <QPainterPath>\n";
    }
    if($class->{astNodeName} eq "QApplication") {
        $return .= "#include <QPalette>\n#include <QFontMetrics>\n#include <QIcon>\n";
    }
    if($class->{astNodeName} eq "QCoreApplication") {
        $return .= "#include <QStringList>\n";
    }
    if($class->{astNodeName} eq "QWidget") {
        $return .= "#include <QIcon>\n";
    }

    print CLASS $return;
}

sub DerivedClass
{
    my ($class) = @_;

    # handle enums
    my $public_enum_declaration;
    my $protected_enum_declaration;
    foreach $enum (@enums){
        # deactivated
        $public_enum_declaration .= declareEnums($enum,"public");
        $protected_enum_declaration .= declareEnums($enum,"protected");
    }

    # handle constructors
    @constructors = findConstructor($class);

    # nothing to do
    return if($onlyPrivateConstructor);

    my $constructors_declaration, my $constructors_implementation;


    foreach my $constructor (@constructors){

        my $prepared_params, my $comma, my $call_params;
        $call_params = prepareParamsForCall($constructor);

        my @paramList = kdocUtil::splitUnnested(",", $constructor->{Params});
        if(@paramList > 0){
            foreach my $param (@paramList){
                @ch = split(/=/, $param);
                $prepared_params .= ",".@ch[0];
            }
            $comma = "," if ($prepared_params);
        }

        $constructors_declaration .= $classname."_php_qt(zval* zend_ptr".$comma.$constructor->{Params}.");";
        $constructors_implementation .= $classname."_php_qt::".$classname."_php_qt(zval* zend_ptr".$prepared_params.") : ".$classname."(".$call_params.")
        {
            this->zend_ptr = zend_ptr;";

        if(hasMetaObject()){
            $constructors_implementation .= "
// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,\"".$classname."\",&staticMetaObject));";
        }
        $constructors_implementation .= "\n}\n";
    }

    my $protected_declaration, my $protected_implementation;
    my $virtual_declaration, my $virtual_implementation;

    # handle pure methods
    if(@pure){
        foreach my $method (@pure){

            if(IshouldSkipForReimplementation($method)){
                next;
            }

            # add const to declaration and implementation
            # someMethod() const
            my $constant;
            if($method->{Flags} =~ /c/){
                $constant = "const\n";
            }

            writeMethodDoc($method);

            if($method->{ReturnType} eq "void"){
                $return = "";
            } else {
                $return = "return ";
            }

            checkAddIncludes($method);

            $call_params = prepareParamsForCall($method);

            # virtual protected methods will be implemented
            if($method->{Flags} =~ /v/){
                $virtual_declaration .= "\n".checkConst($method->{Flags})." ".checkFlags($method->{Flags})." ".$method->{ReturnType}." ".$method->{astNodeName}."(".$method->{Params}.")".$constant."; // pure \n";

                $virtual_implementation .= "\n// virtual, pure \n\n ".$method->{ReturnType}." ".$classname."_php_qt::".$method->{astNodeName}."(".prepareParamsForArg($method).")".$constant."{}";

            # protected methods with proxy methods
            } else {

                # SliderAction => QbstractSlider_php_qt::SliderAction
                my $returnIType;
                if(isEnum($method->{ReturnType})){
                    $returnIType = $classname."::".$method->{ReturnType};
                } else {
                    $returnIType = $method->{ReturnType};
                }

                #   void protected_adjustPosition(QWidget * QWidget * s0);
                $protected_declaration .= "\n".checkConst($method->{Flags})." ".checkFlags($method->{Flags})." ".$returnIType." protected_".$method->{astNodeName}."(".prepareParamsForDeclaration($method).")".$constant."; // pure \n";

                $protected_implementation .= "\n ".$returnIType." ".$classname."_php_qt::protected_".$method->{astNodeName}."(".prepareParamsForArg($method).")".$constant."{".$return."this->".$method->{astNodeName}."(".$call_params.");}";
            }

        }
    } # end pure

    # handle protected methods
    # temp. disabled
    if(@protected && 0){

        $protected_declaration;
        my $return, my $call_params;

        foreach my $method (@protected){

            if(IshouldSkipForReimplementation($method)){
                next;
            }

            # add const to declaration and implementation
            # someMethod() const
            my $constant;
            if($method->{Flags} =~ /c/){
                $constant = "const\n";
            }

            writeMethodDoc($method);

            if($method->{ReturnType} eq "void"){
                $return = "";
            } else {
                $return = "return ";
            }
            # skip special methods
            if($method->{astNodeName} eq "metaObject"
            || $method->{astNodeName} eq "className"){
                next;
            }
            checkAddIncludes($method);

            $call_params = prepareParamsForCall($method);

            # virtual protected methods will be implemented
            if($method->{Flags} =~ /v/){
                $virtual_declaration .= "\n".checkConst($method->{Flags})." ".checkFlags($method->{Flags})." ".$method->{ReturnType}." ".$method->{astNodeName}."(".$method->{Params}.")".$constant.";";

                $virtual_implementation .= "\n// virtual \n\n ".$method->{ReturnType}." ".$classname."_php_qt::".$method->{astNodeName}."(".prepareParamsForArg($method).")".$constant."{}";

            # protected methods with proxy methods
            } else {

                # SliderAction => QbstractSlider_php_qt::SliderAction
                my $returnIType;
                if(isEnum($method->{ReturnType})){
                    $returnIType = $classname."::".$method->{ReturnType};
                } else {
                    $returnIType = $method->{ReturnType};
                }

                #   void protected_adjustPosition(QWidget * QWidget * s0);
                $protected_declaration .= "\n".checkConst($method->{Flags})." ".checkFlags($method->{Flags})." ".$returnIType." protected_".$method->{astNodeName}."(".prepareParamsForDeclaration($method).")".$constant.";";

                $protected_implementation .= "\n ".$returnIType." ".$classname."_php_qt::protected_".$method->{astNodeName}."(".prepareParamsForArg($method).")".$constant."{".$return."this->".$method->{astNodeName}."(".$call_params.");}";
            }
        }

    }

    my $includes;
    foreach $include (@addIncludes){
        $include =~ s/\*|\&//;
        print CLASS "#include <".$include.">\n" if $include ne "";
    }

    # handle moc implementation
    my $moc_declaration, my $moc_implementation;
    if(hasMetaObject()){
        $moc_declaration = "
        const QMetaObject* metaObject() const;
        int qt_metacall(QMetaObject::Call _c, int _id, void **_a);";
        $moc_implementation = "\nPHP_QT_MOC(".$classname.");\n";
    }

    print CLASS "#include <QMetaMethod>
    class ".$classname."_php_qt : public ".$classname."{

    public:
        ".$constructors_declaration."
        ".$public_enum_declaration."

        zval* zend_ptr;";
    print CLASS $moc_declaration;
    print CLASS $virtual_declaration;
    print CLASS "protected:" if $protected_declaration;
    print CLASS $protected_enum_declaration;
    print CLASS $protected_declaration;
    print CLASS "};";

    print CLASS $constructors_implementation;
    print CLASS $virtual_implementation;
    print CLASS $protected_implementation;
    print CLASS $moc_implementation;

    print CLASS "\n";

# TODO:
# virtual and private classes

}

#

sub Inheritance
{
    my ($node) = @_;

    # find ancestors
    my @ancestors = ();
	Iter::Ancestors( $node, $rootnode, undef, undef,
		sub {
			my ( $ances, $name, $type, $template ) = @_;
            push @ancestors, $name;
		},
		undef
	);

    # print mainfile stuff
    print AG_PHP_QT_CPP "
    {NULL,NULL,NULL}
};\n";

    my $zend_inherit = $node->{astNodeName}."_ce_ptr = zend_register_internal_class(&ce TSRMLS_CC);";
    my $ancestor;

    my $first = 1;
	foreach $ancestor ( @ancestors ) {
        if($first) {
            $zend_inherit = $node->{astNodeName}."_ce_ptr = zend_register_internal_class_ex(&ce TSRMLS_CC, ".$ancestor."_ce_ptr,NULL TSRMLS_CC);\n";
            $first = 0;
        } else {
           $zend_inherit .= "\tzend_do_inheritance(".$node->{astNodeName}."_ce_ptr, ".$ancestor."_ce_ptr TSRMLS_CC);\n";
        }
	}

    print AG_PHP_QT_CPP "
void _register_",$node->{astNodeName},"(TSRMLS_D)
{
    zend_class_entry ce;
    INIT_CLASS_ENTRY(ce,\"",$node->{astNodeName},"\",",$node->{astNodeName},"_methods);
    ",$zend_inherit,"
";

# 	Iter::MembersByType ( $node,
# 		sub { print CLASS "", $_[0], ""; print CLASS "", $_[0], "";  },
# 		sub {	my ($node, $kid ) = @_;
#             if ($kid->{NodeType} eq "property"){
#                 print AG_PHP_QT_CPP "\tPHP_QT_DECLARE_PROPERTY(\"$kid->{astNodeName}\");\n";
#             }
#         },
# 		sub { print CLASS ""; print JNISOURCE ""; }
# 	);

    print AG_PHP_QT_CPP "
}\n";


}

sub closeClassFile
{
    close CLASS;
}

sub cplusplusToZVAL
{
	my ( $cplusplusType )  = @_;

    if($cplusplusType eq ""){
        return "";
    }

	if ( $cplusplusType =~ /bool/) {
		return "BOOL";
	} elsif ( $cplusplusType =~ /\s*void\s*\**/ ) {
		return "VOID";
	} elsif ( $cplusplusType =~ /\s*::\s*/) {
		return "LONG";
	} elsif ( $cplusplusType =~ /\s*\bint\s*\&*/) {
		return "LONG";
	} elsif ( $cplusplusType =~ /\s*\buint\s*\&*/) {
		return "LONG";
#	} elsif ( $cplusplusType =~ /\s*int\s*\&*/) {
#		return "LONG";
	} elsif ( $cplusplusType =~ /\s*short\s*\&*/) {
		return "LONG";
	} elsif ( $cplusplusType =~ /\s*char\s*\*\*/ ) {
        # should e array
		return "ARRAY";
	} elsif ( $cplusplusType =~ /\s*uchar\s*\**/ ) {
		return "unknown";
	} elsif ( $cplusplusType =~ /\s*char\s*\**/ ) {
		return "STRING";
	} elsif ( $cplusplusType =~ /\s*unsigned int\s*\**/ ) {
		return "LONG";
	} elsif ( $cplusplusType =~ /\s*unsigned short\s*\**/ ) {
        return "LONG";
	} elsif ( $cplusplusType =~ /\s*unsigned long\s*\**/ ) {
		return "LONG";
	} elsif ( $cplusplusType =~ /\s*float\s*\**/ ) {
        return "DOUBLE";
	} elsif ( $cplusplusType =~ /\s*double\s*\**/ ) {
        return "DOUBLE";
	} elsif ( $cplusplusType =~ /\s*unsigned char\s*\**/ ) {
		return "STRING";
	} elsif ( $cplusplusType =~ /Q/ ) {
        return "OBJECT";
	} else {
        return "unknown";
    }
}

# helper: unwraps the classtype from arg string
sub unwrapClassType
{
    my ($argString) = @_;

    $argString =~ s/const//;
    $argString =~ s/\*//;
    $argString =~ s/\&//;

    # skip spaces
    @c = split(/ /,$argString);
    foreach(@c){
        if($_ ne ""){
            return $_;
        }
    }

    return $c[0];

}

# checks for references, pointers, objects

sub checkRPN
{
    my ($e) = @_;

    my $rpo;

    if($e =~ /\*/){
        $rpo = "pointer";
    } elsif ($e =~ /\&/) {
        $rpo = "reference";
    } else {
        $rpo = "normal";
    }

    return $rpo;

}

# checks for const
sub checkConst
{
    my ($e) = @_;
    if($e =~ /const/){
        return "const";
    }
    return "";
}

# checks for const
sub checkFlags
{
    my ($e) = @_;
    my $return;
    if($e =~ /v/){
        $return .= "virtual";
    }

    return $return;
}

# invokes types for the Z_XVAL macro
sub invokeTypeToZ_XVAL
{
    my ($type) = @_;
    my $Z_VAL = substr($type,0,1);
    if($Z_VAL eq "S"){
        return "STR";
    }
    # due problems with references
    if($Z_VAL eq "B"){
        return "L";
    }

    return $Z_VAL;
}

#
# expand #ifdef PHP_QT_QString ... #endif statements
#

sub expandIfdefs
{
    my (@ifdef_stack) = @_;
    my $ifdef;
    foreach $def (@ifdef_stack){
        $ifdef .= "#ifdef PHP_QT_".$def."\n";
    }
    return $ifdef;
}

sub expandEndifs
{
    my (@ifdef_stack) = @_;
    my $endif;
    foreach $def (@ifdef_stack){
        $endif .= "#endif\n\n";
    }
    return $endif;
}

# flags:
# virtual           v
# static            's'
# pure              p
# const             c
# slots             l
# inline            i
# signal            n
# k_dcop            d
# k_dcop_signals    z
# k_dcop_hidden     y
# explicit          t

sub IshouldSkip
{
    my ($method) = @_;

    if($method->{astNodeName} =~ /qt_/)
    {   # skip qt_cast, ...
        return 1;
    }
#    if($method->{Flags} =~ /n|v|t/){    # skip slots
    if($method->{Flags} =~ /n|v/){    # skip slots
        return 1;
    }

    if($method->{Access} eq "protected"){
        return 1;
    }

    if($method->{astNodeName} eq "className"
        || $method->{astNodeName} eq "qObject"
        || $method->{astNodeName} =~ /operator/
        || $method->{astNodeName} =~ /qt_/
    ){
        return 1;
    }

}

sub IshouldSkipForReimplementation
{
    my ($method) = @_;

    if($method->{astNodeName} =~ /qt_/)
    {   # skip qt_cast, ...
        return 1;
    }

    if($method->{Flags} =~ /n/){    # skip slots
        return 1;
    }

    if($method->{astNodeName} eq "className"
        || $method->{astNodeName} eq "qObject"
        || $method->{astNodeName} =~ /operator/
        || $method->{astNodeName} =~ /qt_/
    ){
        return 1;
    }

}


#
#   finds the constructor
#
sub findConstructor
{
    my ($class) = @_;

    my @return, my $safetyConstructor;

    $onlyPrivateConstructor = 1;
    $main::doPrivate = 1;

    Iter::MembersByType ($class,sub{},
	sub
    {
        my ($class, $kid ) = @_;
        if($kid->{NodeType} eq "method")
        {
            # there are some additional protected constructors, skip
            if($kid->{Access} ne "protected"){
                if($kid->{Access} eq "private"){
                    next;
                }
                if($kid->{astNodeName} eq $classname){
                    if($kid->{ReturnType} =~ /~/){
                        debug("destructor skipped");
                    } else {
                        $onlyPrivateConstructor = 0;
                        push @return, $kid;
                    }
                }
            }
            if($kid->{Access} ne "protected" && $kid->{astNodeName} eq $classname){
                $safetyConstructor = $kid;
            }
        }
    },sub {}
	);

    if (@return == 0){
        report("none or only protected constructors detected, we declared an empty destructor ".$safetyConstructor->{Params}, 3);
        push @return, $safetyConstructor;
    }

    return @return;

}

sub checkAddIncludes
{
    my ($method) = @_;

    my @cargs = kdocUtil::splitUnnested(",", $method->{Params});

    foreach my $arg (@cargs){

        if($arg =~ /::/){
            return;
        }

        my @arg_ = split(/ /,$arg);
        foreach my $m (@addIncludes){
            # skip 'const'
            if(@arg_[0] eq "const"){
                if($m eq @arg_[1]){
                    return;
                }
            # skip enums
            } else {
                if($m eq @arg_[0]){
                    return;
                }
            }
        }

        if(@arg_[0] =~ /Q/ || @arg_[1] =~ /Q/){
            if(@arg_[0] eq "const"){
                push @addIncludes, @arg_[1];
            } else {
                push @addIncludes, @arg_[0];
            }
        }
    }

}

#
#   for reimplementing of protected methods
#   QFocusEvent * e => e
#   int repeatTime = 50 s
#
#   warn: $method->{Params} will be modified!

sub prepareParamsForCall
{
    my ($method) = @_;

    # for typos:
    # QWidget* => QWidget *, see
    $method->{Params} =~ s/\*/ \*/;
    $method->{Params} =~ s/\&/ \&/;
    $method->{Params} =~ s/  / /;

    my @cargs = kdocUtil::splitUnnested(",", $method->{Params});
    my $param, my $params_replacement, my $safetyCount=0;

    foreach my $arg (@cargs){

        my $type_tmp = $arg;  # needed for @arg_ == 1

        # safety
        # QAbstractSlider::timerEvent(QTimerEvent*)
        my $arg_s;
        if($arg =~ /=/){
        } else {
            $/ = " ";
            chomp($arg);

            # ' Type' => 'Type'
            $arg =~ s/^ //;
            my $c = ($arg =~ tr/ //);

            if($c == 0){
                # to prevent 'PaintDeviceMetrics0',
                # should be 'PaintDeviceMetric s0' (see QWidget)
                $arg = "";
                $arg .= "s".$safetyCount;# if $arg =~ /^:/;
            } else {
                $arg .= "s".$safetyCount;# if $arg =~ /^:/;
            }
            $arg .= "s".$safetyCount if $arg =~ /^:/;
            $arg_s = "s".$safetyCount++;    # for @arg_ == 1, to prevent 'bool bools0'
        }

        my @arg_ = split(/ /,$arg);
        if(@arg_[0] eq ""){
            shift(@arg_);
        }
        if(@arg_ == 1){
            $params_replacement .= $type_tmp." ".$arg_s.",";
        } else {
            $params_replacement .= $arg.",";
        }

        #   int repeatTime = 50 s => repeatTime
        if($arg =~ /=/){

            # remove special signs
            $arg_c = $arg;              # work with a copy
            $arg_c =~ s/=/ /;           # remove '='
            $arg_c =~ s/\*|\&|const//;  # remove special signs
            $arg_c =~ s/  / /;          # remove double spaces

            my @arg_c = split(/ /,$arg_c);
            my @arg_stack;
            foreach my $a (@arg_c){
                next if($a eq "" | $a eq "const");
                push (@arg_stack, $a);
            }
            if(@arg_stack == 2){
                $param .= "s".$safetyCount.",";
            } else {
                pop (@arg_stack);
                $param .= pop (@arg_stack).",";
            }
        #   QFocusEvent * e => e
        } else {
            my $arg__ = pop(@arg_);
            $arg__ =~ s/\*|&//;
            $param .= $arg__.",";

        }
    }

    chop($param);
    chop($params_replacement);
    $param =~ s/\*|\&//;

    $method->{Params} = $params_replacement;
    return $param;

}

#
#   prepare for implementation of protected methods
#

sub prepareParamsForArg
{
    my ($method) = @_;

    my @cargs = kdocUtil::splitUnnested(",", $method->{Params});
    my $arg_return;

    foreach $param (@cargs){
        my $arg_chunk;
        if($param =~ /=/){
            my @arg = split(/=/,$param);
            $arg_chunk = shift(@arg);

            # WId => 'WId s0'
            my $c = ($arg_chunk =~ tr/ //);
            if($c == 1){
                report("Warning: parameter 's0' hardcoded, maybe dangerous!");
                $arg_chunk .= "s0";
            }

        } else {
            $arg_chunk = $param;
        }

        # SliderAction => QAbstractSlider::SliderAction
        @arg_ = split(/ /,$arg_chunk);
        if(isEnum(@arg_[0])){
            $arg_chunk = $classname."::".$arg_chunk;
        }

        $arg_return .= $arg_chunk;

        $arg_return .= ",";
    }

    chop($arg_return);

    return $arg_return;

}

#
#   prepare for implementation of protected methods
#

sub prepareParamsForDeclaration
{
    my ($method) = @_;

    my @cargs = kdocUtil::splitUnnested(",", $method->{Params});
    my $arg_return;

    foreach $param (@cargs){
        my $arg_chunk;

        $arg_chunk = $param;

        # SliderAction => QAbstractSlider::SliderAction
        @arg_ = split(/ /,$arg_chunk);
        if(isEnum(@arg_[0])){
            $arg_chunk = $classname."::".$arg_chunk;
        }

        $arg_return .= $arg_chunk;

        $arg_return .= ",";
    }

    chop($arg_return);

    return $arg_return;

}


#
#   for _all_ methods in class
#   QEvent* => QEvent* s0

sub prepareArgs
{
    my ($method) = @_;

    # for typos:
    # QWidget* => QWidget *
    $method->{Params} =~ s/\*/ \*/;
    $method->{Params} =~ s/\&/ \&/;
    $method->{Params} =~ s/  / /;

    my @cargs = kdocUtil::splitUnnested(",", $method->{Params});
    my $params_replacement, my $safetyCount;

    foreach $arg (@cargs){
        my $type_tmp = $arg;  # needed for @arg_ == 1

        # safety
        # QAbstractSlider::timerEvent(QTimerEvent*)
        $arg .= "s".$safetyCount++;

        my @arg_ = split(/ /,$arg);
        if(@arg_[0] eq ""){
            shift(@arg_);
        }

        if(@arg_ == 1){
            $params_replacement .= $type_tmp." ".$arg.",";
        } else {
            $params_replacement .= $arg.",";
        }

    }

    chop($params_replacement);

    $method->{Params} = $params_replacement;

    return $method;

}

sub declareEnums
{
	my( $enum, $specifier ) = @_;

	$enum->{Access} =~ /([^_]*)(.*)?\s*/;

	if( $enum->{NodeType} eq "/* enum" && $enum->{Access} eq $specifier) {

        my $enum_declaration = "enum ".$enum->{astNodeName}." {";   # return value

		my @enums = split(",", $enum->{Params});
		my $enumCount = 0;

		if($enum->{astNodeName} ne " ") {

			foreach my $enum_ ( @enums ) {
				$enum_ =~ s/\s//g;
				$enum_ =~ s/::/./g;
				if($#enums == $enumCount){

					if ( $enum_ =~ /(.*)=(.*)/ ) {
						$enum_declaration .= "\n\t\t\t$1 = $2";
					} else {
						$enum_declaration .= "\n\t\t\t".$enum_." = $enumCount";
					}

				} else {

					if ( $enum_ =~ /(.*)=(.*)/ ) {
						$enum_declaration .= "\n\t\t\t$1 = $2,";
					} else {
						$enum_declaration .= "\n\t\t\t".$enum_." = $enumCount,";
					}

				}
#                my @constant = split(/=/,$enum_);
# what to skip?
                    if(!(
                            $classname =~ /QContextMenuEvent/
                        ||  $classname =~ /QInputMethodEvent/
                        ||  $classname =~ /QPainter/
                        ||  $classname =~ /QTabletEvent/
                    )){
                        print AG_QT_MINIT "\t  REGISTER_LONG_CONSTANT(\"",uc($classname),"_",uc($enum->{astNodeName}),"_",uc($constant[0]),"\", ",$classname,"::",$constant[0],", CONST_CS | CONST_PERSISTENT);\n";
                        $enumCount++;
                    }
			}

			$enum_declaration .= "\n\t\t};*/\n";

            return $enum_declaration;
		}
	}

}

#   remove generic syntax
#   QList<Attribute> => QList
sub removeGeneric
{
    my($myarg) = @_;
    $myarg =~ s/<.*>//;
    return $myarg;
}

sub generateInheritanceList
{

    print INHERITANCE "\n\n#include \"php_qt.h\"\nbool inherits(zend_class_entry* ace, uint objectId, int recursion){";

    # generate list of Id's
    my $classId;
	Iter::LocalCompounds( $global_rootnode, sub {
        $class = shift;
        $classes{ $class->{astNodeName} } = ++$classId;
    });

    $classId = 0;   # reset

    # write code
	Iter::LocalCompounds( $global_rootnode, sub {

        $class = shift;
        $classId++;

        # ask for all ancestors
        @c = superclass_list($class);

        print INHERITANCE "\n\n/// ".$class->{astNodeName}.", ID: ".$classId." \n";
        print INHERITANCE "if(ace == ".$class->{astNodeName}."_ce_ptr){ switch(objectId){";
        print INHERITANCE "case ".$classId.": //".$class->{astNodeName}."\nreturn true;";

        # walk through relevant ancestors
        foreach my $a (@c){
            next if $a->{astNodeName} eq "";
            print INHERITANCE "case ".%classes->{ $a->{astNodeName} }.": //".$a->{astNodeName}."\nreturn true;"
        }

        print INHERITANCE "default: return false;";
        print INHERITANCE "}}";

    } );

    print INHERITANCE "\n// final: \nif(recursion == 10) {return false;} inherits(ace->parent, objectId, recursion++);}\n";

}

# helper function
sub superclass_list($)
{
    my $classNode = shift;
    my @super;
    Iter::Ancestors( $classNode, $global_rootnode, undef, undef, sub {
                        push @super, @_[0];
                        push @super, superclass_list( @_[0] );
                     }, undef );
    return @super;
}

#
#   returns 1 if enum
#
sub isEnum
{
    my ($name) = @_;

    foreach $enum (@enums){
        if($name eq $enum->{astNodeName}){
            return 1;
        }
    }
    return 0;
}

# returns 1 if moc is needed

sub hasMetaObject
{
    foreach my $key (keys %methods)
    {
        $method = %methods->{$key};
        if($method->{astNodeName} eq "metaObject"){
            return 1;
        }
    }
    return 0;
}

#
# returns 1 if class is abstract
# abstract classes cannot be instanciated

sub isAbstract
{
    my ($className) = @_;

    if($className eq "") {return 0;}

    my $iter_class = kdocAstUtil::findRef( $global_rootnode, $className, sub{});

    if($iter_class->{Pure} == 1){
        return 1;
    } else {
        return 0;
    }

}

sub isChar
{

    my ($arg) = @_;

    my @arg_ = split(/ /,$arg);

    foreach $chunk (@arg_){
        return 1 if($chunk eq "char");
    }

    return 0;

}

sub debug
{
    my ($string) = @_;

    print CLASS "/// DEBUG:".$string.".\n";

}

# 3     important hints
# 4     informations for later

sub report
{
    my ($string, $level) = @_;

    print "REPORT ".$classname.": ".$string.".\n" if $level < 5;

}

1;
