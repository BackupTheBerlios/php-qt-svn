/*
 * PHP-Qt - The PHP language bindings for Qt
 *
 * Copyright (C) 2006
 * Thomas Moenicke <tm@ippfp.org>,
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * QTime.cpp - QTime PHP implementation.
 * begin           : Tue Jun  6 22:42:56 2006
 * generated by    : moni using kalyptus 0.9.
 */

#include <iostream>
using namespace std;

#include "../php_qt.h"


#include <QTime>
#include <QMetaMethod>
class QTime_php_qt:public QTime
{

public:
  QTime_php_qt(zval * zend_ptr);
  QTime_php_qt(zval * zend_ptr, int hs0, int ms1, int s = 0, int ms = 0);


  zval *zend_ptr;
};

QTime_php_qt::QTime_php_qt(zval * zend_ptr):QTime()
{
  this->zend_ptr = zend_ptr;
}
QTime_php_qt::QTime_php_qt(zval * zend_ptr, int hs0, int ms1, int s, int ms):
QTime(hs0, ms1, s, ms)
{
  this->zend_ptr = zend_ptr;
}

/*!
 * method hour
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QTime, hour)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'hour' is not static");
        RETURN_NULL();
      }
      /// try 
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->hour());
    }
  }
  php_error(E_ERROR, "could not parse argument in QTime::hour(...) ");
}

/*!
 * method isValid
 * 
 * @param: -
 * @param: -
 * 
 * overloaded args:
 * @param	int h
 * @param	 int m
 * @param	 int s
 * @param	 int ms = 0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QTime, isValid)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isValid' is not static");
        RETURN_NULL();
      }
      /// try 
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isValid());
    }
  }
  ///int h, int m, int s, int ms = 0
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
      /// try int h, int m, int s,
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      if (getThis() == NULL) {
        RETURN_BOOL(QTime::isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
      } else {
        RETURN_BOOL(selfpointer->isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
    }}
  }
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
      /// try int h, int m, int s, int ms = 0,
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      if (getThis() == NULL) {
        RETURN_BOOL(QTime::isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
      } else {
        RETURN_BOOL(selfpointer->isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
    }}
  }
  php_error(E_ERROR, "could not parse argument in QTime::isValid(...) ");
}

/*!
 * method elapsed
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QTime, elapsed)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'elapsed' is not static");
        RETURN_NULL();
      }
      /// try 
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->elapsed());
    }
  }
  php_error(E_ERROR, "could not parse argument in QTime::elapsed(...) ");
}

/*!
 * method fromString
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &ss0
 * @param	 Qt::DateFormat f = Qt::TextDates1
 * 
 * overloaded args:
 * @param	const QString &s
 * @param	 const QString &format
 * 
 * @access	public
 * @return	QTime
 * @flags	s
 */

ZEND_METHOD(QTime, fromString)
{
  ///const QString &ss0, Qt::DateFormat f = Qt::TextDates1
#ifdef PHP_QT_QTime             // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        /// try const QString &ss0,
        QTime *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QTime *return_object = new QTime;

        if (getThis() == NULL) {
          *return_object = static_cast < QTime > (QTime::fromString((const QString &)*cpp_arg_0));
        } else {
          *return_object = static_cast < QTime > (selfpointer->fromString((const QString &)*cpp_arg_0));
        } le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        /// try const QString &ss0, Qt::DateFormat f = Qt::TextDates1,
        QTime *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QTime *return_object = new QTime;

        if (getThis() == NULL) {
          *return_object = static_cast < QTime > (QTime::fromString((const QString &)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
        } else {
          *return_object = static_cast < QTime > (selfpointer->fromString((const QString &)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
        } le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///const QString &s, const QString &format
#ifdef PHP_QT_QTime             // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_1 = invokeToQString(arg_1);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QString
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
        /// try const QString &s, const QString &format,
        QTime *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QTime *return_object = new QTime;

        if (getThis() == NULL) {
          *return_object = static_cast < QTime > (QTime::fromString((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
        } else {
          *return_object = static_cast < QTime > (selfpointer->fromString((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
        } le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QTime::fromString(...) ");
}

/*!
 * method second
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QTime, second)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'second' is not static");
        RETURN_NULL();
      }
      /// try 
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->second());
    }
  }
  php_error(E_ERROR, "could not parse argument in QTime::second(...) ");
}

/*!
 * method setHMS
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int hs0
 * @param	 int ms1
 * @param	 int ss2
 * @param	 int ms = 0s3
 * 
 * @access	public
 * @return	bool
 * @flags	
 */

ZEND_METHOD(QTime, setHMS)
{
  ///int hs0, int ms1, int ss2, int ms = 0s3
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setHMS' is not static");
        RETURN_NULL();
      }
      /// try int hs0, int ms1, int ss2,
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->setHMS((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
    }
  }
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setHMS' is not static");
        RETURN_NULL();
      }
      /// try int hs0, int ms1, int ss2, int ms = 0s3,
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->setHMS((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QTime::setHMS(...) ");
}

/*!
 * method minute
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QTime, minute)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'minute' is not static");
        RETURN_NULL();
      }
      /// try 
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->minute());
    }
  }
  php_error(E_ERROR, "could not parse argument in QTime::minute(...) ");
}

/*!
 * method start
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QTime, start)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'start' is not static");
        RETURN_NULL();
      }
      /// try 
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->start());
    }
  }
  php_error(E_ERROR, "could not parse argument in QTime::start(...) ");
}

/*!
 * method operator<
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QTime &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method operator==
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QTime &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method addSecs
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int secss0
 * 
 * @access	public
 * @return	QTime
 * @flags	c
 */

ZEND_METHOD(QTime, addSecs)
{
  ///int secss0
#ifdef PHP_QT_QTime             // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'addSecs' is not static");
        RETURN_NULL();
      }
      /// try int secss0,
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QTime *return_object = new QTime;

      *return_object = static_cast < QTime > (selfpointer->addSecs((int)Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QTime::addSecs(...) ");
}

/*!
 * method currentTime
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QTime
 * @flags	s
 */

ZEND_METHOD(QTime, currentTime)
{
  ///
#ifdef PHP_QT_QTime             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      /// try 
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QTime *return_object = new QTime;

      if (getThis() == NULL) {
        *return_object = static_cast < QTime > (QTime::currentTime());
      } else {
        *return_object = static_cast < QTime > (selfpointer->currentTime());
      }
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QTime::currentTime(...) ");
}

/*!
 * method operator!=
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QTime &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method operator>
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QTime &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method msec
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QTime, msec)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'msec' is not static");
        RETURN_NULL();
      }
      /// try 
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->msec());
    }
  }
  php_error(E_ERROR, "could not parse argument in QTime::msec(...) ");
}

/*!
 * method secsTo
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QTime &s0
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QTime, secsTo)
{
  ///const QTime &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QTime
      if (inherits(Z_OBJCE_P(arg_0), 63)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'secsTo' is not static");
          RETURN_NULL();
        }
        /// try const QTime &s0,
        QTime *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
        }
        QTime *cpp_arg_0 = static_cast < QTime * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->secsTo((const QTime &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QTime::secsTo(...) ");
}

/*!
 * method addMSecs
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int mss0
 * 
 * @access	public
 * @return	QTime
 * @flags	c
 */

ZEND_METHOD(QTime, addMSecs)
{
  ///int mss0
#ifdef PHP_QT_QTime             // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'addMSecs' is not static");
        RETURN_NULL();
      }
      /// try int mss0,
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QTime *return_object = new QTime;

      *return_object = static_cast < QTime > (selfpointer->addMSecs((int)Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QTime::addMSecs(...) ");
}

/*!
 * method msecsTo
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QTime &s0
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QTime, msecsTo)
{
  ///const QTime &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QTime
      if (inherits(Z_OBJCE_P(arg_0), 63)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'msecsTo' is not static");
          RETURN_NULL();
        }
        /// try const QTime &s0,
        QTime *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
        }
        QTime *cpp_arg_0 = static_cast < QTime * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->msecsTo((const QTime &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QTime::msecsTo(...) ");
}

/*!
 * method operator<=
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QTime &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method toString
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::DateFormat f = Qt::TextDates0
 * 
 * overloaded args:
 * @param	const QString &format
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QTime, toString)
{
  ///Qt::DateFormat f = Qt::TextDates0
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toString' is not static");
        RETURN_NULL();
      }
      /// try 
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->toString());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toString' is not static");
        RETURN_NULL();
      }
      /// try Qt::DateFormat f = Qt::TextDates0,
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->toString((Qt::DateFormat) Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///const QString &format
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'toString' is not static");
          RETURN_NULL();
        }
        /// try const QString &format,
        QTime *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object = static_cast < QString > (selfpointer->toString((const QString &)*cpp_arg_0));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QTime::toString(...) ");
}

/*!
 * method restart
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	
 */

ZEND_METHOD(QTime, restart)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'restart' is not static");
        RETURN_NULL();
      }
      /// try 
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->restart());
    }
  }
  php_error(E_ERROR, "could not parse argument in QTime::restart(...) ");
}

/*!
 * method QTime
 * 
 * @param: -
 * @param: -
 * 
 * overloaded args:
 * @param	int hs0
 * @param	int ms1
 * @param	 int s = 0
 * @param	 int ms = 0
 * 
 * @access	public
 * @return	
 * @flags	
 */

ZEND_METHOD(QTime, __construct)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try 
      QTime_php_qt *selfpointer = new QTime_php_qt(getThis());

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  ///int hs0,int ms1, int s = 0, int ms = 0
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try int hs0,int ms1,
      QTime_php_qt *selfpointer = new QTime_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1));

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try int hs0,int ms1, int s = 0,
      QTime_php_qt *selfpointer = new QTime_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2));

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try int hs0,int ms1, int s = 0, int ms = 0,
      QTime_php_qt *selfpointer = new QTime_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3));

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  php_error(E_ERROR, "could not parse argument in QTime::QTime(...) ");
}

/*!
 * method isNull
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QTime, isNull)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isNull' is not static");
        RETURN_NULL();
      }
      /// try 
      QTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QTime * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isNull());
    }
  }
  php_error(E_ERROR, "could not parse argument in QTime::isNull(...) ");
}

/*!
 * method operator>=
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QTime &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */
