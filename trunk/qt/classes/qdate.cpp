/*
 * PHP-Qt - The PHP language bindings for Qt
 *
 * Copyright (C) 2006
 * Thomas Moenicke <tm@ippfp.org>,
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * QDate.cpp - QDate PHP implementation.
 * begin           : Tue Jun  6 22:42:56 2006
 * generated by    : moni using kalyptus 0.9.
 */

#include <iostream>
using namespace std;

#include "../php_qt.h"


#include <QDate>
#include <QMetaMethod>
class QDate_php_qt:public QDate
{

public:
  QDate_php_qt(zval * zend_ptr);
  QDate_php_qt(zval * zend_ptr, int ys0, int ms1, int ds2);


  zval *zend_ptr;
};

QDate_php_qt::QDate_php_qt(zval * zend_ptr):QDate()
{
  this->zend_ptr = zend_ptr;
}
QDate_php_qt::QDate_php_qt(zval * zend_ptr, int ys0, int ms1, int ds2):
QDate(ys0, ms1, ds2)
{
  this->zend_ptr = zend_ptr;
}

/*!
 * method isValid
 * 
 * @param: -
 * @param: -
 * 
 * overloaded args:
 * @param	int y
 * @param	 int m
 * @param	 int d
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QDate, isValid)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isValid' is not static");
        RETURN_NULL();
      }
      /// try 
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isValid());
    }
  }
  ///int y, int m, int d
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
      /// try int y, int m, int d,
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      if (getThis() == NULL) {
        RETURN_BOOL(QDate::isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
      } else {
        RETURN_BOOL(selfpointer->isValid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
    }}
  }
  php_error(E_ERROR, "could not parse argument in QDate::isValid(...) ");
}

/*!
 * method shortMonthName
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int months0
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QDate, shortMonthName)
{
  ///int months0
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      /// try int months0,
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QDate::shortMonthName((int)Z_LVAL_P(arg_0)));
      } else {
        *return_object = static_cast < QString > (selfpointer->shortMonthName((int)Z_LVAL_P(arg_0)));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDate::shortMonthName(...) ");
}

/*!
 * method fromJulianDay
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int jds0
 * 
 * @access	public
 * @return	QDate
 * @flags	s
 */

ZEND_METHOD(QDate, fromJulianDay)
{
  ///int jds0
#ifdef PHP_QT_QDate             // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      /// try int jds0,
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QDate *return_object = new QDate;

      if (getThis() == NULL) {
        *return_object = static_cast < QDate > (QDate::fromJulianDay((int)Z_LVAL_P(arg_0)));
      } else {
        *return_object = static_cast < QDate > (selfpointer->fromJulianDay((int)Z_LVAL_P(arg_0)));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDate::fromJulianDay(...) ");
}

/*!
 * method currentDate
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QDate
 * @flags	s
 */

ZEND_METHOD(QDate, currentDate)
{
  ///
#ifdef PHP_QT_QDate             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      /// try 
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QDate *return_object = new QDate;

      if (getThis() == NULL) {
        *return_object = static_cast < QDate > (QDate::currentDate());
      } else {
        *return_object = static_cast < QDate > (selfpointer->currentDate());
      }
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDate::currentDate(...) ");
}

/*!
 * method addDays
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int dayss0
 * 
 * @access	public
 * @return	QDate
 * @flags	c
 */

ZEND_METHOD(QDate, addDays)
{
  ///int dayss0
#ifdef PHP_QT_QDate             // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'addDays' is not static");
        RETURN_NULL();
      }
      /// try int dayss0,
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QDate *return_object = new QDate;

      *return_object = static_cast < QDate > (selfpointer->addDays((int)Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDate::addDays(...) ");
}

/*!
 * method day
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QDate, day)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'day' is not static");
        RETURN_NULL();
      }
      /// try 
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->day());
    }
  }
  php_error(E_ERROR, "could not parse argument in QDate::day(...) ");
}

/*!
 * method fromString
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &ss0
 * @param	 Qt::DateFormat f = Qt::TextDates1
 * 
 * overloaded args:
 * @param	const QString &s
 * @param	 const QString &format
 * 
 * @access	public
 * @return	QDate
 * @flags	s
 */

ZEND_METHOD(QDate, fromString)
{
  ///const QString &ss0, Qt::DateFormat f = Qt::TextDates1
#ifdef PHP_QT_QDate             // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        /// try const QString &ss0,
        QDate *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QDate *return_object = new QDate;

        if (getThis() == NULL) {
          *return_object = static_cast < QDate > (QDate::fromString((const QString &)*cpp_arg_0));
        } else {
          *return_object = static_cast < QDate > (selfpointer->fromString((const QString &)*cpp_arg_0));
        } le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        /// try const QString &ss0, Qt::DateFormat f = Qt::TextDates1,
        QDate *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QDate *return_object = new QDate;

        if (getThis() == NULL) {
          *return_object = static_cast < QDate > (QDate::fromString((const QString &)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
        } else {
          *return_object = static_cast < QDate > (selfpointer->fromString((const QString &)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
        } le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///const QString &s, const QString &format
#ifdef PHP_QT_QDate             // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_1 = invokeToQString(arg_1);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QString
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
        /// try const QString &s, const QString &format,
        QDate *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QDate *return_object = new QDate;

        if (getThis() == NULL) {
          *return_object = static_cast < QDate > (QDate::fromString((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
        } else {
          *return_object = static_cast < QDate > (selfpointer->fromString((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
        } le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDate::fromString(...) ");
}

/*!
 * method daysTo
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QDate &s0
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QDate, daysTo)
{
  ///const QDate &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QDate
      if (inherits(Z_OBJCE_P(arg_0), 13)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'daysTo' is not static");
          RETURN_NULL();
        }
        /// try const QDate &s0,
        QDate *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
        }
        QDate *cpp_arg_0 = static_cast < QDate * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->daysTo((const QDate &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QDate::daysTo(...) ");
}

/*!
 * method month
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QDate, month)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'month' is not static");
        RETURN_NULL();
      }
      /// try 
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->month());
    }
  }
  php_error(E_ERROR, "could not parse argument in QDate::month(...) ");
}

/*!
 * method operator<
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QDate &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method operator==
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QDate &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method isLeapYear
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int years0
 * 
 * @access	public
 * @return	bool
 * @flags	s
 */

ZEND_METHOD(QDate, isLeapYear)
{
  ///int years0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      /// try int years0,
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      if (getThis() == NULL) {
        RETURN_BOOL(QDate::isLeapYear((int)Z_LVAL_P(arg_0)));
      } else {
        RETURN_BOOL(selfpointer->isLeapYear((int)Z_LVAL_P(arg_0)));
    }}
  }
  php_error(E_ERROR, "could not parse argument in QDate::isLeapYear(...) ");
}

/*!
 * method gregorianToJulian
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ys0
 * @param	 int ms1
 * @param	 int ds2
 * 
 * @access	public
 * @return	uint
 * @flags	s
 */

ZEND_METHOD(QDate, gregorianToJulian)
{
  ///int ys0, int ms1, int ds2
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
      /// try int ys0, int ms1, int ds2,
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      if (getThis() == NULL) {
        RETURN_LONG(QDate::gregorianToJulian((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
      } else {
        RETURN_LONG(selfpointer->gregorianToJulian((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
    }}
  }
  php_error(E_ERROR, "could not parse argument in QDate::gregorianToJulian(...) ");
}

/*!
 * method julianToGregorian
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	uint jds0
 * @param	 int &ys1
 * @param	 int &ms2
 * @param	 int &ds3
 * 
 * @access	public
 * @return	void
 * @flags	s
 */

ZEND_METHOD(QDate, julianToGregorian)
{
  ///uint jds0, int &ys1, int &ms2, int &ds3
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
      /// try uint jds0, int &ys1, int &ms2, int &ds3,
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      if (getThis() == NULL) {
        RETURN_VOID(QDate::julianToGregorian((uint) Z_LVAL_P(arg_0), (int &)Z_LVAL_P(arg_1), (int &)Z_LVAL_P(arg_2), (int &)Z_LVAL_P(arg_3)));
      } else {
        RETURN_VOID(selfpointer->julianToGregorian((uint) Z_LVAL_P(arg_0), (int &)Z_LVAL_P(arg_1), (int &)Z_LVAL_P(arg_2), (int &)Z_LVAL_P(arg_3)));
    }}
  }
  php_error(E_ERROR, "could not parse argument in QDate::julianToGregorian(...) ");
}

/*!
 * method QDate
 * 
 * @param: -
 * @param: -
 * 
 * overloaded args:
 * @param	int ys0
 * @param	int ms1
 * @param	int ds2
 * 
 * @access	public
 * @return	
 * @flags	
 */

ZEND_METHOD(QDate, __construct)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try 
      QDate_php_qt *selfpointer = new QDate_php_qt(getThis());

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  ///int ys0,int ms1,int ds2
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try int ys0,int ms1,int ds2,
      QDate_php_qt *selfpointer = new QDate_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2));

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  php_error(E_ERROR, "could not parse argument in QDate::QDate(...) ");
}

/*!
 * method weekNumber
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int *yearNum = 0s0
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QDate, weekNumber)
{
  ///int *yearNum = 0s0
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'weekNumber' is not static");
        RETURN_NULL();
      }
      /// try 
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->weekNumber());
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'weekNumber' is not static");
        RETURN_NULL();
      }
      /// try int *yearNum = 0s0,
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->weekNumber((int *)&Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QDate::weekNumber(...) ");
}

/*!
 * method addMonths
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int monthss0
 * 
 * @access	public
 * @return	QDate
 * @flags	c
 */

ZEND_METHOD(QDate, addMonths)
{
  ///int monthss0
#ifdef PHP_QT_QDate             // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'addMonths' is not static");
        RETURN_NULL();
      }
      /// try int monthss0,
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QDate *return_object = new QDate;

      *return_object = static_cast < QDate > (selfpointer->addMonths((int)Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDate::addMonths(...) ");
}

/*!
 * method year
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QDate, year)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'year' is not static");
        RETURN_NULL();
      }
      /// try 
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->year());
    }
  }
  php_error(E_ERROR, "could not parse argument in QDate::year(...) ");
}

/*!
 * method dayOfWeek
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QDate, dayOfWeek)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'dayOfWeek' is not static");
        RETURN_NULL();
      }
      /// try 
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->dayOfWeek());
    }
  }
  php_error(E_ERROR, "could not parse argument in QDate::dayOfWeek(...) ");
}

/*!
 * method operator!=
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QDate &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method setYMD
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ys0
 * @param	 int ms1
 * @param	 int ds2
 * 
 * @access	public
 * @return	bool
 * @flags	
 */

ZEND_METHOD(QDate, setYMD)
{
  ///int ys0, int ms1, int ds2
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setYMD' is not static");
        RETURN_NULL();
      }
      /// try int ys0, int ms1, int ds2,
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->setYMD((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QDate::setYMD(...) ");
}

/*!
 * method operator>
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QDate &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method dayOfYear
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QDate, dayOfYear)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'dayOfYear' is not static");
        RETURN_NULL();
      }
      /// try 
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->dayOfYear());
    }
  }
  php_error(E_ERROR, "could not parse argument in QDate::dayOfYear(...) ");
}

/*!
 * method toJulianDay
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QDate, toJulianDay)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toJulianDay' is not static");
        RETURN_NULL();
      }
      /// try 
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->toJulianDay());
    }
  }
  php_error(E_ERROR, "could not parse argument in QDate::toJulianDay(...) ");
}

/*!
 * method addYears
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int yearss0
 * 
 * @access	public
 * @return	QDate
 * @flags	c
 */

ZEND_METHOD(QDate, addYears)
{
  ///int yearss0
#ifdef PHP_QT_QDate             // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'addYears' is not static");
        RETURN_NULL();
      }
      /// try int yearss0,
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QDate *return_object = new QDate;

      *return_object = static_cast < QDate > (selfpointer->addYears((int)Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDate::addYears(...) ");
}

/*!
 * method longDayName
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int weekdays0
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QDate, longDayName)
{
  ///int weekdays0
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      /// try int weekdays0,
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QDate::longDayName((int)Z_LVAL_P(arg_0)));
      } else {
        *return_object = static_cast < QString > (selfpointer->longDayName((int)Z_LVAL_P(arg_0)));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDate::longDayName(...) ");
}

/*!
 * method daysInMonth
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QDate, daysInMonth)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'daysInMonth' is not static");
        RETURN_NULL();
      }
      /// try 
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->daysInMonth());
    }
  }
  php_error(E_ERROR, "could not parse argument in QDate::daysInMonth(...) ");
}

/*!
 * method operator<=
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QDate &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method toString
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::DateFormat f = Qt::TextDates0
 * 
 * overloaded args:
 * @param	const QString &format
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QDate, toString)
{
  ///Qt::DateFormat f = Qt::TextDates0
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toString' is not static");
        RETURN_NULL();
      }
      /// try 
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->toString());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toString' is not static");
        RETURN_NULL();
      }
      /// try Qt::DateFormat f = Qt::TextDates0,
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->toString((Qt::DateFormat) Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///const QString &format
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'toString' is not static");
          RETURN_NULL();
        }
        /// try const QString &format,
        QDate *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object = static_cast < QString > (selfpointer->toString((const QString &)*cpp_arg_0));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDate::toString(...) ");
}

/*!
 * method longMonthName
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int months0
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QDate, longMonthName)
{
  ///int months0
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      /// try int months0,
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QDate::longMonthName((int)Z_LVAL_P(arg_0)));
      } else {
        *return_object = static_cast < QString > (selfpointer->longMonthName((int)Z_LVAL_P(arg_0)));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDate::longMonthName(...) ");
}

/*!
 * method shortDayName
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int weekdays0
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QDate, shortDayName)
{
  ///int weekdays0
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      /// try int weekdays0,
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QDate::shortDayName((int)Z_LVAL_P(arg_0)));
      } else {
        *return_object = static_cast < QString > (selfpointer->shortDayName((int)Z_LVAL_P(arg_0)));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDate::shortDayName(...) ");
}

/*!
 * method isNull
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QDate, isNull)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isNull' is not static");
        RETURN_NULL();
      }
      /// try 
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isNull());
    }
  }
  php_error(E_ERROR, "could not parse argument in QDate::isNull(...) ");
}

/*!
 * method operator>=
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QDate &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method daysInYear
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QDate, daysInYear)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'daysInYear' is not static");
        RETURN_NULL();
      }
      /// try 
      QDate *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDate * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->daysInYear());
    }
  }
  php_error(E_ERROR, "could not parse argument in QDate::daysInYear(...) ");
}
