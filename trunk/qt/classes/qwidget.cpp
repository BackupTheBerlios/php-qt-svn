/*
 * PHP-Qt - The PHP language bindings for Qt
 *
 * Copyright (C) 2006
 * Thomas Moenicke <tm@ippfp.org>,
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * QWidget.cpp - QWidget PHP implementation.
 * begin           : Tue Jun  6 22:42:56 2006
 * generated by    : moni using kalyptus 0.9.
 */

#include <iostream>
using namespace std;

#include "../php_qt.h"


#include <QWidget>
#include <QIcon>
/// DEBUG:destructor skipped.
#include <QMetaMethod>
class QWidget_php_qt:public QWidget
{

public:
  QWidget_php_qt(zval * zend_ptr, QWidget * parent = 0, Qt::WFlags f = 0);


  zval *zend_ptr;
  const QMetaObject *metaObject() const;
  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
};

QWidget_php_qt::QWidget_php_qt(zval * zend_ptr, QWidget * parent, Qt::WFlags f):QWidget(parent, f)
{
  this->zend_ptr = zend_ptr;
// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QWidget",&staticMetaObject));
}

PHP_QT_MOC(QWidget);

/*!
 * method nextInFocusChain
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QWidget *
 * @flags	c
 */

ZEND_METHOD(QWidget, nextInFocusChain)
{
  ///
#ifdef PHP_QT_QWidget           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'nextInFocusChain' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = static_cast < QWidget * >(selfpointer->nextInFocusChain());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::nextInFocusChain(...) ");
}

/*!
 * method tr
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 const char *s0
 * @param	 const char * = 0 s1
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QWidget, tr)
{
  /// const char *s0, const char * = 0 s1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      /// try  const char *s0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QString *
        return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QWidget::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
      /// try  const char *s0, const char * = 0 s1,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QString *
        return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QWidget::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::tr(...) ");
}

/*!
 * method focusPolicy
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Qt::FocusPolicy
 * @flags	c
 */

ZEND_METHOD(QWidget, focusPolicy)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'focusPolicy' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->focusPolicy());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::focusPolicy(...) ");
}

/*!
 * method mouseMoveEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QMouseEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method insertActions
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QAction *befores0
 * @param	 QList<QAction*> actionss1
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, insertActions)
{
  ///QAction *befores0, QList<QAction*> actionss1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QAction
#ifdef PHP_QT_QList
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'insertActions' is not static");
          RETURN_NULL();
        }
        /// try QAction *befores0, QList<QAction*> actionss1,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QAction *
          cpp_arg_0 = static_cast < QAction * >(php_qt_fetch(arg_0));

        QList < QAction > *cpp_arg_1 = static_cast < QList < QAction > *>(php_qt_fetch(arg_1));
        RETURN_VOID(selfpointer->insertActions((QAction *) cpp_arg_0, (QList < QAction > *)cpp_arg_1));
      }
#endif

#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::insertActions(...) ");
}

/*!
 * method windowOpacity
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	qreal
 * @flags	c
 */

ZEND_METHOD(QWidget, windowOpacity)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type qreal");
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::windowOpacity(...) ");
}

/*!
 * method y
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QWidget, y)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'y' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->y());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::y(...) ");
}

/*!
 * method clearFocus
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, clearFocus)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'clearFocus' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->clearFocus());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::clearFocus(...) ");
}

/*!
 * method fontInfo
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QFontInfo
 * @flags	c
 */

ZEND_METHOD(QWidget, fontInfo)
{
  ///
#ifdef PHP_QT_QFontInfo         // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'fontInfo' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QFontInfo *
        return_object = new QFontInfo;

      *return_object = static_cast < QFontInfo > (selfpointer->fontInfo());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::fontInfo(...) ");
}

/*!
 * method isHidden
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, isHidden)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isHidden' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isHidden());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::isHidden(...) ");
}

/*!
 * method qt_cast
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 const char * s0
 * 
 * @access	public
 * @return	void*
 * @flags	v
 */

/*!
 * method styleChange
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QStyle &s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method setMaximumWidth
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int maxws0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setMaximumWidth)
{
  ///int maxws0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setMaximumWidth' is not static");
        RETURN_NULL();
      }
      /// try int maxws0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setMaximumWidth((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setMaximumWidth(...) ");
}

/*!
 * method metaObject
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QMetaObject *
 * @flags	cv
 */

/*!
 * method contentsRect
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QRect
 * @flags	c
 */

ZEND_METHOD(QWidget, contentsRect)
{
  ///
#ifdef PHP_QT_QRect             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'contentsRect' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QRect *
        return_object = new QRect;

      *return_object = static_cast < QRect > (selfpointer->contentsRect());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::contentsRect(...) ");
}

/*!
 * method setContextMenuPolicy
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::ContextMenuPolicy policys0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setContextMenuPolicy)
{
  ///Qt::ContextMenuPolicy policys0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setContextMenuPolicy' is not static");
        RETURN_NULL();
      }
      /// try Qt::ContextMenuPolicy policys0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setContextMenuPolicy((Qt::ContextMenuPolicy) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setContextMenuPolicy(...) ");
}

/*!
 * method focusProxy
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QWidget *
 * @flags	c
 */

ZEND_METHOD(QWidget, focusProxy)
{
  ///
#ifdef PHP_QT_QWidget           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'focusProxy' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = static_cast < QWidget * >(selfpointer->focusProxy());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::focusProxy(...) ");
}

/*!
 * method statusTip
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QWidget, statusTip)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'statusTip' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QString *
        return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->statusTip());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::statusTip(...) ");
}

/*!
 * method visibleRegion
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QRegion
 * @flags	c
 */

ZEND_METHOD(QWidget, visibleRegion)
{
  ///
#ifdef PHP_QT_QRegion           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'visibleRegion' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QRegion *
        return_object = new QRegion;

      *return_object = static_cast < QRegion > (selfpointer->visibleRegion());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::visibleRegion(...) ");
}

/*!
 * method isVisibleTo
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget *s0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, isVisibleTo)
{
  ///QWidget *s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QWidget
      if (inherits(Z_OBJCE_P(arg_0), 71)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'isVisibleTo' is not static");
          RETURN_NULL();
        }
        /// try QWidget *s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QWidget *
          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->isVisibleTo((QWidget *) cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::isVisibleTo(...) ");
}

/*!
 * method releaseMouse
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, releaseMouse)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'releaseMouse' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->releaseMouse());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::releaseMouse(...) ");
}

/*!
 * method setTabOrder
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget *s0
 * @param	 QWidget *s1
 * 
 * @access	public
 * @return	void
 * @flags	s
 */

ZEND_METHOD(QWidget, setTabOrder)
{
  ///QWidget *s0, QWidget *s1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QWidget
#ifdef PHP_QT_QWidget
      if (inherits(Z_OBJCE_P(arg_0), 71) && inherits(Z_OBJCE_P(arg_1), 71)) {
        /// try QWidget *s0, QWidget *s1,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QWidget *
          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
        QWidget *
          cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));

        if (getThis() == NULL) {
          RETURN_VOID(QWidget::setTabOrder((QWidget *) cpp_arg_0, (QWidget *) cpp_arg_1));
        } else {
          RETURN_VOID(selfpointer->setTabOrder((QWidget *) cpp_arg_0, (QWidget *) cpp_arg_1));
        }
      }
#endif

#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setTabOrder(...) ");
}

/*!
 * method setFocusProxy
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget *s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setFocusProxy)
{
  ///QWidget *s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QWidget
      if (inherits(Z_OBJCE_P(arg_0), 71)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setFocusProxy' is not static");
          RETURN_NULL();
        }
        /// try QWidget *s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QWidget *
          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setFocusProxy((QWidget *) cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setFocusProxy(...) ");
}

/*!
 * method qt_emit
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 int  ints0
 * @param	 QUObject * s1
 * 
 * @access	public
 * @return	bool
 * @flags	v
 */

/*!
 * method topLevelWidget
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QWidget *
 * @flags	c
 */

ZEND_METHOD(QWidget, topLevelWidget)
{
  ///
#ifdef PHP_QT_QWidget           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'topLevelWidget' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = static_cast < QWidget * >(selfpointer->topLevelWidget());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::topLevelWidget(...) ");
}

/*!
 * method mapToParent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPoint &s0
 * 
 * @access	public
 * @return	QPoint
 * @flags	c
 */

ZEND_METHOD(QWidget, mapToParent)
{
  ///const QPoint &s0
#ifdef PHP_QT_QPoint            // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'mapToParent' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
        zend_class_entry *
          ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry
          le;
        QPoint *
          return_object = new QPoint;

        *return_object = static_cast < QPoint > (selfpointer->mapToParent((const QPoint &)*cpp_arg_0));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::mapToParent(...) ");
}

/*!
 * method className
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const char *
 * @flags	cv
 */

/*!
 * method overrideWindowFlags
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::WindowFlags types0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, overrideWindowFlags)
{
  ///Qt::WindowFlags types0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'overrideWindowFlags' is not static");
        RETURN_NULL();
      }
      /// try Qt::WindowFlags types0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->overrideWindowFlags((Qt::WindowFlags) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::overrideWindowFlags(...) ");
}

/*!
 * method hide
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QWidget, hide)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'hide' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->hide());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::hide(...) ");
}

/*!
 * method mapTo
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget *s0
 * @param	 const QPoint  &s1
 * 
 * @access	public
 * @return	QPoint
 * @flags	c
 */

ZEND_METHOD(QWidget, mapTo)
{
  ///QWidget *s0, const QPoint  &s1
#ifdef PHP_QT_QPoint            // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QWidget
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 71) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'mapTo' is not static");
          RETURN_NULL();
        }
        /// try QWidget *s0, const QPoint  &s1,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QWidget *
          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
        QPoint *
          cpp_arg_1 = static_cast < QPoint * >(php_qt_fetch(arg_1));
        zend_class_entry *
          ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry
          le;
        QPoint *
          return_object = new QPoint;

        *return_object = static_cast < QPoint > (selfpointer->mapTo((QWidget *) cpp_arg_0, (const QPoint &)*cpp_arg_1));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::mapTo(...) ");
}

/*!
 * method childrenRect
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QRect
 * @flags	c
 */

ZEND_METHOD(QWidget, childrenRect)
{
  ///
#ifdef PHP_QT_QRect             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'childrenRect' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QRect *
        return_object = new QRect;

      *return_object = static_cast < QRect > (selfpointer->childrenRect());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::childrenRect(...) ");
}

/*!
 * method setStyle
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QStyle *s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setStyle)
{
  ///QStyle *s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QStyle
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setStyle' is not static");
          RETURN_NULL();
        }
        /// try QStyle *s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QStyle *
          cpp_arg_0 = static_cast < QStyle * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setStyle((QStyle *) cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setStyle(...) ");
}

/*!
 * method isRightToLeft
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, isRightToLeft)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isRightToLeft' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isRightToLeft());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::isRightToLeft(...) ");
}

/*!
 * method setWindowModified
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QWidget, setWindowModified)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setWindowModified' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setWindowModified((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setWindowModified(...) ");
}

/*!
 * method setBackgroundRole
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QPalette::ColorRole QPalette::ColorRoles0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setBackgroundRole)
{
  ///QPalette::ColorRole QPalette::ColorRoles0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setBackgroundRole' is not static");
        RETURN_NULL();
      }
      /// try QPalette::ColorRole QPalette::ColorRoles0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setBackgroundRole((QPalette::ColorRole) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setBackgroundRole(...) ");
}

/*!
 * method setFixedSize
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QSize &s0
 * 
 * overloaded args:
 * @param	int w
 * @param	 int h
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setFixedSize)
{
  ///const QSize &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QSize
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setFixedSize' is not static");
          RETURN_NULL();
        }
        /// try const QSize &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QSize *
          cpp_arg_0 = static_cast < QSize * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setFixedSize((const QSize &)*cpp_arg_0));
      }
#endif

    }
  }
  ///int w, int h
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setFixedSize' is not static");
        RETURN_NULL();
      }
      /// try int w, int h,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setFixedSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setFixedSize(...) ");
}

/*!
 * method focusPreviousChild
 * 
 * @param: -
 * @param: -
 * 
 * @access	protected
 * @return	bool
 * @flags	
 */

/*!
 * method dragLeaveEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QDragLeaveEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method inputContext
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QInputContext *
 * @flags	
 */

ZEND_METHOD(QWidget, inputContext)
{
  ///
#ifdef PHP_QT_QInputContext     // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'inputContext' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = static_cast < QInputContext * >(selfpointer->inputContext());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::inputContext(...) ");
}

/*!
 * method palette
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const QPalette &
 * @flags	c
 */

ZEND_METHOD(QWidget, palette)
{
  ///
#ifdef PHP_QT_QPalette          // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'palette' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = &const_cast < QPalette & >(selfpointer->palette());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::palette(...) ");
}

/*!
 * method setFixedHeight
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int hs0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setFixedHeight)
{
  ///int hs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setFixedHeight' is not static");
        RETURN_NULL();
      }
      /// try int hs0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setFixedHeight((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setFixedHeight(...) ");
}

/*!
 * method repaint
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int xs0
 * @param	 int ys1
 * @param	 int ws2
 * @param	 int hs3
 * 
 * overloaded args:
 * @param	const QRect &
 * 
 * overloaded args:
 * @param	const QRegion &
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, repaint)
{
  ///int xs0, int ys1, int ws2, int hs3
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'repaint' is not static");
        RETURN_NULL();
      }
      /// try int xs0, int ys1, int ws2, int hs3,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->repaint((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
    }
  }
  ///const QRect &
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'repaint' is not static");
          RETURN_NULL();
        }
        /// try const QRect &,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->repaint((const QRect &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QRegion &
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRegion
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'repaint' is not static");
          RETURN_NULL();
        }
        /// try const QRegion &,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QRegion *
          cpp_arg_0 = static_cast < QRegion * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->repaint((const QRegion &)*cpp_arg_0));
      }
#endif

    }
  }
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'repaint' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->repaint());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::repaint(...) ");
}

/*!
 * method cursor
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QCursor
 * @flags	c
 */

ZEND_METHOD(QWidget, cursor)
{
  ///
#ifdef PHP_QT_QCursor           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'cursor' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QCursor *
        return_object = new QCursor;

      *return_object = static_cast < QCursor > (selfpointer->cursor());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::cursor(...) ");
}

/*!
 * method setWindowIconText
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setWindowIconText)
{
  ///const QString &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setWindowIconText' is not static");
          RETURN_NULL();
        }
        /// try const QString &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QString *
          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setWindowIconText((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setWindowIconText(...) ");
}

/*!
 * method fontMetrics
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QFontMetrics
 * @flags	c
 */

ZEND_METHOD(QWidget, fontMetrics)
{
  ///
#ifdef PHP_QT_QFontMetrics      // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'fontMetrics' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QFontMetrics *
        return_object = new QFontMetrics;

      *return_object = static_cast < QFontMetrics > (selfpointer->fontMetrics());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::fontMetrics(...) ");
}

/*!
 * method grabShortcut
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QKeySequence &keys0
 * @param	 Qt::ShortcutContext context = Qt::WindowShortcuts1
 * 
 * @access	public
 * @return	int
 * @flags	
 */

ZEND_METHOD(QWidget, grabShortcut)
{
  ///const QKeySequence &keys0, Qt::ShortcutContext context = Qt::WindowShortcuts1
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QKeySequence
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'grabShortcut' is not static");
          RETURN_NULL();
        }
        /// try const QKeySequence &keys0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QKeySequence *
          cpp_arg_0 = static_cast < QKeySequence * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->grabShortcut((const QKeySequence &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QKeySequence
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'grabShortcut' is not static");
          RETURN_NULL();
        }
        /// try const QKeySequence &keys0, Qt::ShortcutContext context = Qt::WindowShortcuts1,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QKeySequence *
          cpp_arg_0 = static_cast < QKeySequence * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->grabShortcut((const QKeySequence &)*cpp_arg_0, (Qt::ShortcutContext) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::grabShortcut(...) ");
}

/*!
 * method releaseKeyboard
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, releaseKeyboard)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'releaseKeyboard' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->releaseKeyboard());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::releaseKeyboard(...) ");
}

/*!
 * method setAccessibleDescription
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &descriptions0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setAccessibleDescription)
{
  ///const QString &descriptions0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setAccessibleDescription' is not static");
          RETURN_NULL();
        }
        /// try const QString &descriptions0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QString *
          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setAccessibleDescription((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setAccessibleDescription(...) ");
}

/*!
 * method qObject
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QObject*
 * @flags	
 */

/*!
 * method maximumWidth
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QWidget, maximumWidth)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'maximumWidth' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->maximumWidth());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::maximumWidth(...) ");
}

/*!
 * method setWindowOpacity
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	qreal levels0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setWindowOpacity)
{
// notice: unknown argument qreal levels0, skipped
  php_error(E_ERROR, "could not parse argument in QWidget::setWindowOpacity(...) ");
}

/*!
 * method isTopLevel
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, isTopLevel)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isTopLevel' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isTopLevel());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::isTopLevel(...) ");
}

/*!
 * method mask
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QRegion
 * @flags	c
 */

ZEND_METHOD(QWidget, mask)
{
  ///
#ifdef PHP_QT_QRegion           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'mask' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QRegion *
        return_object = new QRegion;

      *return_object = static_cast < QRegion > (selfpointer->mask());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::mask(...) ");
}

/*!
 * method fontChange
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QFont &s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method isActiveWindow
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, isActiveWindow)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isActiveWindow' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isActiveWindow());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::isActiveWindow(...) ");
}

/*!
 * method isEnabledTo
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget *s0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, isEnabledTo)
{
  ///QWidget *s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QWidget
      if (inherits(Z_OBJCE_P(arg_0), 71)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'isEnabledTo' is not static");
          RETURN_NULL();
        }
        /// try QWidget *s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QWidget *
          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->isEnabledTo((QWidget *) cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::isEnabledTo(...) ");
}

/*!
 * method layoutDirection
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Qt::LayoutDirection
 * @flags	c
 */

ZEND_METHOD(QWidget, layoutDirection)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'layoutDirection' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->layoutDirection());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::layoutDirection(...) ");
}

/*!
 * method isAncestorOf
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QWidget *childs0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, isAncestorOf)
{
  ///const QWidget *childs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QWidget
      if (inherits(Z_OBJCE_P(arg_0), 71)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'isAncestorOf' is not static");
          RETURN_NULL();
        }
        /// try const QWidget *childs0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QWidget *
          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->isAncestorOf((const QWidget *)cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::isAncestorOf(...) ");
}

/*!
 * method windowIcon
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QIcon
 * @flags	c
 */

ZEND_METHOD(QWidget, windowIcon)
{
  ///
#ifdef PHP_QT_QIcon             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'windowIcon' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QIcon *
        return_object = new QIcon;

      *return_object = static_cast < QIcon > (selfpointer->windowIcon());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::windowIcon(...) ");
}

/*!
 * method updatesEnabled
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, updatesEnabled)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'updatesEnabled' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->updatesEnabled());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::updatesEnabled(...) ");
}

/*!
 * method isMinimized
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, isMinimized)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isMinimized' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isMinimized());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::isMinimized(...) ");
}

/*!
 * method height
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QWidget, height)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'height' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->height());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::height(...) ");
}

/*!
 * method normalGeometry
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QRect
 * @flags	c
 */

ZEND_METHOD(QWidget, normalGeometry)
{
  ///
#ifdef PHP_QT_QRect             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'normalGeometry' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QRect *
        return_object = new QRect;

      *return_object = static_cast < QRect > (selfpointer->normalGeometry());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::normalGeometry(...) ");
}

/*!
 * method setMask
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QBitmap &s0
 * 
 * overloaded args:
 * @param	const QRegion &
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setMask)
{
  ///const QBitmap &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QBitmap
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setMask' is not static");
          RETURN_NULL();
        }
        /// try const QBitmap &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QBitmap *
          cpp_arg_0 = static_cast < QBitmap * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setMask((const QBitmap &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QRegion &
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRegion
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setMask' is not static");
          RETURN_NULL();
        }
        /// try const QRegion &,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QRegion *
          cpp_arg_0 = static_cast < QRegion * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setMask((const QRegion &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setMask(...) ");
}

/*!
 * method setForegroundRole
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QPalette::ColorRole QPalette::ColorRoles0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setForegroundRole)
{
  ///QPalette::ColorRole QPalette::ColorRoles0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setForegroundRole' is not static");
        RETURN_NULL();
      }
      /// try QPalette::ColorRole QPalette::ColorRoles0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setForegroundRole((QPalette::ColorRole) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setForegroundRole(...) ");
}

/*!
 * method update
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int xs0
 * @param	 int ys1
 * @param	 int ws2
 * @param	 int hs3
 * 
 * overloaded args:
 * @param	const QRect&
 * 
 * overloaded args:
 * @param	const QRegion&
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, update)
{
  ///int xs0, int ys1, int ws2, int hs3
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'update' is not static");
        RETURN_NULL();
      }
      /// try int xs0, int ys1, int ws2, int hs3,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->update((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
    }
  }
  ///const QRect&
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'update' is not static");
          RETURN_NULL();
        }
        /// try const QRect&,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->update((const QRect &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QRegion&
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRegion
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'update' is not static");
          RETURN_NULL();
        }
        /// try const QRegion&,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QRegion *
          cpp_arg_0 = static_cast < QRegion * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->update((const QRegion &)*cpp_arg_0));
      }
#endif

    }
  }
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'update' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->update());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::update(...) ");
}

/*!
 * method adjustSize
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, adjustSize)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'adjustSize' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->adjustSize());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::adjustSize(...) ");
}

/*!
 * method toolTip
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QWidget, toolTip)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toolTip' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QString *
        return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->toolTip());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::toolTip(...) ");
}

/*!
 * method wheelEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWheelEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method setCursor
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QCursor &s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setCursor)
{
  ///const QCursor &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QCursor
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setCursor' is not static");
          RETURN_NULL();
        }
        /// try const QCursor &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QCursor *
          cpp_arg_0 = static_cast < QCursor * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setCursor((const QCursor &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setCursor(...) ");
}

/*!
 * method setMinimumWidth
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int minws0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setMinimumWidth)
{
  ///int minws0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setMinimumWidth' is not static");
        RETURN_NULL();
      }
      /// try int minws0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setMinimumWidth((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setMinimumWidth(...) ");
}

/*!
 * method isEnabledToTLW
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, isEnabledToTLW)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isEnabledToTLW' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isEnabledToTLW());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::isEnabledToTLW(...) ");
}

/*!
 * method setWindowRole
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setWindowRole)
{
  ///const QString &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setWindowRole' is not static");
          RETURN_NULL();
        }
        /// try const QString &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QString *
          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setWindowRole((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setWindowRole(...) ");
}

/*!
 * method setPalette
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPalette &s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setPalette)
{
  ///const QPalette &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPalette
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setPalette' is not static");
          RETURN_NULL();
        }
        /// try const QPalette &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QPalette *
          cpp_arg_0 = static_cast < QPalette * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setPalette((const QPalette &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setPalette(...) ");
}

/*!
 * method closeEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QCloseEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method resizeEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QResizeEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method acceptDrops
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, acceptDrops)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'acceptDrops' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->acceptDrops());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::acceptDrops(...) ");
}

/*!
 * method focusNextChild
 * 
 * @param: -
 * @param: -
 * 
 * @access	protected
 * @return	bool
 * @flags	
 */

/*!
 * method setShortcutEnabled
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ids0
 * @param	 bool enable = trues1
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setShortcutEnabled)
{
  ///int ids0, bool enable = trues1
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setShortcutEnabled' is not static");
        RETURN_NULL();
      }
      /// try int ids0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setShortcutEnabled((int)Z_LVAL_P(arg_0)));
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setShortcutEnabled' is not static");
        RETURN_NULL();
      }
      /// try int ids0, bool enable = trues1,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setShortcutEnabled((int)Z_LVAL_P(arg_0), (bool) Z_LVAL_P(arg_1)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setShortcutEnabled(...) ");
}

/*!
 * method geometry
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const QRect &
 * @flags	c
 */

ZEND_METHOD(QWidget, geometry)
{
  ///
#ifdef PHP_QT_QRect             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'geometry' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = &const_cast < QRect & >(selfpointer->geometry());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::geometry(...) ");
}

/*!
 * method focusNextPrevChild
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool nexts0
 * 
 * @access	protected
 * @return	bool
 * @flags	v
 */

/*!
 * method windowActivationChange
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method setShown
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool showns0
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QWidget, setShown)
{
  ///bool showns0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setShown' is not static");
        RETURN_NULL();
      }
      /// try bool showns0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setShown((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setShown(...) ");
}

/*!
 * method accessibleDescription
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QWidget, accessibleDescription)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'accessibleDescription' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QString *
        return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->accessibleDescription());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::accessibleDescription(...) ");
}

/*!
 * method setMaximumSize
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QSize &s0
 * 
 * overloaded args:
 * @param	int maxw
 * @param	 int maxh
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setMaximumSize)
{
  ///const QSize &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QSize
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setMaximumSize' is not static");
          RETURN_NULL();
        }
        /// try const QSize &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QSize *
          cpp_arg_0 = static_cast < QSize * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setMaximumSize((const QSize &)*cpp_arg_0));
      }
#endif

    }
  }
  ///int maxw, int maxh
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setMaximumSize' is not static");
        RETURN_NULL();
      }
      /// try int maxw, int maxh,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setMaximumSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setMaximumSize(...) ");
}

/*!
 * method setContentsMargins
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int lefts0
 * @param	 int tops1
 * @param	 int rights2
 * @param	 int bottoms3
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setContentsMargins)
{
  ///int lefts0, int tops1, int rights2, int bottoms3
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setContentsMargins' is not static");
        RETURN_NULL();
      }
      /// try int lefts0, int tops1, int rights2, int bottoms3,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setContentsMargins((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setContentsMargins(...) ");
}

/*!
 * method backgroundRole
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QPalette::ColorRole
 * @flags	c
 */

ZEND_METHOD(QWidget, backgroundRole)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'backgroundRole' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->backgroundRole());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::backgroundRole(...) ");
}

/*!
 * method mapFromParent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPoint &s0
 * 
 * @access	public
 * @return	QPoint
 * @flags	c
 */

ZEND_METHOD(QWidget, mapFromParent)
{
  ///const QPoint &s0
#ifdef PHP_QT_QPoint            // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'mapFromParent' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
        zend_class_entry *
          ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry
          le;
        QPoint *
          return_object = new QPoint;

        *return_object = static_cast < QPoint > (selfpointer->mapFromParent((const QPoint &)*cpp_arg_0));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::mapFromParent(...) ");
}

/*!
 * method updateGeometry
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, updateGeometry)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'updateGeometry' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->updateGeometry());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::updateGeometry(...) ");
}

/*!
 * method setAttribute
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::WidgetAttribute Qt::WidgetAttributes0
 * @param	 bool on = trues1
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setAttribute)
{
  ///Qt::WidgetAttribute Qt::WidgetAttributes0, bool on = trues1
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setAttribute' is not static");
        RETURN_NULL();
      }
      /// try Qt::WidgetAttribute Qt::WidgetAttributes0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setAttribute((Qt::WidgetAttribute) Z_LVAL_P(arg_0)));
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setAttribute' is not static");
        RETURN_NULL();
      }
      /// try Qt::WidgetAttribute Qt::WidgetAttributes0, bool on = trues1,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setAttribute((Qt::WidgetAttribute) Z_LVAL_P(arg_0), (bool) Z_LVAL_P(arg_1)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setAttribute(...) ");
}

/*!
 * method windowType
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Qt::WindowType
 * @flags	c
 */

ZEND_METHOD(QWidget, windowType)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'windowType' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->windowType());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::windowType(...) ");
}

/*!
 * method paintEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QPaintEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method mouseDoubleClickEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QMouseEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method focusWidget
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QWidget *
 * @flags	c
 */

ZEND_METHOD(QWidget, focusWidget)
{
  ///
#ifdef PHP_QT_QWidget           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'focusWidget' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = static_cast < QWidget * >(selfpointer->focusWidget());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::focusWidget(...) ");
}

/*!
 * method changeEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method ensurePolished
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	c
 */

ZEND_METHOD(QWidget, ensurePolished)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'ensurePolished' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->ensurePolished());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::ensurePolished(...) ");
}

/*!
 * method foregroundRole
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QPalette::ColorRole
 * @flags	c
 */

ZEND_METHOD(QWidget, foregroundRole)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'foregroundRole' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->foregroundRole());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::foregroundRole(...) ");
}

/*!
 * method setEnabled
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QWidget, setEnabled)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setEnabled' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setEnabled((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setEnabled(...) ");
}

/*!
 * method windowIconText
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QWidget, windowIconText)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'windowIconText' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QString *
        return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->windowIconText());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::windowIconText(...) ");
}

/*!
 * method updateMicroFocus
 * 
 * @param: -
 * @param: -
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method metric
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	PaintDeviceMetric PaintDeviceMetrics0
 * 
 * @access	protected
 * @return	int
 * @flags	c
 */

/*!
 * method paletteChange
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPalette &s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method winId
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	WId
 * @flags	c
 */

ZEND_METHOD(QWidget, winId)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type WId");
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::winId(...) ");
}

/*!
 * method close
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	bool
 * @flags	l
 */

ZEND_METHOD(QWidget, close)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'close' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->close());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::close(...) ");
}

/*!
 * method childAt
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int xs0
 * @param	 int ys1
 * 
 * overloaded args:
 * @param	const QPoint &p
 * 
 * @access	public
 * @return	QWidget *
 * @flags	c
 */

ZEND_METHOD(QWidget, childAt)
{
  ///int xs0, int ys1
#ifdef PHP_QT_QWidget           // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'childAt' is not static");
        RETURN_NULL();
      }
      /// try int xs0, int ys1,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = static_cast < QWidget * >(selfpointer->childAt((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///const QPoint &p
#ifdef PHP_QT_QWidget           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'childAt' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &p,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
        zend_class_entry *
          ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry
          le;

        le.ptr = static_cast < QWidget * >(selfpointer->childAt((const QPoint &)*cpp_arg_0));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::childAt(...) ");
}

/*!
 * method setFixedWidth
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ws0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setFixedWidth)
{
  ///int ws0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setFixedWidth' is not static");
        RETURN_NULL();
      }
      /// try int ws0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setFixedWidth((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setFixedWidth(...) ");
}

/*!
 * method windowRole
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QWidget, windowRole)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'windowRole' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QString *
        return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->windowRole());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::windowRole(...) ");
}

/*!
 * method setFont
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QFont &s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setFont)
{
  ///const QFont &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QFont
      if (inherits(Z_OBJCE_P(arg_0), 24)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setFont' is not static");
          RETURN_NULL();
        }
        /// try const QFont &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QFont *
          cpp_arg_0 = static_cast < QFont * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setFont((const QFont &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setFont(...) ");
}

/*!
 * method hasMouseTracking
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, hasMouseTracking)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'hasMouseTracking' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->hasMouseTracking());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::hasMouseTracking(...) ");
}

/*!
 * method childrenRegion
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QRegion
 * @flags	c
 */

ZEND_METHOD(QWidget, childrenRegion)
{
  ///
#ifdef PHP_QT_QRegion           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'childrenRegion' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QRegion *
        return_object = new QRegion;

      *return_object = static_cast < QRegion > (selfpointer->childrenRegion());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::childrenRegion(...) ");
}

/*!
 * method QWidget
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget * parent = 0s0
 * @param	 Qt::WFlags f = 0s1
 * 
 * overloaded args:
 * @param	QWidgetPrivate &d
 * @param	 QWidget* parent
 * @param	 Qt::WFlags f
 * 
 * overloaded args:
 * @param	const QWidget &
 * 
 * @access	public
 * @return	
 * @flags	t
 */

ZEND_METHOD(QWidget, __construct)
{
  ///QWidget * parent = 0s0, Qt::WFlags f = 0s1
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget_php_qt *
        selfpointer = new QWidget_php_qt(getThis());

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try QWidget * parent = 0s0,
      QWidget *
        cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
      QWidget_php_qt *
        selfpointer = new QWidget_php_qt(getThis(), (QWidget *) cpp_arg_0);

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try QWidget * parent = 0s0, Qt::WFlags f = 0s1,
      QWidget *
        cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
      QWidget_php_qt *
        selfpointer = new QWidget_php_qt(getThis(), (QWidget *) cpp_arg_0, (Qt::WFlags) Z_LVAL_P(arg_1));

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  ///QWidgetPrivate &d, QWidget* parent, Qt::WFlags f
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QWidgetPrivate
#ifdef PHP_QT_QWidget
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 71)) {
/// overloaded method is protected, skipped.
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try QWidgetPrivate &d, QWidget* parent, Qt::WFlags f,
        QWidgetPrivate *
          cpp_arg_0 = static_cast < QWidgetPrivate * >(php_qt_fetch(arg_0));
        QWidget *
          cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
        QWidget_php_qt *
          selfpointer = new QWidget_php_qt(getThis(), (QWidgetPrivate &) * cpp_arg_0, (QWidget *) cpp_arg_1, (Qt::WFlags) Z_LVAL_P(arg_2));

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

#endif

    }
  }
  ///const QWidget &
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QWidget
      if (inherits(Z_OBJCE_P(arg_0), 71)) {
/// method is private, skip
        php_error(E_ERROR, "QWidget::__construct(...) cannot be called with 'const QWidget &,'.");
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::QWidget(...) ");
}

/*!
 * method setInputContext
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QInputContext *s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setInputContext)
{
  ///QInputContext *s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QInputContext
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setInputContext' is not static");
          RETURN_NULL();
        }
        /// try QInputContext *s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QInputContext *
          cpp_arg_0 = static_cast < QInputContext * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setInputContext((QInputContext *) cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setInputContext(...) ");
}

/*!
 * method unsetLayoutDirection
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, unsetLayoutDirection)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'unsetLayoutDirection' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->unsetLayoutDirection());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::unsetLayoutDirection(...) ");
}

/*!
 * method sizeIncrement
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QSize
 * @flags	c
 */

ZEND_METHOD(QWidget, sizeIncrement)
{
  ///
#ifdef PHP_QT_QSize             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'sizeIncrement' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QSize *
        return_object = new QSize;

      *return_object = static_cast < QSize > (selfpointer->sizeIncrement());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::sizeIncrement(...) ");
}

/*!
 * method focusInEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QFocusEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method setVisible
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool visibles0
 * 
 * @access	public_slots
 * @return	void
 * @flags	vl
 */

/*!
 * method mouseGrabber
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QWidget *
 * @flags	s
 */

ZEND_METHOD(QWidget, mouseGrabber)
{
  ///
#ifdef PHP_QT_QWidget           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      if (getThis() == NULL) {
        le.ptr = static_cast < QWidget * >(QWidget::mouseGrabber());
      } else {
        le.ptr = static_cast < QWidget * >(selfpointer->mouseGrabber());
      }
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::mouseGrabber(...) ");
}

/*!
 * method addActions
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QList<QAction *> actionss0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, addActions)
{
  ///QList<QAction *> actionss0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QList
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'addActions' is not static");
          RETURN_NULL();
        }
        /// try QList<QAction *> actionss0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QList < QAction * cpp_arg_0 = static_cast < QList < QAction * >(php_qt_fetch(arg_0));
        RETURN_VOID(selfpointer->addActions((QList < QAction *) cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::addActions(...) ");
}

/*!
 * method trUtf8
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 const char *s0
 * @param	 const char * = 0 s1
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QWidget, trUtf8)
{
  /// const char *s0, const char * = 0 s1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      /// try  const char *s0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QString *
        return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QWidget::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
      /// try  const char *s0, const char * = 0 s1,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QString *
        return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QWidget::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::trUtf8(...) ");
}

/*!
 * method resetInputContext
 * 
 * @param: -
 * @param: -
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method isFullScreen
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, isFullScreen)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isFullScreen' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isFullScreen());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::isFullScreen(...) ");
}

/*!
 * method mapToGlobal
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPoint &s0
 * 
 * @access	public
 * @return	QPoint
 * @flags	c
 */

ZEND_METHOD(QWidget, mapToGlobal)
{
  ///const QPoint &s0
#ifdef PHP_QT_QPoint            // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'mapToGlobal' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
        zend_class_entry *
          ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry
          le;
        QPoint *
          return_object = new QPoint;

        *return_object = static_cast < QPoint > (selfpointer->mapToGlobal((const QPoint &)*cpp_arg_0));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::mapToGlobal(...) ");
}

/*!
 * method move
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int xs0
 * @param	 int ys1
 * 
 * overloaded args:
 * @param	const QPoint &
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, move)
{
  ///int xs0, int ys1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'move' is not static");
        RETURN_NULL();
      }
      /// try int xs0, int ys1,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->move((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
    }
  }
  ///const QPoint &
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'move' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->move((const QPoint &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::move(...) ");
}

/*!
 * method mapFromGlobal
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPoint &s0
 * 
 * @access	public
 * @return	QPoint
 * @flags	c
 */

ZEND_METHOD(QWidget, mapFromGlobal)
{
  ///const QPoint &s0
#ifdef PHP_QT_QPoint            // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'mapFromGlobal' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
        zend_class_entry *
          ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry
          le;
        QPoint *
          return_object = new QPoint;

        *return_object = static_cast < QPoint > (selfpointer->mapFromGlobal((const QPoint &)*cpp_arg_0));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::mapFromGlobal(...) ");
}

/*!
 * method qt_invoke
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 int  ints0
 * @param	 QUObject * s1
 * 
 * @access	public
 * @return	bool
 * @flags	v
 */

/*!
 * method setUpdatesEnabled
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool enables0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setUpdatesEnabled)
{
  ///bool enables0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setUpdatesEnabled' is not static");
        RETURN_NULL();
      }
      /// try bool enables0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setUpdatesEnabled((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setUpdatesEnabled(...) ");
}

/*!
 * method setSizeIncrement
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QSize &s0
 * 
 * overloaded args:
 * @param	int w
 * @param	 int h
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setSizeIncrement)
{
  ///const QSize &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QSize
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setSizeIncrement' is not static");
          RETURN_NULL();
        }
        /// try const QSize &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QSize *
          cpp_arg_0 = static_cast < QSize * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setSizeIncrement((const QSize &)*cpp_arg_0));
      }
#endif

    }
  }
  ///int w, int h
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setSizeIncrement' is not static");
        RETURN_NULL();
      }
      /// try int w, int h,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setSizeIncrement((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setSizeIncrement(...) ");
}

/*!
 * method grabMouse
 * 
 * @param: -
 * @param: -
 * 
 * overloaded args:
 * @param	const QCursor &
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, grabMouse)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'grabMouse' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->grabMouse());
    }
  }
  ///const QCursor &
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QCursor
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'grabMouse' is not static");
          RETURN_NULL();
        }
        /// try const QCursor &,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QCursor *
          cpp_arg_0 = static_cast < QCursor * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->grabMouse((const QCursor &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::grabMouse(...) ");
}

/*!
 * method layout
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QLayout *
 * @flags	c
 */

ZEND_METHOD(QWidget, layout)
{
  ///
#ifdef PHP_QT_QLayout           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'layout' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = static_cast < QLayout * >(selfpointer->layout());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::layout(...) ");
}

/*!
 * method actionEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QActionEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method mapFrom
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget *s0
 * @param	 const QPoint  &s1
 * 
 * @access	public
 * @return	QPoint
 * @flags	c
 */

ZEND_METHOD(QWidget, mapFrom)
{
  ///QWidget *s0, const QPoint  &s1
#ifdef PHP_QT_QPoint            // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QWidget
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 71) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'mapFrom' is not static");
          RETURN_NULL();
        }
        /// try QWidget *s0, const QPoint  &s1,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QWidget *
          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
        QPoint *
          cpp_arg_1 = static_cast < QPoint * >(php_qt_fetch(arg_1));
        zend_class_entry *
          ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry
          le;
        QPoint *
          return_object = new QPoint;

        *return_object = static_cast < QPoint > (selfpointer->mapFrom((QWidget *) cpp_arg_0, (const QPoint &)*cpp_arg_1));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::mapFrom(...) ");
}

/*!
 * method windowFlags
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Qt::WindowFlags
 * @flags	c
 */

ZEND_METHOD(QWidget, windowFlags)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'windowFlags' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->windowFlags());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::windowFlags(...) ");
}

/*!
 * method isModal
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, isModal)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isModal' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isModal());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::isModal(...) ");
}

/*!
 * method unsetCursor
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, unsetCursor)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'unsetCursor' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->unsetCursor());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::unsetCursor(...) ");
}

/*!
 * method setLayoutDirection
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::LayoutDirection directions0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setLayoutDirection)
{
  ///Qt::LayoutDirection directions0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setLayoutDirection' is not static");
        RETURN_NULL();
      }
      /// try Qt::LayoutDirection directions0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setLayoutDirection((Qt::LayoutDirection) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setLayoutDirection(...) ");
}

/*!
 * method tabletEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QTabletEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method maximumHeight
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QWidget, maximumHeight)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'maximumHeight' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->maximumHeight());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::maximumHeight(...) ");
}

/*!
 * method frameGeometry
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QRect
 * @flags	c
 */

ZEND_METHOD(QWidget, frameGeometry)
{
  ///
#ifdef PHP_QT_QRect             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'frameGeometry' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QRect *
        return_object = new QRect;

      *return_object = static_cast < QRect > (selfpointer->frameGeometry());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::frameGeometry(...) ");
}

/*!
 * method enterEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method customContextMenuRequested
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPoint &poss0
 * 
 * @access	signals
 * @return	void
 * @flags	n
 */

/*!
 * method handle
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Qt::HANDLE
 * @flags	c
 */

ZEND_METHOD(QWidget, handle)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'handle' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->handle());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::handle(...) ");
}

/*!
 * method lower
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QWidget, lower)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'lower' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->lower());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::lower(...) ");
}

/*!
 * method setWindowTitle
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setWindowTitle)
{
  ///const QString &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setWindowTitle' is not static");
          RETURN_NULL();
        }
        /// try const QString &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QString *
          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setWindowTitle((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setWindowTitle(...) ");
}

/*!
 * method setWindowState
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::WindowStates states0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setWindowState)
{
  ///Qt::WindowStates states0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setWindowState' is not static");
        RETURN_NULL();
      }
      /// try Qt::WindowStates states0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setWindowState((Qt::WindowStates) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setWindowState(...) ");
}

/*!
 * method scroll
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int dxs0
 * @param	 int dys1
 * 
 * overloaded args:
 * @param	int dx
 * @param	 int dy
 * @param	 const QRect&
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, scroll)
{
  ///int dxs0, int dys1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'scroll' is not static");
        RETURN_NULL();
      }
      /// try int dxs0, int dys1,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->scroll((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
    }
  }
  ///int dx, int dy, const QRect&
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'scroll' is not static");
          RETURN_NULL();
        }
        /// try int dx, int dy, const QRect&,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_2 = static_cast < QRect * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->scroll((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QRect &)*cpp_arg_2));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::scroll(...) ");
}

/*!
 * method sizePolicy
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QSizePolicy
 * @flags	c
 */

ZEND_METHOD(QWidget, sizePolicy)
{
  ///
#ifdef PHP_QT_QSizePolicy       // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'sizePolicy' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QSizePolicy *
        return_object = new QSizePolicy;

      *return_object = static_cast < QSizePolicy > (selfpointer->sizePolicy());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::sizePolicy(...) ");
}

/*!
 * method width
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QWidget, width)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'width' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->width());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::width(...) ");
}

/*!
 * method actions
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QList<QAction*>
 * @flags	c
 */

ZEND_METHOD(QWidget, actions)
{
  ///
#ifdef PHP_QT_QList             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'actions' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = static_cast < QList < QAction > *>(selfpointer->actions());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::actions(...) ");
}

/*!
 * method setHidden
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool hiddens0
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QWidget, setHidden)
{
  ///bool hiddens0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setHidden' is not static");
        RETURN_NULL();
      }
      /// try bool hiddens0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setHidden((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setHidden(...) ");
}

/*!
 * method find
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	WId WIds0
 * 
 * @access	public
 * @return	QWidget *
 * @flags	s
 */

ZEND_METHOD(QWidget, find)
{
// notice: unknown argument WId WIds0, skipped
  php_error(E_ERROR, "could not parse argument in QWidget::find(...) ");
}

/*!
 * method staticMetaObject
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QMetaObject*
 * @flags	s
 */

ZEND_METHOD(QWidget, staticMetaObject)
{
  ///
#ifdef PHP_QT_QMetaObject       // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      if (getThis() == NULL) {
        le.ptr = static_cast < QMetaObject * >(QWidget::staticMetaObject());
      } else {
        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
      }
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::staticMetaObject(...) ");
}

/*!
 * method mouseReleaseEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QMouseEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method size
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QSize
 * @flags	c
 */

ZEND_METHOD(QWidget, size)
{
  ///
#ifdef PHP_QT_QSize             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'size' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QSize *
        return_object = new QSize;

      *return_object = static_cast < QSize > (selfpointer->size());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::size(...) ");
}

/*!
 * method activateWindow
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, activateWindow)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'activateWindow' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->activateWindow());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::activateWindow(...) ");
}

/*!
 * method hideEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QHideEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method setToolTip
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setToolTip)
{
  ///const QString &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setToolTip' is not static");
          RETURN_NULL();
        }
        /// try const QString &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QString *
          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setToolTip((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setToolTip(...) ");
}

/*!
 * method inputMethodQuery
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::InputMethodQuery Qt::InputMethodQuerys0
 * 
 * @access	public
 * @return	QVariant
 * @flags	cv
 */

/*!
 * method setParent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget *parents0
 * 
 * overloaded args:
 * @param	QWidget *parent
 * @param	 Qt::WFlags f
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setParent)
{
  ///QWidget *parents0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QWidget
      if (inherits(Z_OBJCE_P(arg_0), 71)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setParent' is not static");
          RETURN_NULL();
        }
        /// try QWidget *parents0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QWidget *
          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setParent((QWidget *) cpp_arg_0));
      }
#endif

    }
  }
  ///QWidget *parent, Qt::WFlags f
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QWidget
      if (inherits(Z_OBJCE_P(arg_0), 71)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setParent' is not static");
          RETURN_NULL();
        }
        /// try QWidget *parent, Qt::WFlags f,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QWidget *
          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setParent((QWidget *) cpp_arg_0, (Qt::WFlags) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setParent(...) ");
}

/*!
 * method isWindowModified
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, isWindowModified)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isWindowModified' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isWindowModified());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::isWindowModified(...) ");
}

/*!
 * method testAttribute
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::WidgetAttribute Qt::WidgetAttributes0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, testAttribute)
{
  ///Qt::WidgetAttribute Qt::WidgetAttributes0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'testAttribute' is not static");
        RETURN_NULL();
      }
      /// try Qt::WidgetAttribute Qt::WidgetAttributes0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->testAttribute((Qt::WidgetAttribute) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::testAttribute(...) ");
}

/*!
 * method minimumSizeHint
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QSize
 * @flags	cv
 */

/*!
 * method heightForWidth
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ints0
 * 
 * @access	public
 * @return	int
 * @flags	cv
 */

/*!
 * method pos
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QPoint
 * @flags	c
 */

ZEND_METHOD(QWidget, pos)
{
  ///
#ifdef PHP_QT_QPoint            // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'pos' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QPoint *
        return_object = new QPoint;

      *return_object = static_cast < QPoint > (selfpointer->pos());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::pos(...) ");
}

/*!
 * method isWindow
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, isWindow)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isWindow' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isWindow());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::isWindow(...) ");
}

/*!
 * method create
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	WId = 0s0
 * @param	 bool initializeWindow = trues1
 * @param	 bool destroyOldWindow = trues2
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method setFocusPolicy
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::FocusPolicy policys0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setFocusPolicy)
{
  ///Qt::FocusPolicy policys0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setFocusPolicy' is not static");
        RETURN_NULL();
      }
      /// try Qt::FocusPolicy policys0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setFocusPolicy((Qt::FocusPolicy) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setFocusPolicy(...) ");
}

/*!
 * method getContentsMargins
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int *lefts0
 * @param	 int *tops1
 * @param	 int *rights2
 * @param	 int *bottoms3
 * 
 * @access	public
 * @return	void
 * @flags	c
 */

ZEND_METHOD(QWidget, getContentsMargins)
{
  ///int *lefts0, int *tops1, int *rights2, int *bottoms3
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'getContentsMargins' is not static");
        RETURN_NULL();
      }
      /// try int *lefts0, int *tops1, int *rights2, int *bottoms3,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->getContentsMargins((int *)&Z_LVAL_P(arg_0), (int *)&Z_LVAL_P(arg_1), (int *)&Z_LVAL_P(arg_2), (int *)&Z_LVAL_P(arg_3)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::getContentsMargins(...) ");
}

/*!
 * method dropEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QDropEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method windowTitle
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QWidget, windowTitle)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'windowTitle' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QString *
        return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->windowTitle());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::windowTitle(...) ");
}

/*!
 * method keyReleaseEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QKeyEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method style
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QStyle *
 * @flags	c
 */

ZEND_METHOD(QWidget, style)
{
  ///
#ifdef PHP_QT_QStyle            // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'style' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = static_cast < QStyle * >(selfpointer->style());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::style(...) ");
}

/*!
 * method windowState
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Qt::WindowStates
 * @flags	c
 */

ZEND_METHOD(QWidget, windowState)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'windowState' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->windowState());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::windowState(...) ");
}

/*!
 * method frameSize
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QSize
 * @flags	c
 */

ZEND_METHOD(QWidget, frameSize)
{
  ///
#ifdef PHP_QT_QSize             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'frameSize' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QSize *
        return_object = new QSize;

      *return_object = static_cast < QSize > (selfpointer->frameSize());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::frameSize(...) ");
}

/*!
 * method setAccessibleName
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &names0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setAccessibleName)
{
  ///const QString &names0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setAccessibleName' is not static");
          RETURN_NULL();
        }
        /// try const QString &names0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QString *
          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setAccessibleName((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setAccessibleName(...) ");
}

/*!
 * method setAcceptDrops
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool ons0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setAcceptDrops)
{
  ///bool ons0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setAcceptDrops' is not static");
        RETURN_NULL();
      }
      /// try bool ons0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setAcceptDrops((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setAcceptDrops(...) ");
}

/*!
 * method setSizePolicy
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QSizePolicy QSizePolicys0
 * 
 * overloaded args:
 * @param	QSizePolicy::Policy horizontal
 * @param	 QSizePolicy::Policy vertical
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setSizePolicy)
{
  ///QSizePolicy QSizePolicys0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QSizePolicy
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setSizePolicy' is not static");
          RETURN_NULL();
        }
        /// try QSizePolicy QSizePolicys0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QSizePolicy *
          cpp_arg_0 = static_cast < QSizePolicy * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setSizePolicy((QSizePolicy) * cpp_arg_0));
      }
#endif

    }
  }
  ///QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setSizePolicy' is not static");
        RETURN_NULL();
      }
      /// try QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setSizePolicy((QSizePolicy::Policy) Z_LVAL_P(arg_0), (QSizePolicy::Policy) Z_LVAL_P(arg_1)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setSizePolicy(...) ");
}

/*!
 * method languageChange
 * 
 * @param: -
 * @param: -
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method removeAction
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QAction *actions0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, removeAction)
{
  ///QAction *actions0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QAction
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'removeAction' is not static");
          RETURN_NULL();
        }
        /// try QAction *actions0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QAction *
          cpp_arg_0 = static_cast < QAction * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->removeAction((QAction *) cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::removeAction(...) ");
}

/*!
 * method hasFocus
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, hasFocus)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'hasFocus' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->hasFocus());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::hasFocus(...) ");
}

/*!
 * method contextMenuEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QContextMenuEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method showFullScreen
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QWidget, showFullScreen)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'showFullScreen' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->showFullScreen());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::showFullScreen(...) ");
}

/*!
 * method qt_property
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 int  ints0
 * @param	 int  ints1
 * @param	 QVariant * s2
 * 
 * @access	public
 * @return	bool
 * @flags	v
 */

/*!
 * method setMouseTracking
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool enables0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setMouseTracking)
{
  ///bool enables0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setMouseTracking' is not static");
        RETURN_NULL();
      }
      /// try bool enables0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setMouseTracking((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setMouseTracking(...) ");
}

/*!
 * method clearMask
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, clearMask)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'clearMask' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->clearMask());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::clearMask(...) ");
}

/*!
 * method moveEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QMoveEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method inputMethodEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QInputMethodEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method showMaximized
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QWidget, showMaximized)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'showMaximized' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->showMaximized());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::showMaximized(...) ");
}

/*!
 * method devType
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QWidget, devType)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'devType' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->devType());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::devType(...) ");
}

/*!
 * method font
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const QFont &
 * @flags	c
 */

ZEND_METHOD(QWidget, font)
{
  ///
#ifdef PHP_QT_QFont             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'font' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = &const_cast < QFont & >(selfpointer->font());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::font(...) ");
}

/*!
 * method stackUnder
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget *s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, stackUnder)
{
  ///QWidget *s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QWidget
      if (inherits(Z_OBJCE_P(arg_0), 71)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'stackUnder' is not static");
          RETURN_NULL();
        }
        /// try QWidget *s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QWidget *
          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->stackUnder((QWidget *) cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::stackUnder(...) ");
}

/*!
 * method setMinimumSize
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QSize &s0
 * 
 * overloaded args:
 * @param	int minw
 * @param	 int minh
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setMinimumSize)
{
  ///const QSize &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QSize
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setMinimumSize' is not static");
          RETURN_NULL();
        }
        /// try const QSize &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QSize *
          cpp_arg_0 = static_cast < QSize * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setMinimumSize((const QSize &)*cpp_arg_0));
      }
#endif

    }
  }
  ///int minw, int minh
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setMinimumSize' is not static");
        RETURN_NULL();
      }
      /// try int minw, int minh,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setMinimumSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setMinimumSize(...) ");
}

/*!
 * method setDisabled
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QWidget, setDisabled)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setDisabled' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setDisabled((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setDisabled(...) ");
}

/*!
 * method leaveEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method dragEnterEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QDragEnterEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method enabledChange
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method show
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QWidget, show)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'show' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->show());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::show(...) ");
}

/*!
 * method underMouse
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, underMouse)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'underMouse' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->underMouse());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::underMouse(...) ");
}

/*!
 * method setWindowIcon
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QIcon &icons0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setWindowIcon)
{
  ///const QIcon &icons0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QIcon
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setWindowIcon' is not static");
          RETURN_NULL();
        }
        /// try const QIcon &icons0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QIcon *
          cpp_arg_0 = static_cast < QIcon * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setWindowIcon((const QIcon &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setWindowIcon(...) ");
}

/*!
 * method focusOutEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QFocusEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method grabKeyboard
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, grabKeyboard)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'grabKeyboard' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->grabKeyboard());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::grabKeyboard(...) ");
}

/*!
 * method raise
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QWidget, raise)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'raise' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->raise());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::raise(...) ");
}

/*!
 * method event
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QEvent *s0
 * 
 * @access	protected
 * @return	bool
 * @flags	
 */

/*!
 * method setWhatsThis
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setWhatsThis)
{
  ///const QString &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setWhatsThis' is not static");
          RETURN_NULL();
        }
        /// try const QString &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QString *
          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setWhatsThis((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setWhatsThis(...) ");
}

/*!
 * method setGeometry
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int xs0
 * @param	 int ys1
 * @param	 int ws2
 * @param	 int hs3
 * 
 * overloaded args:
 * @param	const QRect &
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setGeometry)
{
  ///int xs0, int ys1, int ws2, int hs3
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setGeometry' is not static");
        RETURN_NULL();
      }
      /// try int xs0, int ys1, int ws2, int hs3,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setGeometry((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
    }
  }
  ///const QRect &
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setGeometry' is not static");
          RETURN_NULL();
        }
        /// try const QRect &,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setGeometry((const QRect &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setGeometry(...) ");
}

/*!
 * method contextMenuPolicy
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Qt::ContextMenuPolicy
 * @flags	c
 */

ZEND_METHOD(QWidget, contextMenuPolicy)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'contextMenuPolicy' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->contextMenuPolicy());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::contextMenuPolicy(...) ");
}

/*!
 * method resize
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ws0
 * @param	 int hs1
 * 
 * overloaded args:
 * @param	const QSize &
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, resize)
{
  ///int ws0, int hs1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'resize' is not static");
        RETURN_NULL();
      }
      /// try int ws0, int hs1,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->resize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
    }
  }
  ///const QSize &
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QSize
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'resize' is not static");
          RETURN_NULL();
        }
        /// try const QSize &,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QSize *
          cpp_arg_0 = static_cast < QSize * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->resize((const QSize &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::resize(...) ");
}

/*!
 * method isLeftToRight
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, isLeftToRight)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isLeftToRight' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isLeftToRight());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::isLeftToRight(...) ");
}

/*!
 * method showEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QShowEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method setWindowFlags
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::WindowFlags types0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setWindowFlags)
{
  ///Qt::WindowFlags types0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setWindowFlags' is not static");
        RETURN_NULL();
      }
      /// try Qt::WindowFlags types0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setWindowFlags((Qt::WindowFlags) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setWindowFlags(...) ");
}

/*!
 * method baseSize
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QSize
 * @flags	c
 */

ZEND_METHOD(QWidget, baseSize)
{
  ///
#ifdef PHP_QT_QSize             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'baseSize' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QSize *
        return_object = new QSize;

      *return_object = static_cast < QSize > (selfpointer->baseSize());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::baseSize(...) ");
}

/*!
 * method setLayout
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QLayout *s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setLayout)
{
  ///QLayout *s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QLayout
      if (inherits(Z_OBJCE_P(arg_0), 41)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setLayout' is not static");
          RETURN_NULL();
        }
        /// try QLayout *s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QLayout *
          cpp_arg_0 = static_cast < QLayout * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setLayout((QLayout *) cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setLayout(...) ");
}

/*!
 * method setMaximumHeight
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int maxhs0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setMaximumHeight)
{
  ///int maxhs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setMaximumHeight' is not static");
        RETURN_NULL();
      }
      /// try int maxhs0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setMaximumHeight((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setMaximumHeight(...) ");
}

/*!
 * method showNormal
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QWidget, showNormal)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'showNormal' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->showNormal());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::showNormal(...) ");
}

/*!
 * method insertAction
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QAction *befores0
 * @param	 QAction *actions1
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, insertAction)
{
  ///QAction *befores0, QAction *actions1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QAction
#ifdef PHP_QT_QAction
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'insertAction' is not static");
          RETURN_NULL();
        }
        /// try QAction *befores0, QAction *actions1,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QAction *
          cpp_arg_0 = static_cast < QAction * >(php_qt_fetch(arg_0));
        QAction *
          cpp_arg_1 = static_cast < QAction * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->insertAction((QAction *) cpp_arg_0, (QAction *) cpp_arg_1));
      }
#endif

#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::insertAction(...) ");
}

/*!
 * method window
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QWidget *
 * @flags	c
 */

ZEND_METHOD(QWidget, window)
{
  ///
#ifdef PHP_QT_QWidget           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'window' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = static_cast < QWidget * >(selfpointer->window());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::window(...) ");
}

/*!
 * method paintEngine
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QPaintEngine *
 * @flags	c
 */

ZEND_METHOD(QWidget, paintEngine)
{
  ///
#ifdef PHP_QT_QPaintEngine      // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'paintEngine' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = static_cast < QPaintEngine * >(selfpointer->paintEngine());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::paintEngine(...) ");
}

/*!
 * method minimumHeight
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QWidget, minimumHeight)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'minimumHeight' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->minimumHeight());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::minimumHeight(...) ");
}

/*!
 * method x
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QWidget, x)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'x' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->x());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::x(...) ");
}

/*!
 * method releaseShortcut
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ids0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, releaseShortcut)
{
  ///int ids0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'releaseShortcut' is not static");
        RETURN_NULL();
      }
      /// try int ids0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->releaseShortcut((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::releaseShortcut(...) ");
}

/*!
 * method setStatusTip
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setStatusTip)
{
  ///const QString &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setStatusTip' is not static");
          RETURN_NULL();
        }
        /// try const QString &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QString *
          cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setStatusTip((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setStatusTip(...) ");
}

/*!
 * method mousePressEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QMouseEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method setBaseSize
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QSize &s0
 * 
 * overloaded args:
 * @param	int basew
 * @param	 int baseh
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setBaseSize)
{
  ///const QSize &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QSize
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setBaseSize' is not static");
          RETURN_NULL();
        }
        /// try const QSize &s0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QSize *
          cpp_arg_0 = static_cast < QSize * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setBaseSize((const QSize &)*cpp_arg_0));
      }
#endif

    }
  }
  ///int basew, int baseh
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setBaseSize' is not static");
        RETURN_NULL();
      }
      /// try int basew, int baseh,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setBaseSize((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setBaseSize(...) ");
}

/*!
 * method rect
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QRect
 * @flags	c
 */

ZEND_METHOD(QWidget, rect)
{
  ///
#ifdef PHP_QT_QRect             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'rect' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QRect *
        return_object = new QRect;

      *return_object = static_cast < QRect > (selfpointer->rect());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::rect(...) ");
}

/*!
 * method addAction
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QAction *actions0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, addAction)
{
  ///QAction *actions0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QAction
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'addAction' is not static");
          RETURN_NULL();
        }
        /// try QAction *actions0,
        QWidget *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
        }
        QAction *
          cpp_arg_0 = static_cast < QAction * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->addAction((QAction *) cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::addAction(...) ");
}

/*!
 * method minimumSize
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QSize
 * @flags	c
 */

ZEND_METHOD(QWidget, minimumSize)
{
  ///
#ifdef PHP_QT_QSize             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'minimumSize' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QSize *
        return_object = new QSize;

      *return_object = static_cast < QSize > (selfpointer->minimumSize());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::minimumSize(...) ");
}

/*!
 * method sizeHint
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QSize
 * @flags	cv
 */

/*!
 * method setFocus
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::FocusReason reasons0
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setFocus)
{
  ///Qt::FocusReason reasons0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setFocus' is not static");
        RETURN_NULL();
      }
      /// try Qt::FocusReason reasons0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setFocus((Qt::FocusReason) Z_LVAL_P(arg_0)));
    }
  }
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setFocus' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setFocus());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setFocus(...) ");
}

/*!
 * method destroy
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool destroyWindow = trues0
 * @param	 bool destroySubWindows = trues1
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method dragMoveEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QDragMoveEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method isVisible
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, isVisible)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isVisible' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isVisible());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::isVisible(...) ");
}

/*!
 * method accessibleName
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QWidget, accessibleName)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'accessibleName' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QString *
        return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->accessibleName());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::accessibleName(...) ");
}

/*!
 * method keyPressEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QKeyEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method minimumWidth
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QWidget, minimumWidth)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'minimumWidth' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->minimumWidth());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::minimumWidth(...) ");
}

/*!
 * method isEnabled
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, isEnabled)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isEnabled' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isEnabled());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::isEnabled(...) ");
}

/*!
 * method keyboardGrabber
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QWidget *
 * @flags	s
 */

ZEND_METHOD(QWidget, keyboardGrabber)
{
  ///
#ifdef PHP_QT_QWidget           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      if (getThis() == NULL) {
        le.ptr = static_cast < QWidget * >(QWidget::keyboardGrabber());
      } else {
        le.ptr = static_cast < QWidget * >(selfpointer->keyboardGrabber());
      }
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::keyboardGrabber(...) ");
}

/*!
 * method overrideWindowState
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::WindowStates states0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, overrideWindowState)
{
  ///Qt::WindowStates states0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'overrideWindowState' is not static");
        RETURN_NULL();
      }
      /// try Qt::WindowStates states0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->overrideWindowState((Qt::WindowStates) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::overrideWindowState(...) ");
}

/*!
 * method setMinimumHeight
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int minhs0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QWidget, setMinimumHeight)
{
  ///int minhs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setMinimumHeight' is not static");
        RETURN_NULL();
      }
      /// try int minhs0,
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setMinimumHeight((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::setMinimumHeight(...) ");
}

/*!
 * method testAttribute_helper
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::WidgetAttribute Qt::WidgetAttributes0
 * 
 * @access	private
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, testAttribute_helper)
{
  ///Qt::WidgetAttribute Qt::WidgetAttributes0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
/// method is private, skip
      php_error(E_ERROR, "QWidget::testAttribute_helper(...) cannot be called with 'Qt::WidgetAttribute Qt::WidgetAttributes0,'.");
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::testAttribute_helper(...) ");
}

/*!
 * method isMaximized
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QWidget, isMaximized)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isMaximized' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isMaximized());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::isMaximized(...) ");
}

/*!
 * method parentWidget
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QWidget *
 * @flags	c
 */

ZEND_METHOD(QWidget, parentWidget)
{
  ///
#ifdef PHP_QT_QWidget           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'parentWidget' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = static_cast < QWidget * >(selfpointer->parentWidget());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::parentWidget(...) ");
}

/*!
 * method whatsThis
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QWidget, whatsThis)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'whatsThis' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QString *
        return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->whatsThis());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::whatsThis(...) ");
}

/*!
 * method maximumSize
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QSize
 * @flags	c
 */

ZEND_METHOD(QWidget, maximumSize)
{
  ///
#ifdef PHP_QT_QSize             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'maximumSize' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QSize *
        return_object = new QSize;

      *return_object = static_cast < QSize > (selfpointer->maximumSize());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QWidget::maximumSize(...) ");
}

/*!
 * method showMinimized
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QWidget, showMinimized)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'showMinimized' is not static");
        RETURN_NULL();
      }
      /// try 
      QWidget *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QWidget * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->showMinimized());
    }
  }
  php_error(E_ERROR, "could not parse argument in QWidget::showMinimized(...) ");
}
