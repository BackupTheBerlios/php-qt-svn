/*
 * PHP-Qt - The PHP language bindings for Qt
 *
 * Copyright (C) 2006
 * Thomas Moenicke <tm@ippfp.org>,
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * QFont.cpp - QFont PHP implementation.
 * begin           : Tue Jun  6 22:42:56 2006
 * generated by    : moni using kalyptus 0.9.
 */

#include <iostream>
using namespace std;

#include "../php_qt.h"


#include <QFont>
#include <QStringList>
/// DEBUG:destructor skipped.
#include <QMetaMethod>
class QFont_php_qt:public QFont
{

public:
  QFont_php_qt(zval * zend_ptr);
  QFont_php_qt(zval * zend_ptr, const QString & familys0, int pointSize = -1, int weight = -1, bool italic = false);
    QFont_php_qt(zval * zend_ptr, const QFont & s0, QPaintDevice * pds1);
    QFont_php_qt(zval * zend_ptr, const QFont & s0);


  zval *zend_ptr;
};

QFont_php_qt::QFont_php_qt(zval * zend_ptr):QFont()
{
  this->zend_ptr = zend_ptr;
}
QFont_php_qt::QFont_php_qt(zval * zend_ptr, const QString & familys0, int pointSize, int weight, bool italic):
QFont(familys0, pointSize, weight, italic)
{
  this->zend_ptr = zend_ptr;
}
QFont_php_qt::QFont_php_qt(zval * zend_ptr, const QFont & s0, QPaintDevice * pds1):
QFont(s0, pds1)
{
  this->zend_ptr = zend_ptr;
}
QFont_php_qt::QFont_php_qt(zval * zend_ptr, const QFont & s0):
QFont(s0)
{
  this->zend_ptr = zend_ptr;
}

/*!
 * method stretch
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QFont, stretch)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'stretch' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->stretch());
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::stretch(...) ");
}

/*!
 * method underline
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QFont, underline)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'underline' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->underline());
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::underline(...) ");
}

/*!
 * method fixedPitch
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QFont, fixedPitch)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'fixedPitch' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->fixedPitch());
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::fixedPitch(...) ");
}

/*!
 * method italic
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QFont, italic)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'italic' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->italic());
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::italic(...) ");
}

/*!
 * method pixelSize
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QFont, pixelSize)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'pixelSize' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->pixelSize());
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::pixelSize(...) ");
}

/*!
 * method insertSubstitutions
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * @param	 const QStringList &s1
 * 
 * @access	public
 * @return	void
 * @flags	s
 */

ZEND_METHOD(QFont, insertSubstitutions)
{
  ///const QString &s0, const QStringList &s1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_1 = invokeToQString(arg_1);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QString
#ifdef PHP_QT_QStringList
      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 0)) {
        /// try const QString &s0, const QStringList &s1,
        QFont *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QStringList *cpp_arg_1 = static_cast < QStringList * >(php_qt_fetch(arg_1));

        if (getThis() == NULL) {
          RETURN_VOID(QFont::insertSubstitutions((const QString &)*cpp_arg_0, (const QStringList &)*cpp_arg_1));
        } else {
          RETURN_VOID(selfpointer->insertSubstitutions((const QString &)*cpp_arg_0, (const QStringList &)*cpp_arg_1));
      }}
#endif

#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::insertSubstitutions(...) ");
}

/*!
 * method key
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QFont, key)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'key' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->key());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QFont::key(...) ");
}

/*!
 * method setStrikeOut
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setStrikeOut)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setStrikeOut' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setStrikeOut((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::setStrikeOut(...) ");
}

/*!
 * method fromString
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * 
 * @access	public
 * @return	bool
 * @flags	
 */

ZEND_METHOD(QFont, fromString)
{
  ///const QString &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'fromString' is not static");
          RETURN_NULL();
        }
        /// try const QString &s0,
        QFont *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->fromString((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::fromString(...) ");
}

/*!
 * method exactMatch
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QFont, exactMatch)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'exactMatch' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->exactMatch());
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::exactMatch(...) ");
}

/*!
 * method handle
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Qt::HANDLE
 * @flags	c
 */

ZEND_METHOD(QFont, handle)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'handle' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->handle());
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::handle(...) ");
}

/*!
 * method setStyle
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Style styles0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setStyle)
{
// notice: unknown argument Style styles0, skipped
  php_error(E_ERROR, "could not parse argument in QFont::setStyle(...) ");
}

/*!
 * method setUnderline
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setUnderline)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setUnderline' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setUnderline((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::setUnderline(...) ");
}

/*!
 * method family
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QFont, family)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'family' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->family());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QFont::family(...) ");
}

/*!
 * method rawMode
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QFont, rawMode)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'rawMode' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->rawMode());
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::rawMode(...) ");
}

/*!
 * method operator QVariant
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	
 * @flags	c
 */

/*!
 * method setStretch
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ints0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setStretch)
{
  ///int ints0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setStretch' is not static");
        RETURN_NULL();
      }
      /// try int ints0,
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setStretch((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::setStretch(...) ");
}

/*!
 * method operator<
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QFont &s0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method operator==
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QFont &s0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method defaultFamily
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QFont, defaultFamily)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'defaultFamily' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->defaultFamily());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QFont::defaultFamily(...) ");
}

/*!
 * method kerning
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QFont, kerning)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'kerning' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->kerning());
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::kerning(...) ");
}

/*!
 * method QFont
 * 
 * @param: -
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &familys0
 * @param	 int pointSize = -1
 * @param	 int weight = -1
 * @param	 bool italic = false
 * 
 * overloaded args:
 * @param	const QFont &s0
 * @param	QPaintDevice  *pds1
 * 
 * overloaded args:
 * @param	const QFont &s0
 * 
 * overloaded args:
 * @param	QFontPrivate *
 * 
 * @access	public
 * @return	
 * @flags	
 */

ZEND_METHOD(QFont, __construct)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont_php_qt *selfpointer = new QFont_php_qt(getThis());

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  ///const QString &familys0, int pointSize = -1, int weight = -1, bool italic = false
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try const QString &familys0,
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QFont_php_qt *selfpointer = new QFont_php_qt(getThis(), (const QString &)*cpp_arg_0);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try const QString &familys0, int pointSize = -1,
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QFont_php_qt *selfpointer = new QFont_php_qt(getThis(), (const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1));

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try const QString &familys0, int pointSize = -1, int weight = -1,
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QFont_php_qt *selfpointer = new QFont_php_qt(getThis(), (const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2));

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_BOOL) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try const QString &familys0, int pointSize = -1, int weight = -1, bool italic = false,
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QFont_php_qt *selfpointer =
          new QFont_php_qt(getThis(), (const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (bool) Z_LVAL_P(arg_3));
        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  ///const QFont &s0,QPaintDevice  *pds1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QFont
#ifdef PHP_QT_QPaintDevice
      if (inherits(Z_OBJCE_P(arg_0), 24) && inherits(Z_OBJCE_P(arg_1), 49)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try const QFont &s0,QPaintDevice  *pds1,
        QFont *cpp_arg_0 = static_cast < QFont * >(php_qt_fetch(arg_0));
        QPaintDevice *cpp_arg_1 = static_cast < QPaintDevice * >(php_qt_fetch(arg_1));
        QFont_php_qt *selfpointer = new QFont_php_qt(getThis(), (const QFont &)*cpp_arg_0, (QPaintDevice *) cpp_arg_1);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

#endif

    }
  }
  ///const QFont &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QFont
      if (inherits(Z_OBJCE_P(arg_0), 24)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try const QFont &s0,
        QFont *cpp_arg_0 = static_cast < QFont * >(php_qt_fetch(arg_0));
        QFont_php_qt *selfpointer = new QFont_php_qt(getThis(), (const QFont &)*cpp_arg_0);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  ///QFontPrivate *
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QFontPrivate
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
/// method is private, skip
        php_error(E_ERROR, "QFont::__construct(...) cannot be called with 'QFontPrivate *,'.");
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::QFont(...) ");
}

/*!
 * method bold
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QFont, bold)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'bold' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->bold());
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::bold(...) ");
}

/*!
 * method style
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Style
 * @flags	c
 */

ZEND_METHOD(QFont, style)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type Style");
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::style(...) ");
}

/*!
 * method setStyleStrategy
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	StyleStrategy ss0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setStyleStrategy)
{
// notice: unknown argument StyleStrategy ss0, skipped
  php_error(E_ERROR, "could not parse argument in QFont::setStyleStrategy(...) ");
}

/*!
 * method cacheStatistics
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	s
 */

ZEND_METHOD(QFont, cacheStatistics)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      if (getThis() == NULL) {
        RETURN_VOID(QFont::cacheStatistics());
      } else {
        RETURN_VOID(selfpointer->cacheStatistics());
      }
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::cacheStatistics(...) ");
}

/*!
 * method lastResortFont
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QFont, lastResortFont)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'lastResortFont' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->lastResortFont());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QFont::lastResortFont(...) ");
}

/*!
 * method lastResortFamily
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QFont, lastResortFamily)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'lastResortFamily' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->lastResortFamily());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QFont::lastResortFamily(...) ");
}

/*!
 * method overline
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QFont, overline)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'overline' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->overline());
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::overline(...) ");
}

/*!
 * method setPointSizeF
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	qreal qreals0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setPointSizeF)
{
// notice: unknown argument qreal qreals0, skipped
  php_error(E_ERROR, "could not parse argument in QFont::setPointSizeF(...) ");
}

/*!
 * method pointSizeF
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	qreal
 * @flags	c
 */

ZEND_METHOD(QFont, pointSizeF)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type qreal");
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::pointSizeF(...) ");
}

/*!
 * method setOverline
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setOverline)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setOverline' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setOverline((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::setOverline(...) ");
}

/*!
 * method insertSubstitution
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * @param	 const QString &s1
 * 
 * @access	public
 * @return	void
 * @flags	s
 */

ZEND_METHOD(QFont, insertSubstitution)
{
  ///const QString &s0, const QString &s1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_1 = invokeToQString(arg_1);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QString
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
        /// try const QString &s0, const QString &s1,
        QFont *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));

        if (getThis() == NULL) {
          RETURN_VOID(QFont::insertSubstitution((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
        } else {
          RETURN_VOID(selfpointer->insertSubstitution((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
      }}
#endif

#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::insertSubstitution(...) ");
}

/*!
 * method operator!=
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QFont &s0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method styleStrategy
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	StyleStrategy
 * @flags	c
 */

ZEND_METHOD(QFont, styleStrategy)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type StyleStrategy");
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::styleStrategy(...) ");
}

/*!
 * method setKerning
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setKerning)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setKerning' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setKerning((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::setKerning(...) ");
}

/*!
 * method removeSubstitution
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * 
 * @access	public
 * @return	void
 * @flags	s
 */

ZEND_METHOD(QFont, removeSubstitution)
{
  ///const QString &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        /// try const QString &s0,
        QFont *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        if (getThis() == NULL) {
          RETURN_VOID(QFont::removeSubstitution((const QString &)*cpp_arg_0));
        } else {
          RETURN_VOID(selfpointer->removeSubstitution((const QString &)*cpp_arg_0));
      }}
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::removeSubstitution(...) ");
}

/*!
 * method substitute
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QFont, substitute)
{
  ///const QString &s0
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        /// try const QString &s0,
        QFont *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        if (getThis() == NULL) {
          *return_object = static_cast < QString > (QFont::substitute((const QString &)*cpp_arg_0));
        } else {
          *return_object = static_cast < QString > (selfpointer->substitute((const QString &)*cpp_arg_0));
        } le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QFont::substitute(...) ");
}

/*!
 * method setBold
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setBold)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setBold' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setBold((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::setBold(...) ");
}

/*!
 * method resolve
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QFont &s0
 * @param: -
 * 
 * overloaded args:
 * @param	uint mask
 * 
 * @access	public
 * @return	QFont
 * @flags	c
 */

ZEND_METHOD(QFont, resolve)
{
  ///const QFont &s0
#ifdef PHP_QT_QFont             // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QFont
      if (inherits(Z_OBJCE_P(arg_0), 24)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'resolve' is not static");
          RETURN_NULL();
        }
        /// try const QFont &s0,
        QFont *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
        }
        QFont *cpp_arg_0 = static_cast < QFont * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QFont *return_object = new QFont;

        *return_object = static_cast < QFont > (selfpointer->resolve((const QFont &)*cpp_arg_0));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'resolve' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->resolve());
    }
  }
  ///uint mask
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'resolve' is not static");
        RETURN_NULL();
      }
      /// try uint mask,
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->resolve((uint) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::resolve(...) ");
}

/*!
 * method weight
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QFont, weight)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'weight' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->weight());
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::weight(...) ");
}

/*!
 * method pointSize
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QFont, pointSize)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'pointSize' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->pointSize());
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::pointSize(...) ");
}

/*!
 * method cleanup
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	s
 */

ZEND_METHOD(QFont, cleanup)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      if (getThis() == NULL) {
        RETURN_VOID(QFont::cleanup());
      } else {
        RETURN_VOID(selfpointer->cleanup());
      }
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::cleanup(...) ");
}

/*!
 * method setWeight
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ints0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setWeight)
{
  ///int ints0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setWeight' is not static");
        RETURN_NULL();
      }
      /// try int ints0,
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setWeight((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::setWeight(...) ");
}

/*!
 * method styleHint
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	StyleHint
 * @flags	c
 */

ZEND_METHOD(QFont, styleHint)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type StyleHint");
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::styleHint(...) ");
}

/*!
 * method rawName
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QFont, rawName)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'rawName' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->rawName());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QFont::rawName(...) ");
}

/*!
 * method isCopyOf
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QFont &s0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QFont, isCopyOf)
{
  ///const QFont &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QFont
      if (inherits(Z_OBJCE_P(arg_0), 24)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'isCopyOf' is not static");
          RETURN_NULL();
        }
        /// try const QFont &s0,
        QFont *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
        }
        QFont *cpp_arg_0 = static_cast < QFont * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->isCopyOf((const QFont &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::isCopyOf(...) ");
}

/*!
 * method substitutes
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * 
 * @access	public
 * @return	QStringList
 * @flags	s
 */

ZEND_METHOD(QFont, substitutes)
{
  ///const QString &s0
#ifdef PHP_QT_QStringList       // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        /// try const QString &s0,
        QFont *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QStringList *return_object = new QStringList;

        if (getThis() == NULL) {
          *return_object = static_cast < QStringList > (QFont::substitutes((const QString &)*cpp_arg_0));
        } else {
          *return_object = static_cast < QStringList > (selfpointer->substitutes((const QString &)*cpp_arg_0));
        } le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QFont::substitutes(...) ");
}

/*!
 * method detach
 * 
 * @param: -
 * @param: -
 * 
 * @access	private
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, detach)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
/// method is private, skip
      php_error(E_ERROR, "QFont::detach(...) cannot be called with ''.");
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::detach(...) ");
}

/*!
 * method initialize
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	s
 */

ZEND_METHOD(QFont, initialize)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      if (getThis() == NULL) {
        RETURN_VOID(QFont::initialize());
      } else {
        RETURN_VOID(selfpointer->initialize());
      }
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::initialize(...) ");
}

/*!
 * method toString
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QFont, toString)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toString' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->toString());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QFont::toString(...) ");
}

/*!
 * method setRawMode
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setRawMode)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setRawMode' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setRawMode((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::setRawMode(...) ");
}

/*!
 * method setStyleHint
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	StyleHint StyleHints0
 * @param	 StyleStrategy = PreferDefaults1
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setStyleHint)
{
// notice: unknown argument StyleHint StyleHints0, skipped
  php_error(E_ERROR, "could not parse argument in QFont::setStyleHint(...) ");
}

/*!
 * method substitutions
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QStringList
 * @flags	s
 */

ZEND_METHOD(QFont, substitutions)
{
  ///
#ifdef PHP_QT_QStringList       // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QStringList *return_object = new QStringList;

      if (getThis() == NULL) {
        *return_object = static_cast < QStringList > (QFont::substitutions());
      } else {
        *return_object = static_cast < QStringList > (selfpointer->substitutions());
      }
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QFont::substitutions(...) ");
}

/*!
 * method setFamily
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setFamily)
{
  ///const QString &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setFamily' is not static");
          RETURN_NULL();
        }
        /// try const QString &s0,
        QFont *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setFamily((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::setFamily(...) ");
}

/*!
 * method setPointSize
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ints0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setPointSize)
{
  ///int ints0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setPointSize' is not static");
        RETURN_NULL();
      }
      /// try int ints0,
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setPointSize((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::setPointSize(...) ");
}

/*!
 * method setRawName
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setRawName)
{
  ///const QString &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setRawName' is not static");
          RETURN_NULL();
        }
        /// try const QString &s0,
        QFont *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setRawName((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::setRawName(...) ");
}

/*!
 * method setFixedPitch
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setFixedPitch)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setFixedPitch' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setFixedPitch((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::setFixedPitch(...) ");
}

/*!
 * method setPixelSize
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ints0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setPixelSize)
{
  ///int ints0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setPixelSize' is not static");
        RETURN_NULL();
      }
      /// try int ints0,
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setPixelSize((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::setPixelSize(...) ");
}

/*!
 * method setItalic
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bs0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QFont, setItalic)
{
  ///bool bs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setItalic' is not static");
        RETURN_NULL();
      }
      /// try bool bs0,
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setItalic((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::setItalic(...) ");
}

/*!
 * method strikeOut
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QFont, strikeOut)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'strikeOut' is not static");
        RETURN_NULL();
      }
      /// try 
      QFont *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QFont * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->strikeOut());
    }
  }
  php_error(E_ERROR, "could not parse argument in QFont::strikeOut(...) ");
}

/*!
 * method operator=
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QFont &s0
 * 
 * @access	public
 * @return	QFont &
 * @flags	
 */
