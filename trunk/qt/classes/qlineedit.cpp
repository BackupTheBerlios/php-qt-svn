/*
 * PHP-Qt - The PHP language bindings for Qt
 *
 * Copyright (C) 2006
 * Thomas Moenicke <tm@ippfp.org>,
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * QLineEdit.cpp - QLineEdit PHP implementation.
 * begin           : Tue Jun  6 22:42:56 2006
 * generated by    : moni using kalyptus 0.9.
 */

#include <iostream>
using namespace std;

#include "../php_qt.h"


#include <QLineEdit>
/// DEBUG:destructor skipped.
#include <QMetaMethod>
class QLineEdit_php_qt:public QLineEdit
{

public:
  QLineEdit_php_qt(zval * zend_ptr, QWidget * parent = 0);
  QLineEdit_php_qt(zval * zend_ptr, const QString & s0, QWidget * parent = 0);


  zval *zend_ptr;
  const QMetaObject *metaObject() const;
  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
};

QLineEdit_php_qt::QLineEdit_php_qt(zval * zend_ptr, QWidget * parent):QLineEdit(parent)
{
  this->zend_ptr = zend_ptr;
// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QLineEdit",&staticMetaObject));
}
QLineEdit_php_qt::QLineEdit_php_qt(zval * zend_ptr, const QString & s0, QWidget * parent):
QLineEdit(s0, parent)
{
  this->zend_ptr = zend_ptr;
// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QLineEdit",&staticMetaObject));
}

PHP_QT_MOC(QLineEdit);

/*!
 * method tr
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 const char *s0
 * @param	 const char * = 0 s1
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QLineEdit, tr)
{
  /// const char *s0, const char * = 0 s1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      /// try  const char *s0,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QLineEdit::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
      /// try  const char *s0, const char * = 0 s1,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QLineEdit::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLineEdit::tr(...) ");
}

/*!
 * method inputMask
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QLineEdit, inputMask)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'inputMask' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->inputMask());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLineEdit::inputMask(...) ");
}

/*!
 * method insert
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, insert)
{
  ///const QString &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'insert' is not static");
          RETURN_NULL();
        }
        /// try const QString &s0,
        QLineEdit *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->insert((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::insert(...) ");
}

/*!
 * method cursorPosition
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QLineEdit, cursorPosition)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'cursorPosition' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->cursorPosition());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::cursorPosition(...) ");
}

/*!
 * method mouseMoveEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QMouseEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method clear
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QLineEdit, clear)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'clear' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->clear());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::clear(...) ");
}

/*!
 * method selectionStart
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QLineEdit, selectionStart)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'selectionStart' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->selectionStart());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::selectionStart(...) ");
}

/*!
 * method setMaxLength
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ints0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, setMaxLength)
{
  ///int ints0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setMaxLength' is not static");
        RETURN_NULL();
      }
      /// try int ints0,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setMaxLength((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::setMaxLength(...) ");
}

/*!
 * method qt_invoke
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 int  ints0
 * @param	 QUObject * s1
 * 
 * @access	public
 * @return	bool
 * @flags	v
 */

/*!
 * method setModified
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, setModified)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setModified' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setModified((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::setModified(...) ");
}

/*!
 * method setFrame
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, setFrame)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setFrame' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setFrame((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::setFrame(...) ");
}

/*!
 * method qt_cast
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 const char * s0
 * 
 * @access	public
 * @return	void*
 * @flags	v
 */

/*!
 * method setReadOnly
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, setReadOnly)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setReadOnly' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setReadOnly((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::setReadOnly(...) ");
}

/*!
 * method setEchoMode
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	EchoMode EchoModes0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, setEchoMode)
{
// notice: unknown argument EchoMode EchoModes0, skipped
  php_error(E_ERROR, "could not parse argument in QLineEdit::setEchoMode(...) ");
}

/*!
 * method metaObject
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QMetaObject *
 * @flags	cv
 */

/*!
 * method cursorBackward
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool marks0
 * @param	 int steps = 1s1
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, cursorBackward)
{
  ///bool marks0, int steps = 1s1
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'cursorBackward' is not static");
        RETURN_NULL();
      }
      /// try bool marks0,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->cursorBackward((bool) Z_LVAL_P(arg_0)));
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'cursorBackward' is not static");
        RETURN_NULL();
      }
      /// try bool marks0, int steps = 1s1,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->cursorBackward((bool) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::cursorBackward(...) ");
}

/*!
 * method cursorWordBackward
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool marks0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, cursorWordBackward)
{
  ///bool marks0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'cursorWordBackward' is not static");
        RETURN_NULL();
      }
      /// try bool marks0,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->cursorWordBackward((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::cursorWordBackward(...) ");
}

/*!
 * method qt_emit
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 int  ints0
 * @param	 QUObject * s1
 * 
 * @access	public
 * @return	bool
 * @flags	v
 */

/*!
 * method setAlignment
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::Alignment flags0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, setAlignment)
{
  ///Qt::Alignment flags0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setAlignment' is not static");
        RETURN_NULL();
      }
      /// try Qt::Alignment flags0,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setAlignment((Qt::Alignment) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::setAlignment(...) ");
}

/*!
 * method className
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const char *
 * @flags	cv
 */

/*!
 * method dragLeaveEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QDragLeaveEvent *es0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method QLineEdit
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget * parent=0s0
 * 
 * overloaded args:
 * @param	const QString &s0
 * @param	 QWidget * parent=0
 * 
 * overloaded args:
 * @param	const QLineEdit &
 * 
 * @access	public
 * @return	
 * @flags	t
 */

ZEND_METHOD(QLineEdit, __construct)
{
  ///QWidget * parent=0s0
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit_php_qt *selfpointer = new QLineEdit_php_qt(getThis());

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try QWidget * parent=0s0,
      QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
      QLineEdit_php_qt *selfpointer = new QLineEdit_php_qt(getThis(), (QWidget *) cpp_arg_0);

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  ///const QString &s0, QWidget * parent=0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try const QString &s0,
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QLineEdit_php_qt *selfpointer = new QLineEdit_php_qt(getThis(), (const QString &)*cpp_arg_0);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try const QString &s0, QWidget * parent=0,
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QWidget *cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
        QLineEdit_php_qt *selfpointer = new QLineEdit_php_qt(getThis(), (const QString &)*cpp_arg_0, (QWidget *) cpp_arg_1);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  ///const QLineEdit &
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QLineEdit
      if (inherits(Z_OBJCE_P(arg_0), 43)) {
/// method is private, skip
        php_error(E_ERROR, "QLineEdit::__construct(...) cannot be called with 'const QLineEdit &,'.");
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::QLineEdit(...) ");
}

/*!
 * method staticMetaObject
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QMetaObject*
 * @flags	s
 */

ZEND_METHOD(QLineEdit, staticMetaObject)
{
  ///
#ifdef PHP_QT_QMetaObject       // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      if (getThis() == NULL) {
        le.ptr = static_cast < QMetaObject * >(QLineEdit::staticMetaObject());
      } else {
        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
      }
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLineEdit::staticMetaObject(...) ");
}

/*!
 * method mouseReleaseEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QMouseEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method qObject
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QObject*
 * @flags	
 */

/*!
 * method inputMethodQuery
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::InputMethodQuery Qt::InputMethodQuerys0
 * 
 * @access	public
 * @return	QVariant
 * @flags	c
 */

ZEND_METHOD(QLineEdit, inputMethodQuery)
{
  ///Qt::InputMethodQuery Qt::InputMethodQuerys0
#ifdef PHP_QT_QVariant          // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'inputMethodQuery' is not static");
        RETURN_NULL();
      }
      /// try Qt::InputMethodQuery Qt::InputMethodQuerys0,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QVariant *return_object = new QVariant;

      *return_object = static_cast < QVariant > (selfpointer->inputMethodQuery((Qt::InputMethodQuery) Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLineEdit::inputMethodQuery(...) ");
}

/*!
 * method text
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QLineEdit, text)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'text' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->text());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLineEdit::text(...) ");
}

/*!
 * method minimumSizeHint
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QSize
 * @flags	c
 */

ZEND_METHOD(QLineEdit, minimumSizeHint)
{
  ///
#ifdef PHP_QT_QSize             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'minimumSizeHint' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QSize *return_object = new QSize;

      *return_object = static_cast < QSize > (selfpointer->minimumSizeHint());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLineEdit::minimumSizeHint(...) ");
}

/*!
 * method home
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool marks0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, home)
{
  ///bool marks0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'home' is not static");
        RETURN_NULL();
      }
      /// try bool marks0,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->home((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::home(...) ");
}

/*!
 * method returnPressed
 * 
 * @param: -
 * @param: -
 * 
 * @access	signals
 * @return	void
 * @flags	n
 */

/*!
 * method del
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, del)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'del' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->del());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::del(...) ");
}

/*!
 * method dropEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QDropEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method cursorForward
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool marks0
 * @param	 int steps = 1s1
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, cursorForward)
{
  ///bool marks0, int steps = 1s1
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'cursorForward' is not static");
        RETURN_NULL();
      }
      /// try bool marks0,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->cursorForward((bool) Z_LVAL_P(arg_0)));
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'cursorForward' is not static");
        RETURN_NULL();
      }
      /// try bool marks0, int steps = 1s1,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->cursorForward((bool) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::cursorForward(...) ");
}

/*!
 * method setDragEnabled
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bs0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, setDragEnabled)
{
  ///bool bs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setDragEnabled' is not static");
        RETURN_NULL();
      }
      /// try bool bs0,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setDragEnabled((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::setDragEnabled(...) ");
}

/*!
 * method contextMenuEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QContextMenuEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method cursorPositionChanged
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ints0
 * @param	 int  ints1
 * 
 * @access	signals
 * @return	void
 * @flags	n
 */

/*!
 * method qt_property
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 int  ints0
 * @param	 int  ints1
 * @param	 QVariant * s2
 * 
 * @access	public
 * @return	bool
 * @flags	v
 */

/*!
 * method echoMode
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	EchoMode
 * @flags	c
 */

ZEND_METHOD(QLineEdit, echoMode)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type EchoMode");
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::echoMode(...) ");
}

/*!
 * method inputMethodEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QInputMethodEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method setValidator
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QValidator *s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, setValidator)
{
  ///const QValidator *s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QValidator
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setValidator' is not static");
          RETURN_NULL();
        }
        /// try const QValidator *s0,
        QLineEdit *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
        }
        QValidator *cpp_arg_0 = static_cast < QValidator * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setValidator((const QValidator *)cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::setValidator(...) ");
}

/*!
 * method hasSelectedText
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QLineEdit, hasSelectedText)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'hasSelectedText' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->hasSelectedText());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::hasSelectedText(...) ");
}

/*!
 * method textChanged
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * 
 * @access	signals
 * @return	void
 * @flags	n
 */

/*!
 * method paste
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QLineEdit, paste)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'paste' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->paste());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::paste(...) ");
}

/*!
 * method hasAcceptableInput
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QLineEdit, hasAcceptableInput)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'hasAcceptableInput' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->hasAcceptableInput());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::hasAcceptableInput(...) ");
}

/*!
 * method copy
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	void
 * @flags	cl
 */

ZEND_METHOD(QLineEdit, copy)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'copy' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->copy());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::copy(...) ");
}

/*!
 * method redo
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QLineEdit, redo)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'redo' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->redo());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::redo(...) ");
}

/*!
 * method dragEnterEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QDragEnterEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method undo
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QLineEdit, undo)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'undo' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->undo());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::undo(...) ");
}

/*!
 * method cursorWordForward
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool marks0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, cursorWordForward)
{
  ///bool marks0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'cursorWordForward' is not static");
        RETURN_NULL();
      }
      /// try bool marks0,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->cursorWordForward((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::cursorWordForward(...) ");
}

/*!
 * method displayText
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QLineEdit, displayText)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'displayText' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->displayText());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLineEdit::displayText(...) ");
}

/*!
 * method focusOutEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QFocusEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method event
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QEvent *s0
 * 
 * @access	public
 * @return	bool
 * @flags	
 */

ZEND_METHOD(QLineEdit, event)
{
  ///QEvent *s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QEvent
      if (inherits(Z_OBJCE_P(arg_0), 21)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'event' is not static");
          RETURN_NULL();
        }
        /// try QEvent *s0,
        QLineEdit *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
        }
        QEvent *cpp_arg_0 = static_cast < QEvent * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->event((QEvent *) cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::event(...) ");
}

/*!
 * method end
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool marks0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, end)
{
  ///bool marks0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'end' is not static");
        RETURN_NULL();
      }
      /// try bool marks0,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->end((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::end(...) ");
}

/*!
 * method validator
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const QValidator *
 * @flags	c
 */

ZEND_METHOD(QLineEdit, validator)
{
  ///
#ifdef PHP_QT_QValidator        // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'validator' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = const_cast < QValidator * >(selfpointer->validator());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLineEdit::validator(...) ");
}

/*!
 * method isRedoAvailable
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QLineEdit, isRedoAvailable)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isRedoAvailable' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isRedoAvailable());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::isRedoAvailable(...) ");
}

/*!
 * method deselect
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, deselect)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'deselect' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->deselect());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::deselect(...) ");
}

/*!
 * method cursorPositionAt
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPoint &poss0
 * 
 * @access	public
 * @return	int
 * @flags	
 */

ZEND_METHOD(QLineEdit, cursorPositionAt)
{
  ///const QPoint &poss0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'cursorPositionAt' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &poss0,
        QLineEdit *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
        }
        QPoint *cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->cursorPositionAt((const QPoint &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::cursorPositionAt(...) ");
}

/*!
 * method paintEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QPaintEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method selectedText
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QLineEdit, selectedText)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'selectedText' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->selectedText());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLineEdit::selectedText(...) ");
}

/*!
 * method setSelection
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ints0
 * @param	 int  ints1
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, setSelection)
{
  ///int ints0, int  ints1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setSelection' is not static");
        RETURN_NULL();
      }
      /// try int ints0, int  ints1,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setSelection((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::setSelection(...) ");
}

/*!
 * method mouseDoubleClickEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QMouseEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method selectionChanged
 * 
 * @param: -
 * @param: -
 * 
 * @access	signals
 * @return	void
 * @flags	n
 */

/*!
 * method isUndoAvailable
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QLineEdit, isUndoAvailable)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isUndoAvailable' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isUndoAvailable());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::isUndoAvailable(...) ");
}

/*!
 * method changeEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method setInputMask
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &inputMasks0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, setInputMask)
{
  ///const QString &inputMasks0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setInputMask' is not static");
          RETURN_NULL();
        }
        /// try const QString &inputMasks0,
        QLineEdit *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setInputMask((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::setInputMask(...) ");
}

/*!
 * method hasFrame
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QLineEdit, hasFrame)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'hasFrame' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->hasFrame());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::hasFrame(...) ");
}

/*!
 * method mousePressEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QMouseEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method dragEnabled
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QLineEdit, dragEnabled)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'dragEnabled' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->dragEnabled());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::dragEnabled(...) ");
}

/*!
 * method cut
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QLineEdit, cut)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'cut' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->cut());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::cut(...) ");
}

/*!
 * method setText
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QLineEdit, setText)
{
  ///const QString &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setText' is not static");
          RETURN_NULL();
        }
        /// try const QString &s0,
        QLineEdit *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setText((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::setText(...) ");
}

/*!
 * method alignment
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Qt::Alignment
 * @flags	c
 */

ZEND_METHOD(QLineEdit, alignment)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'alignment' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->alignment());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::alignment(...) ");
}

/*!
 * method sizeHint
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QSize
 * @flags	c
 */

ZEND_METHOD(QLineEdit, sizeHint)
{
  ///
#ifdef PHP_QT_QSize             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'sizeHint' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QSize *return_object = new QSize;

      *return_object = static_cast < QSize > (selfpointer->sizeHint());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLineEdit::sizeHint(...) ");
}

/*!
 * method dragMoveEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QDragMoveEvent *es0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method setCursorPosition
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ints0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, setCursorPosition)
{
  ///int ints0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setCursorPosition' is not static");
        RETURN_NULL();
      }
      /// try int ints0,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setCursorPosition((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::setCursorPosition(...) ");
}

/*!
 * method createStandardContextMenu
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QMenu *
 * @flags	
 */

ZEND_METHOD(QLineEdit, createStandardContextMenu)
{
  ///
#ifdef PHP_QT_QMenu             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'createStandardContextMenu' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = static_cast < QMenu * >(selfpointer->createStandardContextMenu());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLineEdit::createStandardContextMenu(...) ");
}

/*!
 * method backspace
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLineEdit, backspace)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'backspace' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->backspace());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::backspace(...) ");
}

/*!
 * method keyPressEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QKeyEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method selectAll
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QLineEdit, selectAll)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'selectAll' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->selectAll());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::selectAll(...) ");
}

/*!
 * method focusInEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QFocusEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method editingFinished
 * 
 * @param: -
 * @param: -
 * 
 * @access	signals
 * @return	void
 * @flags	n
 */

/*!
 * method textEdited
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &s0
 * 
 * @access	signals
 * @return	void
 * @flags	n
 */

/*!
 * method maxLength
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QLineEdit, maxLength)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'maxLength' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->maxLength());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::maxLength(...) ");
}

/*!
 * method trUtf8
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 const char *s0
 * @param	 const char * = 0 s1
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QLineEdit, trUtf8)
{
  /// const char *s0, const char * = 0 s1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      /// try  const char *s0,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QLineEdit::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
      /// try  const char *s0, const char * = 0 s1,
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QLineEdit::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLineEdit::trUtf8(...) ");
}

/*!
 * method isModified
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QLineEdit, isModified)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isModified' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isModified());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::isModified(...) ");
}

/*!
 * method isReadOnly
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QLineEdit, isReadOnly)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isReadOnly' is not static");
        RETURN_NULL();
      }
      /// try 
      QLineEdit *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLineEdit * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isReadOnly());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLineEdit::isReadOnly(...) ");
}
