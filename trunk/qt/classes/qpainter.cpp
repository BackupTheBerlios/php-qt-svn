/*
 * PHP-Qt - The PHP language bindings for Qt
 *
 * Copyright (C) 2006
 * Thomas Moenicke <tm@ippfp.org>,
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * QPainter.cpp - QPainter PHP implementation.
 * begin           : Tue Jun  6 22:42:56 2006
 * generated by    : moni using kalyptus 0.9.
 */

#include <iostream>
using namespace std;

#include "../php_qt.h"


#include <QPainter>
#include <QPainterPath>
/// DEBUG:destructor skipped.
#include <QMetaMethod>
class QPainter_php_qt:public QPainter
{

public:
  QPainter_php_qt(zval * zend_ptr);
  QPainter_php_qt(zval * zend_ptr, QPaintDevice * s0);


  zval *zend_ptr;
};

QPainter_php_qt::QPainter_php_qt(zval * zend_ptr):QPainter()
{
  this->zend_ptr = zend_ptr;
}

QPainter_php_qt::QPainter_php_qt(zval * zend_ptr, QPaintDevice * s0):QPainter(s0)
{
  this->zend_ptr = zend_ptr;
}

/*!
 * method eraseRect
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRectF &s0
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 int w
 * @param	 int h
 * 
 * overloaded args:
 * @param	const QRect &
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, eraseRect)
{
  ///const QRectF &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'eraseRect' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &s0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->eraseRect((const QRectF &)*cpp_arg_0));
      }
#endif

    }
  }
  ///int x, int y, int w, int h
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'eraseRect' is not static");
        RETURN_NULL();
      }
      /// try int x, int y, int w, int h,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->eraseRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
    }
  }
  ///const QRect &
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'eraseRect' is not static");
          RETURN_NULL();
        }
        /// try const QRect &,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->eraseRect((const QRect &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::eraseRect(...) ");
}

/*!
 * method setClipPath
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPainterPath &paths0
 * @param	 Qt::ClipOperation op = Qt::ReplaceClips1
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setClipPath)
{
  ///const QPainterPath &paths0, Qt::ClipOperation op = Qt::ReplaceClips1
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPainterPath
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setClipPath' is not static");
          RETURN_NULL();
        }
        /// try const QPainterPath &paths0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPainterPath *
          cpp_arg_0 = static_cast < QPainterPath * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setClipPath((const QPainterPath &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QPainterPath
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setClipPath' is not static");
          RETURN_NULL();
        }
        /// try const QPainterPath &paths0, Qt::ClipOperation op = Qt::ReplaceClips1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPainterPath *
          cpp_arg_0 = static_cast < QPainterPath * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setClipPath((const QPainterPath &)*cpp_arg_0, (Qt::ClipOperation) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::setClipPath(...) ");
}

/*!
 * method matrixEnabled
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QPainter, matrixEnabled)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'matrixEnabled' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->matrixEnabled());
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::matrixEnabled(...) ");
}

/*!
 * method shear
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	qreal shs0
 * @param	 qreal svs1
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, shear)
{
// notice: unknown argument qreal shs0, skipped
  php_error(E_ERROR, "could not parse argument in QPainter::shear(...) ");
}

/*!
 * method save
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, save)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'save' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->save());
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::save(...) ");
}

/*!
 * method resetMatrix
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, resetMatrix)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'resetMatrix' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->resetMatrix());
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::resetMatrix(...) ");
}

/*!
 * method initFrom
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QWidget *widgets0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, initFrom)
{
  ///const QWidget *widgets0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QWidget
      if (inherits(Z_OBJCE_P(arg_0), 71)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'initFrom' is not static");
          RETURN_NULL();
        }
        /// try const QWidget *widgets0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QWidget *
          cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->initFrom((const QWidget *)cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::initFrom(...) ");
}

/*!
 * method fontInfo
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QFontInfo
 * @flags	c
 */

ZEND_METHOD(QPainter, fontInfo)
{
  ///
#ifdef PHP_QT_QFontInfo         // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'fontInfo' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QFontInfo *
        return_object = new QFontInfo;

      *return_object = static_cast < QFontInfo > (selfpointer->fontInfo());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QPainter::fontInfo(...) ");
}

/*!
 * method setLayoutDirection
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::LayoutDirection directions0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setLayoutDirection)
{
  ///Qt::LayoutDirection directions0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setLayoutDirection' is not static");
        RETURN_NULL();
      }
      /// try Qt::LayoutDirection directions0,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setLayoutDirection((Qt::LayoutDirection) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::setLayoutDirection(...) ");
}

/*!
 * method setBrushOrigin
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int xs0
 * @param	 int ys1
 * 
 * overloaded args:
 * @param	const QPoint &
 * 
 * overloaded args:
 * @param	const QPointF &
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setBrushOrigin)
{
  ///int xs0, int ys1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setBrushOrigin' is not static");
        RETURN_NULL();
      }
      /// try int xs0, int ys1,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setBrushOrigin((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
    }
  }
  ///const QPoint &
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setBrushOrigin' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setBrushOrigin((const QPoint &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QPointF &
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPointF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setBrushOrigin' is not static");
          RETURN_NULL();
        }
        /// try const QPointF &,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setBrushOrigin((const QPointF &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::setBrushOrigin(...) ");
}

/*!
 * method pen
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const QPen &
 * @flags	c
 */

ZEND_METHOD(QPainter, pen)
{
  ///
#ifdef PHP_QT_QPen              // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'pen' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = &const_cast < QPen & >(selfpointer->pen());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QPainter::pen(...) ");
}

/*!
 * method drawRects
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRectF *rectss0
 * @param	 int rectCounts1
 * 
 * overloaded args:
 * @param	const QVector<QRectF> &rectangles
 * 
 * overloaded args:
 * @param	const QRect *rects
 * @param	 int rectCount
 * 
 * overloaded args:
 * @param	const QVector<QRect> &rectangles
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawRects)
{
  ///const QRectF *rectss0, int rectCounts1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawRects' is not static");
          RETURN_NULL();
        }
        /// try const QRectF *rectss0, int rectCounts1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawRects((const QRectF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QVector<QRectF> &rectangles
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QVector
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawRects' is not static");
          RETURN_NULL();
        }
        /// try const QVector<QRectF> &rectangles,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QVector < QRectF > *cpp_arg_0 = static_cast < QVector < QRectF > *>(php_qt_fetch(arg_0));
        RETURN_VOID(selfpointer->drawRects((const QVector < QRectF > &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QRect *rects, int rectCount
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawRects' is not static");
          RETURN_NULL();
        }
        /// try const QRect *rects, int rectCount,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawRects((const QRect *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QVector<QRect> &rectangles
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QVector
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawRects' is not static");
          RETURN_NULL();
        }
        /// try const QVector<QRect> &rectangles,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QVector < QRect > *cpp_arg_0 = static_cast < QVector < QRect > *>(php_qt_fetch(arg_0));
        RETURN_VOID(selfpointer->drawRects((const QVector < QRect > &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawRects(...) ");
}

/*!
 * method drawPath
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPainterPath &paths0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawPath)
{
  ///const QPainterPath &paths0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPainterPath
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPath' is not static");
          RETURN_NULL();
        }
        /// try const QPainterPath &paths0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPainterPath *
          cpp_arg_0 = static_cast < QPainterPath * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPath((const QPainterPath &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawPath(...) ");
}

/*!
 * method fillPath
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPainterPath &paths0
 * @param	 const QBrush &brushs1
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, fillPath)
{
  ///const QPainterPath &paths0, const QBrush &brushs1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QPainterPath
#ifdef PHP_QT_QBrush
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'fillPath' is not static");
          RETURN_NULL();
        }
        /// try const QPainterPath &paths0, const QBrush &brushs1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPainterPath *
          cpp_arg_0 = static_cast < QPainterPath * >(php_qt_fetch(arg_0));
        QBrush *
          cpp_arg_1 = static_cast < QBrush * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->fillPath((const QPainterPath &)*cpp_arg_0, (const QBrush &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::fillPath(...) ");
}

/*!
 * method rotate
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	qreal as0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, rotate)
{
// notice: unknown argument qreal as0, skipped
  php_error(E_ERROR, "could not parse argument in QPainter::rotate(...) ");
}

/*!
 * method drawPie
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRectF &rects0
 * @param	 int as1
 * @param	 int alens2
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 int w
 * @param	 int h
 * @param	 int a
 * @param	 int alen
 * 
 * overloaded args:
 * @param	const QRect &
 * @param	 int a
 * @param	 int alen
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawPie)
{
  ///const QRectF &rects0, int as1, int alens2
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPie' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &rects0, int as1, int alens2,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPie((const QRectF &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
      }
#endif

    }
  }
  ///int x, int y, int w, int h, int a, int alen
  if (ZEND_NUM_ARGS() == 6) {
    PHP_QT_FETCH_6_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG
        && Z_TYPE_P(arg_5) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'drawPie' is not static");
        RETURN_NULL();
      }
      /// try int x, int y, int w, int h, int a, int alen,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->
                  drawPie((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4), (int)Z_LVAL_P(arg_5)));
    }
  }
  ///const QRect &, int a, int alen
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPie' is not static");
          RETURN_NULL();
        }
        /// try const QRect &, int a, int alen,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPie((const QRect &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawPie(...) ");
}

/*!
 * method translate
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPointF &offsets0
 * 
 * overloaded args:
 * @param	const QPoint &offset
 * 
 * overloaded args:
 * @param	qreal dx
 * @param	 qreal dy
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, translate)
{
  ///const QPointF &offsets0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPointF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'translate' is not static");
          RETURN_NULL();
        }
        /// try const QPointF &offsets0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->translate((const QPointF &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QPoint &offset
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'translate' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &offset,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->translate((const QPoint &)*cpp_arg_0));
      }
#endif

    }
  }
// notice: unknown argument qreal dx, skipped
  php_error(E_ERROR, "could not parse argument in QPainter::translate(...) ");
}

/*!
 * method setCompositionMode
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	CompositionMode modes0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setCompositionMode)
{
// notice: unknown argument CompositionMode modes0, skipped
  php_error(E_ERROR, "could not parse argument in QPainter::setCompositionMode(...) ");
}

/*!
 * method setWindow
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRect &windows0
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 int w
 * @param	 int h
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setWindow)
{
  ///const QRect &windows0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setWindow' is not static");
          RETURN_NULL();
        }
        /// try const QRect &windows0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setWindow((const QRect &)*cpp_arg_0));
      }
#endif

    }
  }
  ///int x, int y, int w, int h
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setWindow' is not static");
        RETURN_NULL();
      }
      /// try int x, int y, int w, int h,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setWindow((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::setWindow(...) ");
}

/*!
 * method fontMetrics
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QFontMetrics
 * @flags	c
 */

ZEND_METHOD(QPainter, fontMetrics)
{
  ///
#ifdef PHP_QT_QFontMetrics      // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'fontMetrics' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QFontMetrics *
        return_object = new QFontMetrics;

      *return_object = static_cast < QFontMetrics > (selfpointer->fontMetrics());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QPainter::fontMetrics(...) ");
}

/*!
 * method drawPixmap
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRectF &targetRects0
 * @param	 const QPixmap &pixmaps1
 * @param	 const QRectF &sourceRects2
 * 
 * overloaded args:
 * @param	const QRect &targetRect
 * @param	 const QPixmap &pixmap
 * @param	 const QRect &sourceRect
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 int w
 * @param	 int h
 * @param	 const QPixmap &pm
 * @param	 int sx
 * @param	 int sy
 * @param	 int sw
 * @param	 int sh
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 const QPixmap &pm
 * @param	 int sx
 * @param	 int sy
 * @param	 int sw
 * @param	 int sh
 * 
 * overloaded args:
 * @param	const QPointF &p
 * @param	 const QPixmap &pm
 * @param	 const QRectF &sr
 * 
 * overloaded args:
 * @param	const QPoint &p
 * @param	 const QPixmap &pm
 * @param	 const QRect &sr
 * 
 * overloaded args:
 * @param	const QPointF &p
 * @param	 const QPixmap &pm
 * 
 * overloaded args:
 * @param	const QPoint &p
 * @param	 const QPixmap &pm
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 const QPixmap &pm
 * 
 * overloaded args:
 * @param	const QRect &r
 * @param	 const QPixmap &pm
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 int w
 * @param	 int h
 * @param	 const QPixmap &pm
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawPixmap)
{
  ///const QRectF &targetRects0, const QPixmap &pixmaps1, const QRectF &sourceRects2
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
#ifdef PHP_QT_QPixmap
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPixmap' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &targetRects0, const QPixmap &pixmaps1, const QRectF &sourceRects2,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
        QPixmap *
          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));
        QRectF *
          cpp_arg_2 = static_cast < QRectF * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawPixmap((const QRectF &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1, (const QRectF &)*cpp_arg_2));
      }
#endif

#endif

#endif

    }
  }
  ///const QRect &targetRect, const QPixmap &pixmap, const QRect &sourceRect
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QRect
#ifdef PHP_QT_QPixmap
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPixmap' is not static");
          RETURN_NULL();
        }
        /// try const QRect &targetRect, const QPixmap &pixmap, const QRect &sourceRect,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
        QPixmap *
          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));
        QRect *
          cpp_arg_2 = static_cast < QRect * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawPixmap((const QRect &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1, (const QRect &)*cpp_arg_2));
      }
#endif

#endif

#endif

    }
  }
  ///int x, int y, int w, int h, const QPixmap &pm, int sx, int sy, int sw, int sh
  if (ZEND_NUM_ARGS() == 9) {
    PHP_QT_FETCH_9_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
        Z_TYPE_P(arg_4) == IS_OBJECT && Z_TYPE_P(arg_5) == IS_LONG && Z_TYPE_P(arg_6) == IS_LONG && Z_TYPE_P(arg_7) == IS_LONG && Z_TYPE_P(arg_8) == IS_LONG) {
#ifdef PHP_QT_QPixmap
      if (inherits(Z_OBJCE_P(arg_4), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPixmap' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, int w, int h, const QPixmap &pm, int sx, int sy, int sw, int sh,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPixmap *
          cpp_arg_4 = static_cast < QPixmap * >(php_qt_fetch(arg_4));

        RETURN_VOID(selfpointer->
                    drawPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QPixmap &)*cpp_arg_4,
                               (int)Z_LVAL_P(arg_5), (int)Z_LVAL_P(arg_6), (int)Z_LVAL_P(arg_7), (int)Z_LVAL_P(arg_8)));
      }
#endif

    }
  }
  ///int x, int y, const QPixmap &pm, int sx, int sy, int sw, int sh
  if (ZEND_NUM_ARGS() == 7) {
    PHP_QT_FETCH_7_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG &&
        Z_TYPE_P(arg_4) == IS_LONG && Z_TYPE_P(arg_5) == IS_LONG && Z_TYPE_P(arg_6) == IS_LONG) {
#ifdef PHP_QT_QPixmap
      if (inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPixmap' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, const QPixmap &pm, int sx, int sy, int sw, int sh,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPixmap *
          cpp_arg_2 = static_cast < QPixmap * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->
                    drawPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QPixmap &)*cpp_arg_2, (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
                               (int)Z_LVAL_P(arg_5), (int)Z_LVAL_P(arg_6)));
      }
#endif

    }
  }
  ///const QPointF &p, const QPixmap &pm, const QRectF &sr
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QPointF
#ifdef PHP_QT_QPixmap
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPixmap' is not static");
          RETURN_NULL();
        }
        /// try const QPointF &p, const QPixmap &pm, const QRectF &sr,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
        QPixmap *
          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));
        QRectF *
          cpp_arg_2 = static_cast < QRectF * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawPixmap((const QPointF &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1, (const QRectF &)*cpp_arg_2));
      }
#endif

#endif

#endif

    }
  }
  ///const QPoint &p, const QPixmap &pm, const QRect &sr
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
#ifdef PHP_QT_QPixmap
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPixmap' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &p, const QPixmap &pm, const QRect &sr,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
        QPixmap *
          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));
        QRect *
          cpp_arg_2 = static_cast < QRect * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawPixmap((const QPoint &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1, (const QRect &)*cpp_arg_2));
      }
#endif

#endif

#endif

    }
  }
  ///const QPointF &p, const QPixmap &pm
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QPointF
#ifdef PHP_QT_QPixmap
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPixmap' is not static");
          RETURN_NULL();
        }
        /// try const QPointF &p, const QPixmap &pm,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
        QPixmap *
          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawPixmap((const QPointF &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  ///const QPoint &p, const QPixmap &pm
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
#ifdef PHP_QT_QPixmap
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPixmap' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &p, const QPixmap &pm,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
        QPixmap *
          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawPixmap((const QPoint &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  ///int x, int y, const QPixmap &pm
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QPixmap
      if (inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPixmap' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, const QPixmap &pm,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPixmap *
          cpp_arg_2 = static_cast < QPixmap * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QPixmap &)*cpp_arg_2));
      }
#endif

    }
  }
  ///const QRect &r, const QPixmap &pm
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QRect
#ifdef PHP_QT_QPixmap
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPixmap' is not static");
          RETURN_NULL();
        }
        /// try const QRect &r, const QPixmap &pm,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
        QPixmap *
          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawPixmap((const QRect &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  ///int x, int y, int w, int h, const QPixmap &pm
  if (ZEND_NUM_ARGS() == 5) {
    PHP_QT_FETCH_5_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
        Z_TYPE_P(arg_4) == IS_OBJECT) {
#ifdef PHP_QT_QPixmap
      if (inherits(Z_OBJCE_P(arg_4), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPixmap' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, int w, int h, const QPixmap &pm,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPixmap *
          cpp_arg_4 = static_cast < QPixmap * >(php_qt_fetch(arg_4));

        RETURN_VOID(selfpointer->
                    drawPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QPixmap &)*cpp_arg_4));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawPixmap(...) ");
}

/*!
 * method drawPolyline
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPointF *pointss0
 * @param	 int pointCounts1
 * 
 * overloaded args:
 * @param	const QPolygonF &polyline
 * 
 * overloaded args:
 * @param	const QPoint *points
 * @param	 int pointCount
 * 
 * overloaded args:
 * @param	const QPolygon &polygon
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawPolyline)
{
  ///const QPointF *pointss0, int pointCounts1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QPointF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPolyline' is not static");
          RETURN_NULL();
        }
        /// try const QPointF *pointss0, int pointCounts1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPolyline((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QPolygonF &polyline
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPolygonF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPolyline' is not static");
          RETURN_NULL();
        }
        /// try const QPolygonF &polyline,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPolygonF *
          cpp_arg_0 = static_cast < QPolygonF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPolyline((const QPolygonF &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QPoint *points, int pointCount
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPolyline' is not static");
          RETURN_NULL();
        }
        /// try const QPoint *points, int pointCount,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPolyline((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QPolygon &polygon
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPolygon
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPolyline' is not static");
          RETURN_NULL();
        }
        /// try const QPolygon &polygon,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPolygon *
          cpp_arg_0 = static_cast < QPolygon * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPolyline((const QPolygon &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawPolyline(...) ");
}

/*!
 * method deviceMatrix
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const QMatrix &
 * @flags	c
 */

ZEND_METHOD(QPainter, deviceMatrix)
{
  ///
#ifdef PHP_QT_QMatrix           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'deviceMatrix' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = &const_cast < QMatrix & >(selfpointer->deviceMatrix());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QPainter::deviceMatrix(...) ");
}

/*!
 * method drawLine
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QLineF &lines0
 * 
 * overloaded args:
 * @param	const QLine &line
 * 
 * overloaded args:
 * @param	int x1
 * @param	 int y1
 * @param	 int x2
 * @param	 int y2
 * 
 * overloaded args:
 * @param	const QPoint &p1
 * @param	 const QPoint &p2
 * 
 * overloaded args:
 * @param	const QPointF &p1
 * @param	 const QPointF &p2
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawLine)
{
  ///const QLineF &lines0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QLineF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawLine' is not static");
          RETURN_NULL();
        }
        /// try const QLineF &lines0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QLineF *
          cpp_arg_0 = static_cast < QLineF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawLine((const QLineF &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QLine &line
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QLine
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawLine' is not static");
          RETURN_NULL();
        }
        /// try const QLine &line,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QLine *
          cpp_arg_0 = static_cast < QLine * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawLine((const QLine &)*cpp_arg_0));
      }
#endif

    }
  }
  ///int x1, int y1, int x2, int y2
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'drawLine' is not static");
        RETURN_NULL();
      }
      /// try int x1, int y1, int x2, int y2,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->drawLine((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
    }
  }
  ///const QPoint &p1, const QPoint &p2
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawLine' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &p1, const QPoint &p2,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
        QPoint *
          cpp_arg_1 = static_cast < QPoint * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawLine((const QPoint &)*cpp_arg_0, (const QPoint &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  ///const QPointF &p1, const QPointF &p2
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QPointF
#ifdef PHP_QT_QPointF
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawLine' is not static");
          RETURN_NULL();
        }
        /// try const QPointF &p1, const QPointF &p2,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
        QPointF *
          cpp_arg_1 = static_cast < QPointF * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawLine((const QPointF &)*cpp_arg_0, (const QPointF &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawLine(...) ");
}

/*!
 * method fillRect
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRectF &s0
 * @param	 const QBrush &s1
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 int w
 * @param	 int h
 * @param	 const QBrush &
 * 
 * overloaded args:
 * @param	const QRect &
 * @param	 const QBrush &
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, fillRect)
{
  ///const QRectF &s0, const QBrush &s1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
#ifdef PHP_QT_QBrush
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'fillRect' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &s0, const QBrush &s1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
        QBrush *
          cpp_arg_1 = static_cast < QBrush * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->fillRect((const QRectF &)*cpp_arg_0, (const QBrush &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  ///int x, int y, int w, int h, const QBrush &
  if (ZEND_NUM_ARGS() == 5) {
    PHP_QT_FETCH_5_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
        Z_TYPE_P(arg_4) == IS_OBJECT) {
#ifdef PHP_QT_QBrush
      if (inherits(Z_OBJCE_P(arg_4), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'fillRect' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, int w, int h, const QBrush &,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QBrush *
          cpp_arg_4 = static_cast < QBrush * >(php_qt_fetch(arg_4));

        RETURN_VOID(selfpointer->fillRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QBrush &)*cpp_arg_4));
      }
#endif

    }
  }
  ///const QRect &, const QBrush &
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QRect
#ifdef PHP_QT_QBrush
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'fillRect' is not static");
          RETURN_NULL();
        }
        /// try const QRect &, const QBrush &,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
        QBrush *
          cpp_arg_1 = static_cast < QBrush * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->fillRect((const QRect &)*cpp_arg_0, (const QBrush &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::fillRect(...) ");
}

/*!
 * method boundingRect
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRectF &rects0
 * @param	 int flagss1
 * @param	 const QString &texts2
 * 
 * overloaded args:
 * @param	const QRect &rect
 * @param	 int flags
 * @param	 const QString &text
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 int w
 * @param	 int h
 * @param	 int flags
 * @param	 const QString &text
 * 
 * overloaded args:
 * @param	const QRectF &rect
 * @param	 const QString &text
 * @param	 const QTextOption &o = QTextOption()
 * 
 * @access	public
 * @return	QRectF
 * @flags	
 */

ZEND_METHOD(QPainter, boundingRect)
{
  ///const QRectF &rects0, int flagss1, const QString &texts2
#ifdef PHP_QT_QRectF            // return type

  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    arg_2 = invokeToQString(arg_2);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_2), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'boundingRect' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &rects0, int flagss1, const QString &texts2,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
        QString *
          cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));
        zend_class_entry *
          ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry
          le;
        QRectF *
          return_object = new QRectF;

        *return_object = static_cast < QRectF > (selfpointer->boundingRect((const QRectF &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &)*cpp_arg_2));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
#endif // return type


  ///const QRect &rect, int flags, const QString &text
#ifdef PHP_QT_QRect             // return type

  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    arg_2 = invokeToQString(arg_2);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QRect
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_2), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'boundingRect' is not static");
          RETURN_NULL();
        }
        /// try const QRect &rect, int flags, const QString &text,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
        QString *
          cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));
        zend_class_entry *
          ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry
          le;
        QRect *
          return_object = new QRect;

        *return_object = static_cast < QRect > (selfpointer->boundingRect((const QRect &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &)*cpp_arg_2));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
#endif // return type


  ///int x, int y, int w, int h, int flags, const QString &text
#ifdef PHP_QT_QRect             // return type

  if (ZEND_NUM_ARGS() == 6) {
    PHP_QT_FETCH_6_ARGS();
    arg_5 = invokeToQString(arg_5);

    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG
        && Z_TYPE_P(arg_5) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_5), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'boundingRect' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, int w, int h, int flags, const QString &text,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QString *
          cpp_arg_5 = static_cast < QString * >(php_qt_fetch(arg_5));
        zend_class_entry *
          ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry
          le;
        QRect *
          return_object = new QRect;

        *return_object =
          static_cast < QRect >
          (selfpointer->
           boundingRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
                        (const QString &)*cpp_arg_5));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///const QRectF &rect, const QString &text, const QTextOption &o = QTextOption()
#ifdef PHP_QT_QRectF            // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_1 = invokeToQString(arg_1);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'boundingRect' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &rect, const QString &text,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
        QString *
          cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
        zend_class_entry *
          ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry
          le;
        QRectF *
          return_object = new QRectF;

        *return_object = static_cast < QRectF > (selfpointer->boundingRect((const QRectF &)*cpp_arg_0, (const QString &)*cpp_arg_1));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    arg_1 = invokeToQString(arg_1);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'boundingRect' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &rect, const QString &text, const QTextOption &o = QTextOption(),
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
        QString *
          cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
        QTextOption *
          cpp_arg_2 = static_cast < QTextOption * >(php_qt_fetch(arg_2));
        zend_class_entry *
          ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry
          le;
        QRectF *
          return_object = new QRectF;

        *return_object =
          static_cast < QRectF > (selfpointer->boundingRect((const QRectF &)*cpp_arg_0, (const QString &)*cpp_arg_1, (const QTextOption &)*cpp_arg_2));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QPainter::boundingRect(...) ");
}

/*!
 * method setClipRect
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRectF &s0
 * @param	 Qt::ClipOperation op = Qt::ReplaceClips1
 * 
 * overloaded args:
 * @param	const QRect &
 * @param	 Qt::ClipOperation op = Qt::ReplaceClip
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 int w
 * @param	 int h
 * @param	 Qt::ClipOperation op = Qt::ReplaceClip
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setClipRect)
{
  ///const QRectF &s0, Qt::ClipOperation op = Qt::ReplaceClips1
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setClipRect' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &s0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setClipRect((const QRectF &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setClipRect' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &s0, Qt::ClipOperation op = Qt::ReplaceClips1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setClipRect((const QRectF &)*cpp_arg_0, (Qt::ClipOperation) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QRect &, Qt::ClipOperation op = Qt::ReplaceClip
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setClipRect' is not static");
          RETURN_NULL();
        }
        /// try const QRect &,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setClipRect((const QRect &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setClipRect' is not static");
          RETURN_NULL();
        }
        /// try const QRect &, Qt::ClipOperation op = Qt::ReplaceClip,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setClipRect((const QRect &)*cpp_arg_0, (Qt::ClipOperation) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///int x, int y, int w, int h, Qt::ClipOperation op = Qt::ReplaceClip
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setClipRect' is not static");
        RETURN_NULL();
      }
      /// try int x, int y, int w, int h,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setClipRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
    }
  }
  if (ZEND_NUM_ARGS() == 5) {
    PHP_QT_FETCH_5_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setClipRect' is not static");
        RETURN_NULL();
      }
      /// try int x, int y, int w, int h, Qt::ClipOperation op = Qt::ReplaceClip,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->
                  setClipRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (Qt::ClipOperation) Z_LVAL_P(arg_4)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::setClipRect(...) ");
}

/*!
 * method drawImage
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRectF &targetRects0
 * @param	 const QImage &images1
 * @param	 const QRectF &sourceRects2
 * @param	 Qt::ImageConversionFlags flags = Qt::AutoColors3
 * 
 * overloaded args:
 * @param	const QRect &targetRect
 * @param	 const QImage &image
 * @param	 const QRect &sourceRect
 * @param	 Qt::ImageConversionFlags flags = Qt::AutoColor
 * 
 * overloaded args:
 * @param	const QPointF &p
 * @param	 const QImage &image
 * @param	 const QRectF &sr
 * @param	 Qt::ImageConversionFlags flags = Qt::AutoColor
 * 
 * overloaded args:
 * @param	const QPoint &p
 * @param	 const QImage &image
 * @param	 const QRect &sr
 * @param	 Qt::ImageConversionFlags flags = Qt::AutoColor
 * 
 * overloaded args:
 * @param	const QRectF &r
 * @param	 const QImage &image
 * 
 * overloaded args:
 * @param	const QRect &r
 * @param	 const QImage &image
 * 
 * overloaded args:
 * @param	const QPointF &p
 * @param	 const QImage &image
 * 
 * overloaded args:
 * @param	const QPoint &p
 * @param	 const QImage &image
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 const QImage &image
 * @param	 int sx = 0
 * @param	 int sy = 0
 * @param	 int sw = -1
 * @param	 int sh = -1
 * @param	 Qt::ImageConversionFlags flags = Qt::AutoColor
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawImage)
{
  ///const QRectF &targetRects0, const QImage &images1, const QRectF &sourceRects2, Qt::ImageConversionFlags flags = Qt::AutoColors3
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
#ifdef PHP_QT_QImage
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &targetRects0, const QImage &images1, const QRectF &sourceRects2,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
        QImage *
          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
        QRectF *
          cpp_arg_2 = static_cast < QRectF * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawImage((const QRectF &)*cpp_arg_0, (const QImage &)*cpp_arg_1, (const QRectF &)*cpp_arg_2));
      }
#endif

#endif

#endif

    }
  }
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG) {
#ifdef PHP_QT_QRectF
#ifdef PHP_QT_QImage
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &targetRects0, const QImage &images1, const QRectF &sourceRects2, Qt::ImageConversionFlags flags = Qt::AutoColors3,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
        QImage *
          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
        QRectF *
          cpp_arg_2 = static_cast < QRectF * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->
                    drawImage((const QRectF &)*cpp_arg_0, (const QImage &)*cpp_arg_1, (const QRectF &)*cpp_arg_2, (Qt::ImageConversionFlags) Z_LVAL_P(arg_3)));
      }
#endif

#endif

#endif

    }
  }
  ///const QRect &targetRect, const QImage &image, const QRect &sourceRect, Qt::ImageConversionFlags flags = Qt::AutoColor
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QRect
#ifdef PHP_QT_QImage
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try const QRect &targetRect, const QImage &image, const QRect &sourceRect,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
        QImage *
          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
        QRect *
          cpp_arg_2 = static_cast < QRect * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawImage((const QRect &)*cpp_arg_0, (const QImage &)*cpp_arg_1, (const QRect &)*cpp_arg_2));
      }
#endif

#endif

#endif

    }
  }
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG) {
#ifdef PHP_QT_QRect
#ifdef PHP_QT_QImage
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try const QRect &targetRect, const QImage &image, const QRect &sourceRect, Qt::ImageConversionFlags flags = Qt::AutoColor,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
        QImage *
          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
        QRect *
          cpp_arg_2 = static_cast < QRect * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->
                    drawImage((const QRect &)*cpp_arg_0, (const QImage &)*cpp_arg_1, (const QRect &)*cpp_arg_2, (Qt::ImageConversionFlags) Z_LVAL_P(arg_3)));
      }
#endif

#endif

#endif

    }
  }
  ///const QPointF &p, const QImage &image, const QRectF &sr, Qt::ImageConversionFlags flags = Qt::AutoColor
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QPointF
#ifdef PHP_QT_QImage
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try const QPointF &p, const QImage &image, const QRectF &sr,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
        QImage *
          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
        QRectF *
          cpp_arg_2 = static_cast < QRectF * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawImage((const QPointF &)*cpp_arg_0, (const QImage &)*cpp_arg_1, (const QRectF &)*cpp_arg_2));
      }
#endif

#endif

#endif

    }
  }
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG) {
#ifdef PHP_QT_QPointF
#ifdef PHP_QT_QImage
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try const QPointF &p, const QImage &image, const QRectF &sr, Qt::ImageConversionFlags flags = Qt::AutoColor,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
        QImage *
          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
        QRectF *
          cpp_arg_2 = static_cast < QRectF * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->
                    drawImage((const QPointF &)*cpp_arg_0, (const QImage &)*cpp_arg_1, (const QRectF &)*cpp_arg_2, (Qt::ImageConversionFlags) Z_LVAL_P(arg_3)));
      }
#endif

#endif

#endif

    }
  }
  ///const QPoint &p, const QImage &image, const QRect &sr, Qt::ImageConversionFlags flags = Qt::AutoColor
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
#ifdef PHP_QT_QImage
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &p, const QImage &image, const QRect &sr,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
        QImage *
          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
        QRect *
          cpp_arg_2 = static_cast < QRect * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawImage((const QPoint &)*cpp_arg_0, (const QImage &)*cpp_arg_1, (const QRect &)*cpp_arg_2));
      }
#endif

#endif

#endif

    }
  }
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG) {
#ifdef PHP_QT_QPoint
#ifdef PHP_QT_QImage
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0) && inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &p, const QImage &image, const QRect &sr, Qt::ImageConversionFlags flags = Qt::AutoColor,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
        QImage *
          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));
        QRect *
          cpp_arg_2 = static_cast < QRect * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->
                    drawImage((const QPoint &)*cpp_arg_0, (const QImage &)*cpp_arg_1, (const QRect &)*cpp_arg_2, (Qt::ImageConversionFlags) Z_LVAL_P(arg_3)));
      }
#endif

#endif

#endif

    }
  }
  ///const QRectF &r, const QImage &image
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
#ifdef PHP_QT_QImage
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &r, const QImage &image,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
        QImage *
          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawImage((const QRectF &)*cpp_arg_0, (const QImage &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  ///const QRect &r, const QImage &image
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QRect
#ifdef PHP_QT_QImage
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try const QRect &r, const QImage &image,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
        QImage *
          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawImage((const QRect &)*cpp_arg_0, (const QImage &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  ///const QPointF &p, const QImage &image
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QPointF
#ifdef PHP_QT_QImage
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try const QPointF &p, const QImage &image,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
        QImage *
          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawImage((const QPointF &)*cpp_arg_0, (const QImage &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  ///const QPoint &p, const QImage &image
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
#ifdef PHP_QT_QImage
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &p, const QImage &image,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
        QImage *
          cpp_arg_1 = static_cast < QImage * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawImage((const QPoint &)*cpp_arg_0, (const QImage &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  ///int x, int y, const QImage &image, int sx = 0, int sy = 0, int sw = -1, int sh = -1, Qt::ImageConversionFlags flags = Qt::AutoColor
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QImage
      if (inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, const QImage &image,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QImage *
          cpp_arg_2 = static_cast < QImage * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &)*cpp_arg_2));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG) {
#ifdef PHP_QT_QImage
      if (inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, const QImage &image, int sx = 0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QImage *
          cpp_arg_2 = static_cast < QImage * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &)*cpp_arg_2, (int)Z_LVAL_P(arg_3)));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 5) {
    PHP_QT_FETCH_5_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG &&
        Z_TYPE_P(arg_4) == IS_LONG) {
#ifdef PHP_QT_QImage
      if (inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, const QImage &image, int sx = 0, int sy = 0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QImage *
          cpp_arg_2 = static_cast < QImage * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &)*cpp_arg_2, (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4)));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 6) {
    PHP_QT_FETCH_6_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG &&
        Z_TYPE_P(arg_4) == IS_LONG && Z_TYPE_P(arg_5) == IS_LONG) {
#ifdef PHP_QT_QImage
      if (inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, const QImage &image, int sx = 0, int sy = 0, int sw = -1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QImage *
          cpp_arg_2 = static_cast < QImage * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->
                    drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &)*cpp_arg_2, (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
                              (int)Z_LVAL_P(arg_5)));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 7) {
    PHP_QT_FETCH_7_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG &&
        Z_TYPE_P(arg_4) == IS_LONG && Z_TYPE_P(arg_5) == IS_LONG && Z_TYPE_P(arg_6) == IS_LONG) {
#ifdef PHP_QT_QImage
      if (inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, const QImage &image, int sx = 0, int sy = 0, int sw = -1, int sh = -1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QImage *
          cpp_arg_2 = static_cast < QImage * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->
                    drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &)*cpp_arg_2, (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
                              (int)Z_LVAL_P(arg_5), (int)Z_LVAL_P(arg_6)));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 8) {
    PHP_QT_FETCH_8_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG &&
        Z_TYPE_P(arg_4) == IS_LONG && Z_TYPE_P(arg_5) == IS_LONG && Z_TYPE_P(arg_6) == IS_LONG && Z_TYPE_P(arg_7) == IS_LONG) {
#ifdef PHP_QT_QImage
      if (inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawImage' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, const QImage &image, int sx = 0, int sy = 0, int sw = -1, int sh = -1, Qt::ImageConversionFlags flags = Qt::AutoColor,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QImage *
          cpp_arg_2 = static_cast < QImage * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->
                    drawImage((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QImage &)*cpp_arg_2, (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
                              (int)Z_LVAL_P(arg_5), (int)Z_LVAL_P(arg_6), (Qt::ImageConversionFlags) Z_LVAL_P(arg_7)));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawImage(...) ");
}

/*!
 * method drawTiledPixmap
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRectF &rects0
 * @param	 const QPixmap &pms1
 * @param	 const QPointF &offset = QPointF()s2
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 int w
 * @param	 int h
 * @param	 const QPixmap &
 * @param	 int sx=0
 * @param	 int sy=0
 * 
 * overloaded args:
 * @param	const QRect &
 * @param	 const QPixmap &
 * @param	 const QPoint & = QPoint()
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawTiledPixmap)
{
  ///const QRectF &rects0, const QPixmap &pms1, const QPointF &offset = QPointF()s2
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
#ifdef PHP_QT_QPixmap
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawTiledPixmap' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &rects0, const QPixmap &pms1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
        QPixmap *
          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawTiledPixmap((const QRectF &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
#ifdef PHP_QT_QPixmap
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawTiledPixmap' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &rects0, const QPixmap &pms1, const QPointF &offset = QPointF()s2,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
        QPixmap *
          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));
        QPointF *
          cpp_arg_2 = static_cast < QPointF * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawTiledPixmap((const QRectF &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1, (const QPointF &)*cpp_arg_2));
      }
#endif

#endif

    }
  }
  ///int x, int y, int w, int h, const QPixmap &, int sx=0, int sy=0
  if (ZEND_NUM_ARGS() == 5) {
    PHP_QT_FETCH_5_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
        Z_TYPE_P(arg_4) == IS_OBJECT) {
#ifdef PHP_QT_QPixmap
      if (inherits(Z_OBJCE_P(arg_4), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawTiledPixmap' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, int w, int h, const QPixmap &,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPixmap *
          cpp_arg_4 = static_cast < QPixmap * >(php_qt_fetch(arg_4));

        RETURN_VOID(selfpointer->
                    drawTiledPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QPixmap &)*cpp_arg_4));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 6) {
    PHP_QT_FETCH_6_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
        Z_TYPE_P(arg_4) == IS_OBJECT && Z_TYPE_P(arg_5) == IS_LONG) {
#ifdef PHP_QT_QPixmap
      if (inherits(Z_OBJCE_P(arg_4), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawTiledPixmap' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, int w, int h, const QPixmap &, int sx=0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPixmap *
          cpp_arg_4 = static_cast < QPixmap * >(php_qt_fetch(arg_4));

        RETURN_VOID(selfpointer->
                    drawTiledPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QPixmap &)*cpp_arg_4,
                                    (int)Z_LVAL_P(arg_5)));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 7) {
    PHP_QT_FETCH_7_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG &&
        Z_TYPE_P(arg_4) == IS_OBJECT && Z_TYPE_P(arg_5) == IS_LONG && Z_TYPE_P(arg_6) == IS_LONG) {
#ifdef PHP_QT_QPixmap
      if (inherits(Z_OBJCE_P(arg_4), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawTiledPixmap' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, int w, int h, const QPixmap &, int sx=0, int sy=0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPixmap *
          cpp_arg_4 = static_cast < QPixmap * >(php_qt_fetch(arg_4));

        RETURN_VOID(selfpointer->
                    drawTiledPixmap((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (const QPixmap &)*cpp_arg_4,
                                    (int)Z_LVAL_P(arg_5), (int)Z_LVAL_P(arg_6)));
      }
#endif

    }
  }
  ///const QRect &, const QPixmap &, const QPoint & = QPoint()
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QRect
#ifdef PHP_QT_QPixmap
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawTiledPixmap' is not static");
          RETURN_NULL();
        }
        /// try const QRect &, const QPixmap &,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
        QPixmap *
          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawTiledPixmap((const QRect &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QRect
#ifdef PHP_QT_QPixmap
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawTiledPixmap' is not static");
          RETURN_NULL();
        }
        /// try const QRect &, const QPixmap &, const QPoint & = QPoint(),
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
        QPixmap *
          cpp_arg_1 = static_cast < QPixmap * >(php_qt_fetch(arg_1));
        QPoint *
          cpp_arg_2 = static_cast < QPoint * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawTiledPixmap((const QRect &)*cpp_arg_0, (const QPixmap &)*cpp_arg_1, (const QPoint &)*cpp_arg_2));
      }
#endif

#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawTiledPixmap(...) ");
}

/*!
 * method layoutDirection
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Qt::LayoutDirection
 * @flags	c
 */

ZEND_METHOD(QPainter, layoutDirection)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'layoutDirection' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->layoutDirection());
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::layoutDirection(...) ");
}

/*!
 * method background
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const QBrush &
 * @flags	c
 */

ZEND_METHOD(QPainter, background)
{
  ///
#ifdef PHP_QT_QBrush            // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'background' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = &const_cast < QBrush & >(selfpointer->background());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QPainter::background(...) ");
}

/*!
 * method drawPolygon
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPointF *pointss0
 * @param	 int pointCounts1
 * @param	 Qt::FillRule fillRule = Qt::OddEvenFills2
 * 
 * overloaded args:
 * @param	const QPolygonF &polygon
 * @param	 Qt::FillRule fillRule = Qt::OddEvenFill
 * 
 * overloaded args:
 * @param	const QPoint *points
 * @param	 int pointCount
 * @param	 Qt::FillRule fillRule = Qt::OddEvenFill
 * 
 * overloaded args:
 * @param	const QPolygon &polygon
 * @param	 Qt::FillRule fillRule = Qt::OddEvenFill
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawPolygon)
{
  ///const QPointF *pointss0, int pointCounts1, Qt::FillRule fillRule = Qt::OddEvenFills2
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QPointF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPolygon' is not static");
          RETURN_NULL();
        }
        /// try const QPointF *pointss0, int pointCounts1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPolygon((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QPointF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPolygon' is not static");
          RETURN_NULL();
        }
        /// try const QPointF *pointss0, int pointCounts1, Qt::FillRule fillRule = Qt::OddEvenFills2,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPolygon((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::FillRule) Z_LVAL_P(arg_2)));
      }
#endif

    }
  }
  ///const QPolygonF &polygon, Qt::FillRule fillRule = Qt::OddEvenFill
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPolygonF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPolygon' is not static");
          RETURN_NULL();
        }
        /// try const QPolygonF &polygon,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPolygonF *
          cpp_arg_0 = static_cast < QPolygonF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPolygon((const QPolygonF &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QPolygonF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPolygon' is not static");
          RETURN_NULL();
        }
        /// try const QPolygonF &polygon, Qt::FillRule fillRule = Qt::OddEvenFill,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPolygonF *
          cpp_arg_0 = static_cast < QPolygonF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPolygon((const QPolygonF &)*cpp_arg_0, (Qt::FillRule) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QPoint *points, int pointCount, Qt::FillRule fillRule = Qt::OddEvenFill
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPolygon' is not static");
          RETURN_NULL();
        }
        /// try const QPoint *points, int pointCount,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPolygon((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPolygon' is not static");
          RETURN_NULL();
        }
        /// try const QPoint *points, int pointCount, Qt::FillRule fillRule = Qt::OddEvenFill,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPolygon((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::FillRule) Z_LVAL_P(arg_2)));
      }
#endif

    }
  }
  ///const QPolygon &polygon, Qt::FillRule fillRule = Qt::OddEvenFill
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPolygon
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPolygon' is not static");
          RETURN_NULL();
        }
        /// try const QPolygon &polygon,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPolygon *
          cpp_arg_0 = static_cast < QPolygon * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPolygon((const QPolygon &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QPolygon
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPolygon' is not static");
          RETURN_NULL();
        }
        /// try const QPolygon &polygon, Qt::FillRule fillRule = Qt::OddEvenFill,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPolygon *
          cpp_arg_0 = static_cast < QPolygon * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPolygon((const QPolygon &)*cpp_arg_0, (Qt::FillRule) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawPolygon(...) ");
}

/*!
 * method setClipRegion
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRegion &s0
 * @param	 Qt::ClipOperation op = Qt::ReplaceClips1
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setClipRegion)
{
  ///const QRegion &s0, Qt::ClipOperation op = Qt::ReplaceClips1
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRegion
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setClipRegion' is not static");
          RETURN_NULL();
        }
        /// try const QRegion &s0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRegion *
          cpp_arg_0 = static_cast < QRegion * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setClipRegion((const QRegion &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QRegion
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setClipRegion' is not static");
          RETURN_NULL();
        }
        /// try const QRegion &s0, Qt::ClipOperation op = Qt::ReplaceClips1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRegion *
          cpp_arg_0 = static_cast < QRegion * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setClipRegion((const QRegion &)*cpp_arg_0, (Qt::ClipOperation) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::setClipRegion(...) ");
}

/*!
 * method device
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QPaintDevice *
 * @flags	c
 */

ZEND_METHOD(QPainter, device)
{
  ///
#ifdef PHP_QT_QPaintDevice      // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'device' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = static_cast < QPaintDevice * >(selfpointer->device());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QPainter::device(...) ");
}

/*!
 * method restoreRedirected
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPaintDevice *devices0
 * 
 * @access	public
 * @return	void
 * @flags	s
 */

ZEND_METHOD(QPainter, restoreRedirected)
{
  ///const QPaintDevice *devices0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPaintDevice
      if (inherits(Z_OBJCE_P(arg_0), 49)) {
        /// try const QPaintDevice *devices0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPaintDevice *
          cpp_arg_0 = static_cast < QPaintDevice * >(php_qt_fetch(arg_0));

        if (getThis() == NULL) {
          RETURN_VOID(QPainter::restoreRedirected((const QPaintDevice *)cpp_arg_0));
        } else {
          RETURN_VOID(selfpointer->restoreRedirected((const QPaintDevice *)cpp_arg_0));
      }}
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::restoreRedirected(...) ");
}

/*!
 * method setMatrixEnabled
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool enableds0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setMatrixEnabled)
{
  ///bool enableds0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setMatrixEnabled' is not static");
        RETURN_NULL();
      }
      /// try bool enableds0,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setMatrixEnabled((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::setMatrixEnabled(...) ");
}

/*!
 * method drawPoints
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPointF *pointss0
 * @param	 int pointCounts1
 * 
 * overloaded args:
 * @param	const QPolygonF &points
 * 
 * overloaded args:
 * @param	const QPoint *points
 * @param	 int pointCount
 * 
 * overloaded args:
 * @param	const QPolygon &points
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawPoints)
{
  ///const QPointF *pointss0, int pointCounts1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QPointF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPoints' is not static");
          RETURN_NULL();
        }
        /// try const QPointF *pointss0, int pointCounts1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPoints((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QPolygonF &points
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPolygonF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPoints' is not static");
          RETURN_NULL();
        }
        /// try const QPolygonF &points,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPolygonF *
          cpp_arg_0 = static_cast < QPolygonF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPoints((const QPolygonF &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QPoint *points, int pointCount
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPoints' is not static");
          RETURN_NULL();
        }
        /// try const QPoint *points, int pointCount,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPoints((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QPolygon &points
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPolygon
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPoints' is not static");
          RETURN_NULL();
        }
        /// try const QPolygon &points,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPolygon *
          cpp_arg_0 = static_cast < QPolygon * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPoints((const QPolygon &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawPoints(...) ");
}

/*!
 * method drawRoundRect
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRectF &rs0
 * @param	 int xround = 25s1
 * @param	 int yround = 25s2
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 int w
 * @param	 int h
 * @param	 int = 25
 * @param	 int = 25
 * 
 * overloaded args:
 * @param	const QRect &r
 * @param	 int xround = 25
 * @param	 int yround = 25
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawRoundRect)
{
  ///const QRectF &rs0, int xround = 25s1, int yround = 25s2
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawRoundRect' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &rs0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawRoundRect((const QRectF &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawRoundRect' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &rs0, int xround = 25s1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawRoundRect((const QRectF &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawRoundRect' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &rs0, int xround = 25s1, int yround = 25s2,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawRoundRect((const QRectF &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
      }
#endif

    }
  }
  ///int x, int y, int w, int h, int = 25, int = 25
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'drawRoundRect' is not static");
        RETURN_NULL();
      }
      /// try int x, int y, int w, int h,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->drawRoundRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
    }
  }
  if (ZEND_NUM_ARGS() == 5) {
    PHP_QT_FETCH_5_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'drawRoundRect' is not static");
        RETURN_NULL();
      }
      /// try int x, int y, int w, int h, int = 25,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->drawRoundRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4)));
    }
  }
  if (ZEND_NUM_ARGS() == 6) {
    PHP_QT_FETCH_6_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG
        && Z_TYPE_P(arg_5) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'drawRoundRect' is not static");
        RETURN_NULL();
      }
      /// try int x, int y, int w, int h, int = 25, int = 25,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->
                  drawRoundRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
                                (int)Z_LVAL_P(arg_5)));
    }
  }
  ///const QRect &r, int xround = 25, int yround = 25
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawRoundRect' is not static");
          RETURN_NULL();
        }
        /// try const QRect &r,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawRoundRect((const QRect &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawRoundRect' is not static");
          RETURN_NULL();
        }
        /// try const QRect &r, int xround = 25,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawRoundRect((const QRect &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawRoundRect' is not static");
          RETURN_NULL();
        }
        /// try const QRect &r, int xround = 25, int yround = 25,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawRoundRect((const QRect &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawRoundRect(...) ");
}

/*!
 * method drawConvexPolygon
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPointF *pointss0
 * @param	 int pointCounts1
 * 
 * overloaded args:
 * @param	const QPolygonF &polygon
 * 
 * overloaded args:
 * @param	const QPoint *points
 * @param	 int pointCount
 * 
 * overloaded args:
 * @param	const QPolygon &polygon
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawConvexPolygon)
{
  ///const QPointF *pointss0, int pointCounts1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QPointF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawConvexPolygon' is not static");
          RETURN_NULL();
        }
        /// try const QPointF *pointss0, int pointCounts1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawConvexPolygon((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QPolygonF &polygon
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPolygonF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawConvexPolygon' is not static");
          RETURN_NULL();
        }
        /// try const QPolygonF &polygon,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPolygonF *
          cpp_arg_0 = static_cast < QPolygonF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawConvexPolygon((const QPolygonF &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QPoint *points, int pointCount
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawConvexPolygon' is not static");
          RETURN_NULL();
        }
        /// try const QPoint *points, int pointCount,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawConvexPolygon((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QPolygon &polygon
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPolygon
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawConvexPolygon' is not static");
          RETURN_NULL();
        }
        /// try const QPolygon &polygon,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPolygon *
          cpp_arg_0 = static_cast < QPolygon * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawConvexPolygon((const QPolygon &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawConvexPolygon(...) ");
}

/*!
 * method drawPicture
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPointF &ps0
 * @param	 const QPicture &pictures1
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 const QPicture &picture
 * 
 * overloaded args:
 * @param	const QPoint &p
 * @param	 const QPicture &picture
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawPicture)
{
  ///const QPointF &ps0, const QPicture &pictures1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QPointF
#ifdef PHP_QT_QPicture
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPicture' is not static");
          RETURN_NULL();
        }
        /// try const QPointF &ps0, const QPicture &pictures1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
        QPicture *
          cpp_arg_1 = static_cast < QPicture * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawPicture((const QPointF &)*cpp_arg_0, (const QPicture &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  ///int x, int y, const QPicture &picture
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QPicture
      if (inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPicture' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, const QPicture &picture,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPicture *
          cpp_arg_2 = static_cast < QPicture * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawPicture((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QPicture &)*cpp_arg_2));
      }
#endif

    }
  }
  ///const QPoint &p, const QPicture &picture
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
#ifdef PHP_QT_QPicture
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPicture' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &p, const QPicture &picture,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
        QPicture *
          cpp_arg_1 = static_cast < QPicture * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawPicture((const QPoint &)*cpp_arg_0, (const QPicture &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawPicture(...) ");
}

/*!
 * method setMatrix
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QMatrix &matrixs0
 * @param	 bool combine = falses1
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setMatrix)
{
  ///const QMatrix &matrixs0, bool combine = falses1
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QMatrix
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setMatrix' is not static");
          RETURN_NULL();
        }
        /// try const QMatrix &matrixs0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QMatrix *
          cpp_arg_0 = static_cast < QMatrix * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setMatrix((const QMatrix &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_BOOL) {
#ifdef PHP_QT_QMatrix
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setMatrix' is not static");
          RETURN_NULL();
        }
        /// try const QMatrix &matrixs0, bool combine = falses1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QMatrix *
          cpp_arg_0 = static_cast < QMatrix * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setMatrix((const QMatrix &)*cpp_arg_0, (bool) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::setMatrix(...) ");
}

/*!
 * method restore
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, restore)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'restore' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->restore());
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::restore(...) ");
}

/*!
 * method matrix
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const QMatrix &
 * @flags	c
 */

ZEND_METHOD(QPainter, matrix)
{
  ///
#ifdef PHP_QT_QMatrix           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'matrix' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = &const_cast < QMatrix & >(selfpointer->matrix());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QPainter::matrix(...) ");
}

/*!
 * method font
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const QFont &
 * @flags	c
 */

ZEND_METHOD(QPainter, font)
{
  ///
#ifdef PHP_QT_QFont             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'font' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = &const_cast < QFont & >(selfpointer->font());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QPainter::font(...) ");
}

/*!
 * method viewport
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QRect
 * @flags	c
 */

ZEND_METHOD(QPainter, viewport)
{
  ///
#ifdef PHP_QT_QRect             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'viewport' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QRect *
        return_object = new QRect;

      *return_object = static_cast < QRect > (selfpointer->viewport());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QPainter::viewport(...) ");
}

/*!
 * method viewTransformEnabled
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QPainter, viewTransformEnabled)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'viewTransformEnabled' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->viewTransformEnabled());
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::viewTransformEnabled(...) ");
}

/*!
 * method drawText
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPointF &ps0
 * @param	 const QString &ss1
 * 
 * overloaded args:
 * @param	const QPoint &p
 * @param	 const QString &s
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 const QString &s
 * 
 * overloaded args:
 * @param	const QRectF &r
 * @param	 int flags
 * @param	 const QString &text
 * @param	 QRectF *br=0
 * 
 * overloaded args:
 * @param	const QRect &r
 * @param	 int flags
 * @param	 const QString &text
 * @param	 QRect *br=0
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 int w
 * @param	 int h
 * @param	 int flags
 * @param	 const QString &text
 * @param	 QRect *br=0
 * 
 * overloaded args:
 * @param	const QRectF &r
 * @param	 const QString &text
 * @param	 const QTextOption &o = QTextOption()
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawText)
{
  ///const QPointF &ps0, const QString &ss1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_1 = invokeToQString(arg_1);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QPointF
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawText' is not static");
          RETURN_NULL();
        }
        /// try const QPointF &ps0, const QString &ss1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
        QString *
          cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawText((const QPointF &)*cpp_arg_0, (const QString &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  ///const QPoint &p, const QString &s
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_1 = invokeToQString(arg_1);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawText' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &p, const QString &s,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
        QString *
          cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawText((const QPoint &)*cpp_arg_0, (const QString &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  ///int x, int y, const QString &s
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    arg_2 = invokeToQString(arg_2);

    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_2), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawText' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, const QString &s,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QString *
          cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawText((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QString &)*cpp_arg_2));
      }
#endif

    }
  }
  ///const QRectF &r, int flags, const QString &text, QRectF *br=0
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    arg_2 = invokeToQString(arg_2);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_2), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawText' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &r, int flags, const QString &text,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
        QString *
          cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawText((const QRectF &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &)*cpp_arg_2));
      }
#endif

#endif

    }
  }
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    arg_2 = invokeToQString(arg_2);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_2), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawText' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &r, int flags, const QString &text, QRectF *br=0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
        QString *
          cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));
        QRectF *
          cpp_arg_3 = static_cast < QRectF * >(php_qt_fetch(arg_3));

        RETURN_VOID(selfpointer->drawText((const QRectF &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &)*cpp_arg_2, (QRectF *) cpp_arg_3));
      }
#endif

#endif

    }
  }
  ///const QRect &r, int flags, const QString &text, QRect *br=0
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    arg_2 = invokeToQString(arg_2);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QRect
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_2), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawText' is not static");
          RETURN_NULL();
        }
        /// try const QRect &r, int flags, const QString &text,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
        QString *
          cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawText((const QRect &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &)*cpp_arg_2));
      }
#endif

#endif

    }
  }
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    arg_2 = invokeToQString(arg_2);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_OBJECT) {
#ifdef PHP_QT_QRect
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_2), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawText' is not static");
          RETURN_NULL();
        }
        /// try const QRect &r, int flags, const QString &text, QRect *br=0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));
        QString *
          cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));
        QRect *
          cpp_arg_3 = static_cast < QRect * >(php_qt_fetch(arg_3));

        RETURN_VOID(selfpointer->drawText((const QRect &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QString &)*cpp_arg_2, (QRect *) cpp_arg_3));
      }
#endif

#endif

    }
  }
  ///int x, int y, int w, int h, int flags, const QString &text, QRect *br=0
  if (ZEND_NUM_ARGS() == 6) {
    PHP_QT_FETCH_6_ARGS();
    arg_5 = invokeToQString(arg_5);

    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG
        && Z_TYPE_P(arg_5) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_5), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawText' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, int w, int h, int flags, const QString &text,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QString *
          cpp_arg_5 = static_cast < QString * >(php_qt_fetch(arg_5));

        RETURN_VOID(selfpointer->
                    drawText((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
                             (const QString &)*cpp_arg_5));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 7) {
    PHP_QT_FETCH_7_ARGS();
    arg_5 = invokeToQString(arg_5);
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG
        && Z_TYPE_P(arg_5) == IS_OBJECT && Z_TYPE_P(arg_6) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_5), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawText' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, int w, int h, int flags, const QString &text, QRect *br=0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QString *
          cpp_arg_5 = static_cast < QString * >(php_qt_fetch(arg_5));
        QRect *
          cpp_arg_6 = static_cast < QRect * >(php_qt_fetch(arg_6));

        RETURN_VOID(selfpointer->
                    drawText((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
                             (const QString &)*cpp_arg_5, (QRect *) cpp_arg_6));
      }
#endif

    }
  }
  ///const QRectF &r, const QString &text, const QTextOption &o = QTextOption()
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_1 = invokeToQString(arg_1);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawText' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &r, const QString &text,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
        QString *
          cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawText((const QRectF &)*cpp_arg_0, (const QString &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    arg_1 = invokeToQString(arg_1);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawText' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &r, const QString &text, const QTextOption &o = QTextOption(),
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));
        QString *
          cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
        QTextOption *
          cpp_arg_2 = static_cast < QTextOption * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawText((const QRectF &)*cpp_arg_0, (const QString &)*cpp_arg_1, (const QTextOption &)*cpp_arg_2));
      }
#endif

#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawText(...) ");
}

/*!
 * method drawChord
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRectF &rects0
 * @param	 int as1
 * @param	 int alens2
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 int w
 * @param	 int h
 * @param	 int a
 * @param	 int alen
 * 
 * overloaded args:
 * @param	const QRect &
 * @param	 int a
 * @param	 int alen
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawChord)
{
  ///const QRectF &rects0, int as1, int alens2
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawChord' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &rects0, int as1, int alens2,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawChord((const QRectF &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
      }
#endif

    }
  }
  ///int x, int y, int w, int h, int a, int alen
  if (ZEND_NUM_ARGS() == 6) {
    PHP_QT_FETCH_6_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG
        && Z_TYPE_P(arg_5) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'drawChord' is not static");
        RETURN_NULL();
      }
      /// try int x, int y, int w, int h, int a, int alen,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->
                  drawChord((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4),
                            (int)Z_LVAL_P(arg_5)));
    }
  }
  ///const QRect &, int a, int alen
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawChord' is not static");
          RETURN_NULL();
        }
        /// try const QRect &, int a, int alen,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawChord((const QRect &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawChord(...) ");
}

/*!
 * method clipRegion
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QRegion
 * @flags	c
 */

ZEND_METHOD(QPainter, clipRegion)
{
  ///
#ifdef PHP_QT_QRegion           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'clipRegion' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QRegion *
        return_object = new QRegion;

      *return_object = static_cast < QRegion > (selfpointer->clipRegion());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QPainter::clipRegion(...) ");
}

/*!
 * method brushOrigin
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QPoint
 * @flags	c
 */

ZEND_METHOD(QPainter, brushOrigin)
{
  ///
#ifdef PHP_QT_QPoint            // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'brushOrigin' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QPoint *
        return_object = new QPoint;

      *return_object = static_cast < QPoint > (selfpointer->brushOrigin());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QPainter::brushOrigin(...) ");
}

/*!
 * method end
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	
 */

ZEND_METHOD(QPainter, end)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'end' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->end());
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::end(...) ");
}

/*!
 * method setViewTransformEnabled
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool enables0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setViewTransformEnabled)
{
  ///bool enables0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setViewTransformEnabled' is not static");
        RETURN_NULL();
      }
      /// try bool enables0,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setViewTransformEnabled((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::setViewTransformEnabled(...) ");
}

/*!
 * method scale
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	qreal sxs0
 * @param	 qreal sys1
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, scale)
{
// notice: unknown argument qreal sxs0, skipped
  php_error(E_ERROR, "could not parse argument in QPainter::scale(...) ");
}

/*!
 * method setPen
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QColor &colors0
 * 
 * overloaded args:
 * @param	const QPen &pen
 * 
 * overloaded args:
 * @param	Qt::PenStyle style
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setPen)
{
  ///const QColor &colors0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QColor
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setPen' is not static");
          RETURN_NULL();
        }
        /// try const QColor &colors0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QColor *
          cpp_arg_0 = static_cast < QColor * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setPen((const QColor &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QPen &pen
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPen
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setPen' is not static");
          RETURN_NULL();
        }
        /// try const QPen &pen,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPen *
          cpp_arg_0 = static_cast < QPen * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setPen((const QPen &)*cpp_arg_0));
      }
#endif

    }
  }
  ///Qt::PenStyle style
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setPen' is not static");
        RETURN_NULL();
      }
      /// try Qt::PenStyle style,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setPen((Qt::PenStyle) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::setPen(...) ");
}

/*!
 * method window
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QRect
 * @flags	c
 */

ZEND_METHOD(QPainter, window)
{
  ///
#ifdef PHP_QT_QRect             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'window' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QRect *
        return_object = new QRect;

      *return_object = static_cast < QRect > (selfpointer->window());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QPainter::window(...) ");
}

/*!
 * method setBackgroundMode
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::BGMode modes0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setBackgroundMode)
{
  ///Qt::BGMode modes0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setBackgroundMode' is not static");
        RETURN_NULL();
      }
      /// try Qt::BGMode modes0,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setBackgroundMode((Qt::BGMode) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::setBackgroundMode(...) ");
}

/*!
 * method paintEngine
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QPaintEngine *
 * @flags	c
 */

ZEND_METHOD(QPainter, paintEngine)
{
  ///
#ifdef PHP_QT_QPaintEngine      // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'paintEngine' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = static_cast < QPaintEngine * >(selfpointer->paintEngine());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QPainter::paintEngine(...) ");
}

/*!
 * method setRenderHint
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	RenderHint hints0
 * @param	 bool on = trues1
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setRenderHint)
{
// notice: unknown argument RenderHint hints0, skipped
  php_error(E_ERROR, "could not parse argument in QPainter::setRenderHint(...) ");
}

/*!
 * method strokePath
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPainterPath &paths0
 * @param	 const QPen &pens1
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, strokePath)
{
  ///const QPainterPath &paths0, const QPen &pens1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QPainterPath
#ifdef PHP_QT_QPen
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'strokePath' is not static");
          RETURN_NULL();
        }
        /// try const QPainterPath &paths0, const QPen &pens1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPainterPath *
          cpp_arg_0 = static_cast < QPainterPath * >(php_qt_fetch(arg_0));
        QPen *
          cpp_arg_1 = static_cast < QPen * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->strokePath((const QPainterPath &)*cpp_arg_0, (const QPen &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::strokePath(...) ");
}

/*!
 * method brush
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const QBrush &
 * @flags	c
 */

ZEND_METHOD(QPainter, brush)
{
  ///
#ifdef PHP_QT_QBrush            // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'brush' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;

      le.ptr = &const_cast < QBrush & >(selfpointer->brush());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QPainter::brush(...) ");
}

/*!
 * method setBrush
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QBrush &brushs0
 * 
 * overloaded args:
 * @param	Qt::BrushStyle style
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setBrush)
{
  ///const QBrush &brushs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QBrush
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setBrush' is not static");
          RETURN_NULL();
        }
        /// try const QBrush &brushs0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QBrush *
          cpp_arg_0 = static_cast < QBrush * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setBrush((const QBrush &)*cpp_arg_0));
      }
#endif

    }
  }
  ///Qt::BrushStyle style
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setBrush' is not static");
        RETURN_NULL();
      }
      /// try Qt::BrushStyle style,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setBrush((Qt::BrushStyle) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::setBrush(...) ");
}

/*!
 * method drawPoint
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPointF &pts0
 * 
 * overloaded args:
 * @param	const QPoint &p
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawPoint)
{
  ///const QPointF &pts0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPointF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPoint' is not static");
          RETURN_NULL();
        }
        /// try const QPointF &pts0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPoint((const QPointF &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QPoint &p
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawPoint' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &p,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawPoint((const QPoint &)*cpp_arg_0));
      }
#endif

    }
  }
  ///int x, int y
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'drawPoint' is not static");
        RETURN_NULL();
      }
      /// try int x, int y,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->drawPoint((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawPoint(...) ");
}

/*!
 * method QPainter
 * 
 * @param: -
 * @param: -
 * 
 * overloaded args:
 * @param	QPaintDevice *s0
 * 
 * @access	public
 * @return	
 * @flags	
 */

ZEND_METHOD(QPainter, __construct)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter_php_qt *
        selfpointer = new QPainter_php_qt(getThis());

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  ///QPaintDevice *s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPaintDevice
      if (inherits(Z_OBJCE_P(arg_0), 49)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try QPaintDevice *s0,
        QPaintDevice *
          cpp_arg_0 = static_cast < QPaintDevice * >(php_qt_fetch(arg_0));
        QPainter_php_qt *
          selfpointer = new QPainter_php_qt(getThis(), (QPaintDevice *) cpp_arg_0);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::QPainter(...) ");
}

/*!
 * method setRedirected
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPaintDevice *devices0
 * @param	 QPaintDevice *replacements1
 * @param	 const QPoint & offset = QPoint()s2
 * 
 * @access	public
 * @return	void
 * @flags	s
 */

ZEND_METHOD(QPainter, setRedirected)
{
  ///const QPaintDevice *devices0, QPaintDevice *replacements1, const QPoint & offset = QPoint()s2
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QPaintDevice
#ifdef PHP_QT_QPaintDevice
      if (inherits(Z_OBJCE_P(arg_0), 49) && inherits(Z_OBJCE_P(arg_1), 49)) {
        /// try const QPaintDevice *devices0, QPaintDevice *replacements1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPaintDevice *
          cpp_arg_0 = static_cast < QPaintDevice * >(php_qt_fetch(arg_0));
        QPaintDevice *
          cpp_arg_1 = static_cast < QPaintDevice * >(php_qt_fetch(arg_1));

        if (getThis() == NULL) {
          RETURN_VOID(QPainter::setRedirected((const QPaintDevice *)cpp_arg_0, (QPaintDevice *) cpp_arg_1));
        } else {
          RETURN_VOID(selfpointer->setRedirected((const QPaintDevice *)cpp_arg_0, (QPaintDevice *) cpp_arg_1));
      }}
#endif

#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QPaintDevice
#ifdef PHP_QT_QPaintDevice
      if (inherits(Z_OBJCE_P(arg_0), 49) && inherits(Z_OBJCE_P(arg_1), 49)) {
        /// try const QPaintDevice *devices0, QPaintDevice *replacements1, const QPoint & offset = QPoint()s2,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPaintDevice *
          cpp_arg_0 = static_cast < QPaintDevice * >(php_qt_fetch(arg_0));
        QPaintDevice *
          cpp_arg_1 = static_cast < QPaintDevice * >(php_qt_fetch(arg_1));
        QPoint *
          cpp_arg_2 = static_cast < QPoint * >(php_qt_fetch(arg_2));

        if (getThis() == NULL) {
          RETURN_VOID(QPainter::setRedirected((const QPaintDevice *)cpp_arg_0, (QPaintDevice *) cpp_arg_1, (const QPoint &)*cpp_arg_2));
        } else {
          RETURN_VOID(selfpointer->setRedirected((const QPaintDevice *)cpp_arg_0, (QPaintDevice *) cpp_arg_1, (const QPoint &)*cpp_arg_2));
      }}
#endif

#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::setRedirected(...) ");
}

/*!
 * method compositionMode
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	CompositionMode
 * @flags	c
 */

ZEND_METHOD(QPainter, compositionMode)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type CompositionMode");
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::compositionMode(...) ");
}

/*!
 * method setFont
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QFont &fs0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setFont)
{
  ///const QFont &fs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QFont
      if (inherits(Z_OBJCE_P(arg_0), 24)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setFont' is not static");
          RETURN_NULL();
        }
        /// try const QFont &fs0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QFont *
          cpp_arg_0 = static_cast < QFont * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setFont((const QFont &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::setFont(...) ");
}

/*!
 * method begin
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QPaintDevice *s0
 * 
 * @access	public
 * @return	bool
 * @flags	
 */

ZEND_METHOD(QPainter, begin)
{
  ///QPaintDevice *s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QPaintDevice
      if (inherits(Z_OBJCE_P(arg_0), 49)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'begin' is not static");
          RETURN_NULL();
        }
        /// try QPaintDevice *s0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPaintDevice *
          cpp_arg_0 = static_cast < QPaintDevice * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->begin((QPaintDevice *) cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::begin(...) ");
}

/*!
 * method setViewport
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRect &viewports0
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 int w
 * @param	 int h
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setViewport)
{
  ///const QRect &viewports0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setViewport' is not static");
          RETURN_NULL();
        }
        /// try const QRect &viewports0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setViewport((const QRect &)*cpp_arg_0));
      }
#endif

    }
  }
  ///int x, int y, int w, int h
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setViewport' is not static");
        RETURN_NULL();
      }
      /// try int x, int y, int w, int h,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setViewport((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::setViewport(...) ");
}

/*!
 * method drawEllipse
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRectF &rs0
 * 
 * overloaded args:
 * @param	const QRect &r
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 int w
 * @param	 int h
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawEllipse)
{
  ///const QRectF &rs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawEllipse' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &rs0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawEllipse((const QRectF &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QRect &r
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawEllipse' is not static");
          RETURN_NULL();
        }
        /// try const QRect &r,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawEllipse((const QRect &)*cpp_arg_0));
      }
#endif

    }
  }
  ///int x, int y, int w, int h
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'drawEllipse' is not static");
        RETURN_NULL();
      }
      /// try int x, int y, int w, int h,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->drawEllipse((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawEllipse(...) ");
}

/*!
 * method drawArc
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRectF &rects0
 * @param	 int as1
 * @param	 int alens2
 * 
 * overloaded args:
 * @param	const QRect &
 * @param	 int a
 * @param	 int alen
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 int w
 * @param	 int h
 * @param	 int a
 * @param	 int alen
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawArc)
{
  ///const QRectF &rects0, int as1, int alens2
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawArc' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &rects0, int as1, int alens2,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawArc((const QRectF &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
      }
#endif

    }
  }
  ///const QRect &, int a, int alen
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawArc' is not static");
          RETURN_NULL();
        }
        /// try const QRect &, int a, int alen,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawArc((const QRect &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
      }
#endif

    }
  }
  ///int x, int y, int w, int h, int a, int alen
  if (ZEND_NUM_ARGS() == 6) {
    PHP_QT_FETCH_6_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG && Z_TYPE_P(arg_4) == IS_LONG
        && Z_TYPE_P(arg_5) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'drawArc' is not static");
        RETURN_NULL();
      }
      /// try int x, int y, int w, int h, int a, int alen,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->
                  drawArc((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3), (int)Z_LVAL_P(arg_4), (int)Z_LVAL_P(arg_5)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawArc(...) ");
}

/*!
 * method drawRect
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRectF &rects0
 * 
 * overloaded args:
 * @param	int x1
 * @param	 int y1
 * @param	 int w
 * @param	 int h
 * 
 * overloaded args:
 * @param	const QRect &rect
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawRect)
{
  ///const QRectF &rects0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRectF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawRect' is not static");
          RETURN_NULL();
        }
        /// try const QRectF &rects0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRectF *
          cpp_arg_0 = static_cast < QRectF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawRect((const QRectF &)*cpp_arg_0));
      }
#endif

    }
  }
  ///int x1, int y1, int w, int h
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'drawRect' is not static");
        RETURN_NULL();
      }
      /// try int x1, int y1, int w, int h,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->drawRect((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (int)Z_LVAL_P(arg_3)));
    }
  }
  ///const QRect &rect
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawRect' is not static");
          RETURN_NULL();
        }
        /// try const QRect &rect,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QRect *
          cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawRect((const QRect &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawRect(...) ");
}

/*!
 * method setBackground
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QBrush &bgs0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setBackground)
{
  ///const QBrush &bgs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QBrush
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setBackground' is not static");
          RETURN_NULL();
        }
        /// try const QBrush &bgs0,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QBrush *
          cpp_arg_0 = static_cast < QBrush * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setBackground((const QBrush &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::setBackground(...) ");
}

/*!
 * method isActive
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QPainter, isActive)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isActive' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isActive());
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::isActive(...) ");
}

/*!
 * method drawLines
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QLineF *liness0
 * @param	 int lineCounts1
 * 
 * overloaded args:
 * @param	const QVector<QLineF> &lines
 * 
 * overloaded args:
 * @param	const QPointF *pointPairs
 * @param	 int lineCount
 * 
 * overloaded args:
 * @param	const QVector<QPointF> &pointPairs
 * 
 * overloaded args:
 * @param	const QLine *lines
 * @param	 int lineCount
 * 
 * overloaded args:
 * @param	const QVector<QLine> &lines
 * 
 * overloaded args:
 * @param	const QPoint *pointPairs
 * @param	 int lineCount
 * 
 * overloaded args:
 * @param	const QVector<QPoint> &pointPairs
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawLines)
{
  ///const QLineF *liness0, int lineCounts1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QLineF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawLines' is not static");
          RETURN_NULL();
        }
        /// try const QLineF *liness0, int lineCounts1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QLineF *
          cpp_arg_0 = static_cast < QLineF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawLines((const QLineF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QVector<QLineF> &lines
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QVector
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawLines' is not static");
          RETURN_NULL();
        }
        /// try const QVector<QLineF> &lines,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QVector < QLineF > *cpp_arg_0 = static_cast < QVector < QLineF > *>(php_qt_fetch(arg_0));
        RETURN_VOID(selfpointer->drawLines((const QVector < QLineF > &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QPointF *pointPairs, int lineCount
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QPointF
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawLines' is not static");
          RETURN_NULL();
        }
        /// try const QPointF *pointPairs, int lineCount,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawLines((const QPointF *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QVector<QPointF> &pointPairs
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QVector
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawLines' is not static");
          RETURN_NULL();
        }
        /// try const QVector<QPointF> &pointPairs,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QVector < QPointF > *cpp_arg_0 = static_cast < QVector < QPointF > *>(php_qt_fetch(arg_0));
        RETURN_VOID(selfpointer->drawLines((const QVector < QPointF > &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QLine *lines, int lineCount
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QLine
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawLines' is not static");
          RETURN_NULL();
        }
        /// try const QLine *lines, int lineCount,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QLine *
          cpp_arg_0 = static_cast < QLine * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawLines((const QLine *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QVector<QLine> &lines
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QVector
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawLines' is not static");
          RETURN_NULL();
        }
        /// try const QVector<QLine> &lines,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QVector < QLine > *cpp_arg_0 = static_cast < QVector < QLine > *>(php_qt_fetch(arg_0));
        RETURN_VOID(selfpointer->drawLines((const QVector < QLine > &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QPoint *pointPairs, int lineCount
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QPoint
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawLines' is not static");
          RETURN_NULL();
        }
        /// try const QPoint *pointPairs, int lineCount,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->drawLines((const QPoint *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QVector<QPoint> &pointPairs
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QVector
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawLines' is not static");
          RETURN_NULL();
        }
        /// try const QVector<QPoint> &pointPairs,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QVector < QPoint > *cpp_arg_0 = static_cast < QVector < QPoint > *>(php_qt_fetch(arg_0));
        RETURN_VOID(selfpointer->drawLines((const QVector < QPoint > &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawLines(...) ");
}

/*!
 * method renderHints
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	RenderHints
 * @flags	c
 */

ZEND_METHOD(QPainter, renderHints)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type RenderHints");
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::renderHints(...) ");
}

/*!
 * method backgroundMode
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Qt::BGMode
 * @flags	c
 */

ZEND_METHOD(QPainter, backgroundMode)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'backgroundMode' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->backgroundMode());
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::backgroundMode(...) ");
}

/*!
 * method redirected
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPaintDevice *devices0
 * @param	 QPoint *offset = 0s1
 * 
 * @access	public
 * @return	QPaintDevice *
 * @flags	s
 */

ZEND_METHOD(QPainter, redirected)
{
// notice: abstract class QPaintDevice cannot be instanciated, skipped
  php_error(E_ERROR, "could not parse argument in QPainter::redirected(...) ");
}

/*!
 * method hasClipping
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QPainter, hasClipping)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'hasClipping' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->hasClipping());
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::hasClipping(...) ");
}

/*!
 * method drawTextItem
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPointF &ps0
 * @param	 const QTextItem &tis1
 * 
 * overloaded args:
 * @param	int x
 * @param	 int y
 * @param	 const QTextItem &ti
 * 
 * overloaded args:
 * @param	const QPoint &p
 * @param	 const QTextItem &ti
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, drawTextItem)
{
  ///const QPointF &ps0, const QTextItem &tis1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QPointF
#ifdef PHP_QT_QTextItem
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawTextItem' is not static");
          RETURN_NULL();
        }
        /// try const QPointF &ps0, const QTextItem &tis1,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPointF *
          cpp_arg_0 = static_cast < QPointF * >(php_qt_fetch(arg_0));
        QTextItem *
          cpp_arg_1 = static_cast < QTextItem * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawTextItem((const QPointF &)*cpp_arg_0, (const QTextItem &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  ///int x, int y, const QTextItem &ti
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QTextItem
      if (inherits(Z_OBJCE_P(arg_2), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawTextItem' is not static");
          RETURN_NULL();
        }
        /// try int x, int y, const QTextItem &ti,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QTextItem *
          cpp_arg_2 = static_cast < QTextItem * >(php_qt_fetch(arg_2));

        RETURN_VOID(selfpointer->drawTextItem((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QTextItem &)*cpp_arg_2));
      }
#endif

    }
  }
  ///const QPoint &p, const QTextItem &ti
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QPoint
#ifdef PHP_QT_QTextItem
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'drawTextItem' is not static");
          RETURN_NULL();
        }
        /// try const QPoint &p, const QTextItem &ti,
        QPainter *
          selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
        }
        QPoint *
          cpp_arg_0 = static_cast < QPoint * >(php_qt_fetch(arg_0));
        QTextItem *
          cpp_arg_1 = static_cast < QTextItem * >(php_qt_fetch(arg_1));

        RETURN_VOID(selfpointer->drawTextItem((const QPoint &)*cpp_arg_0, (const QTextItem &)*cpp_arg_1));
      }
#endif

#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::drawTextItem(...) ");
}

/*!
 * method setClipping
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool enables0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QPainter, setClipping)
{
  ///bool enables0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setClipping' is not static");
        RETURN_NULL();
      }
      /// try bool enables0,
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setClipping((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QPainter::setClipping(...) ");
}

/*!
 * method clipPath
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QPainterPath
 * @flags	c
 */

ZEND_METHOD(QPainter, clipPath)
{
  ///
#ifdef PHP_QT_QPainterPath      // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'clipPath' is not static");
        RETURN_NULL();
      }
      /// try 
      QPainter *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QPainter * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QPainterPath *
        return_object = new QPainterPath;

      *return_object = static_cast < QPainterPath > (selfpointer->clipPath());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QPainter::clipPath(...) ");
}
