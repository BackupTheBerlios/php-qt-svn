/*
 * PHP-Qt - The PHP language bindings for Qt
 *
 * Copyright (C) 2006
 * Thomas Moenicke <tm@ippfp.org>,
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * QString.cpp - QString PHP implementation.
 * begin           : Tue Jun  6 22:42:56 2006
 * generated by    : moni using kalyptus 0.9.
 */

#include <iostream>
using namespace std;

#include "../php_qt.h"


#include <QString>
/// DEBUG:destructor skipped.
#include <QMetaMethod>
class QString_php_qt:public QString
{

public:
  QString_php_qt(zval * zend_ptr);
  QString_php_qt(zval * zend_ptr, const QChar * unicodes0, int sizes1);
    QString_php_qt(zval * zend_ptr, QChar cs0);
    QString_php_qt(zval * zend_ptr, int sizes0, QChar cs1);
    QString_php_qt(zval * zend_ptr, const QLatin1String & latin1s0);
    QString_php_qt(zval * zend_ptr, const QString & s0);
    QString_php_qt(zval * zend_ptr, const char *chs0);
    QString_php_qt(zval * zend_ptr, const QByteArray & as0);
    QString_php_qt(zval * zend_ptr, const Null & s0);


  zval *zend_ptr;
};

QString_php_qt::QString_php_qt(zval * zend_ptr):QString()
{
  this->zend_ptr = zend_ptr;
}
QString_php_qt::QString_php_qt(zval * zend_ptr, const QChar * unicodes0, int sizes1):
QString(unicodes0, sizes1)
{
  this->zend_ptr = zend_ptr;
}

QString_php_qt::QString_php_qt(zval * zend_ptr, QChar cs0):QString(cs0)
{
  this->zend_ptr = zend_ptr;
}
QString_php_qt::QString_php_qt(zval * zend_ptr, int sizes0, QChar cs1):
QString(sizes0, cs1)
{
  this->zend_ptr = zend_ptr;
}
QString_php_qt::QString_php_qt(zval * zend_ptr, const QLatin1String & latin1s0):
QString(latin1s0)
{
  this->zend_ptr = zend_ptr;
}
QString_php_qt::QString_php_qt(zval * zend_ptr, const QString & s0):
QString(s0)
{
  this->zend_ptr = zend_ptr;
}
QString_php_qt::QString_php_qt(zval * zend_ptr, const char *chs0):
QString(chs0)
{
  this->zend_ptr = zend_ptr;
}
QString_php_qt::QString_php_qt(zval * zend_ptr, const QByteArray & as0):
QString(as0)
{
  this->zend_ptr = zend_ptr;
}
QString_php_qt::QString_php_qt(zval * zend_ptr, const Null & s0):
QString(s0)
{
  this->zend_ptr = zend_ptr;
}

/*!
 * method compare
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &ss0
 * 
 * overloaded args:
 * @param	const QString &s1
 * @param	 const QString &s2
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QString, compare)
{
  ///const QString &ss0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'compare' is not static");
          RETURN_NULL();
        }
        /// try const QString &ss0,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->compare((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QString &s1, const QString &s2
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_1 = invokeToQString(arg_1);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QString
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
        /// try const QString &s1, const QString &s2,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));

        if (getThis() == NULL) {
          RETURN_LONG(QString::compare((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
        } else {
          RETURN_LONG(selfpointer->compare((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
      }}
#endif

#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QString::compare(...) ");
}

/*!
 * method utf16
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const ushort *
 * @flags	c
 */

ZEND_METHOD(QString, utf16)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'utf16' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->utf16());
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::utf16(...) ");
}

/*!
 * method constData
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const QChar *
 * @flags	c
 */

ZEND_METHOD(QString, constData)
{
  ///
#ifdef PHP_QT_QChar             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'constData' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = const_cast < QChar * >(selfpointer->constData());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::constData(...) ");
}

/*!
 * method insert
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int is0
 * @param	 QChar cs1
 * 
 * overloaded args:
 * @param	int i
 * @param	 const QChar *uc
 * @param	 int len
 * 
 * overloaded args:
 * @param	int i
 * @param	 const QString &s
 * 
 * overloaded args:
 * @param	int i
 * @param	 const QLatin1String &s
 * 
 * @access	public
 * @return	QString &
 * @flags	
 */

ZEND_METHOD(QString, insert)
{
  ///int is0, QChar cs1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_1), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'insert' is not static");
          RETURN_NULL();
        }
        /// try int is0, QChar cs1,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->insert((int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///int i, const QChar *uc, int len
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_1), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'insert' is not static");
          RETURN_NULL();
        }
        /// try int i, const QChar *uc, int len,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->insert((int)Z_LVAL_P(arg_0), (const QChar *)cpp_arg_1, (int)Z_LVAL_P(arg_2)));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///int i, const QString &s
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_1 = invokeToQString(arg_1);

    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_1), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'insert' is not static");
          RETURN_NULL();
        }
        /// try int i, const QString &s,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->insert((int)Z_LVAL_P(arg_0), (const QString &)*cpp_arg_1));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///int i, const QLatin1String &s
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QLatin1String
      if (inherits(Z_OBJCE_P(arg_1), 40)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'insert' is not static");
          RETURN_NULL();
        }
        /// try int i, const QLatin1String &s,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QLatin1String *cpp_arg_1 = static_cast < QLatin1String * >(php_qt_fetch(arg_1));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->insert((int)Z_LVAL_P(arg_0), (const QLatin1String &)*cpp_arg_1));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::insert(...) ");
}

/*!
 * method clear
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QString, clear)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'clear' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->clear());
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::clear(...) ");
}

/*!
 * method setUtf16
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const ushort *utf16s0
 * @param	 int sizes1
 * 
 * @access	public
 * @return	QString &
 * @flags	
 */

ZEND_METHOD(QString, setUtf16)
{
  ///const ushort *utf16s0, int sizes1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setUtf16' is not static");
        RETURN_NULL();
      }
      /// try const ushort *utf16s0, int sizes1,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->setUtf16((const ushort *)&Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::setUtf16(...) ");
}

/*!
 * method prepend
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QChar cs0
 * 
 * overloaded args:
 * @param	const QString &s
 * 
 * overloaded args:
 * @param	const QLatin1String &s
 * 
 * overloaded args:
 * @param	const char *s
 * 
 * overloaded args:
 * @param	const QByteArray &s
 * 
 * @access	public
 * @return	QString &
 * @flags	
 */

ZEND_METHOD(QString, prepend)
{
  ///QChar cs0
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'prepend' is not static");
          RETURN_NULL();
        }
        /// try QChar cs0,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->prepend((QChar) * cpp_arg_0));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///const QString &s
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'prepend' is not static");
          RETURN_NULL();
        }
        /// try const QString &s,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->prepend((const QString &)*cpp_arg_0));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///const QLatin1String &s
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QLatin1String
      if (inherits(Z_OBJCE_P(arg_0), 40)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'prepend' is not static");
          RETURN_NULL();
        }
        /// try const QLatin1String &s,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QLatin1String *cpp_arg_0 = static_cast < QLatin1String * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->prepend((const QLatin1String &)*cpp_arg_0));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///const char *s
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'prepend' is not static");
        RETURN_NULL();
      }
      /// try const char *s,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->prepend((const char *)&Z_STRVAL_P(arg_0)[0]));
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///const QByteArray &s
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QByteArray
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'prepend' is not static");
          RETURN_NULL();
        }
        /// try const QByteArray &s,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QByteArray *cpp_arg_0 = static_cast < QByteArray * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->prepend((const QByteArray &)*cpp_arg_0));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::prepend(...) ");
}

/*!
 * method grow
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ints0
 * 
 * @access	private
 * @return	int
 * @flags	s
 */

ZEND_METHOD(QString, grow)
{
  ///int ints0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
/// method is private, skip
      php_error(E_ERROR, "QString::grow(...) cannot be called with 'int ints0,'.");
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::grow(...) ");
}

/*!
 * method trimmed
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QString, trimmed)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'trimmed' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->trimmed());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::trimmed(...) ");
}

/*!
 * method chop
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ns0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QString, chop)
{
  ///int ns0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'chop' is not static");
        RETURN_NULL();
      }
      /// try int ns0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->chop((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::chop(...) ");
}

/*!
 * method leftJustified
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int widths0
 * @param	 QChar fill = QLatin1Char(' ')s1
 * @param	 bool trunc = falses2
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QString, leftJustified)
{
  ///int widths0, QChar fill = QLatin1Char(' ')s1, bool trunc = falses2
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'leftJustified' is not static");
        RETURN_NULL();
      }
      /// try int widths0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->leftJustified((int)Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'leftJustified' is not static");
        RETURN_NULL();
      }
      /// try int widths0, QChar fill = QLatin1Char(' ')s1,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->leftJustified((int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'leftJustified' is not static");
        RETURN_NULL();
      }
      /// try int widths0, QChar fill = QLatin1Char(' ')s1, bool trunc = falses2,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->leftJustified((int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1, (bool) Z_LVAL_P(arg_2)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::leftJustified(...) ");
}

/*!
 * method squeeze
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QString, squeeze)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'squeeze' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->squeeze());
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::squeeze(...) ");
}

/*!
 * method count
 * 
 * @param: -
 * @param: -
 * 
 * overloaded args:
 * @param	QChar c
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
 * 
 * overloaded args:
 * @param	const QString &s
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
 * 
 * overloaded args:
 * @param	const QRegExp &
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QString, count)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'count' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->count());
    }
  }
  ///QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'count' is not static");
          RETURN_NULL();
        }
        /// try QChar c,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->count((QChar) * cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'count' is not static");
          RETURN_NULL();
        }
        /// try QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->count((QChar) * cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'count' is not static");
          RETURN_NULL();
        }
        /// try const QString &s,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->count((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'count' is not static");
          RETURN_NULL();
        }
        /// try const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->count((const QString &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QRegExp &
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRegExp
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'count' is not static");
          RETURN_NULL();
        }
        /// try const QRegExp &,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->count((const QRegExp &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QString::count(...) ");
}

/*!
 * method fromAscii
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const char *s0
 * @param	 int size = -1s1
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QString, fromAscii)
{
  ///const char *s0, int size = -1s1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      /// try const char *s0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QString::fromAscii((const char *)&Z_STRVAL_P(arg_0)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->fromAscii((const char *)&Z_STRVAL_P(arg_0)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_LONG) {
      /// try const char *s0, int size = -1s1,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QString::fromAscii((const char *)&Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
      } else {
        *return_object = static_cast < QString > (selfpointer->fromAscii((const char *)&Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::fromAscii(...) ");
}

/*!
 * method toLongLong
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool *ok=0s0
 * @param	 int base=10s1
 * 
 * @access	public
 * @return	qlonglong
 * @flags	c
 */

ZEND_METHOD(QString, toLongLong)
{
  ///bool *ok=0s0, int base=10s1
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type qlonglong");
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      php_error(E_ERROR, "unsupported return type qlonglong");
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
      php_error(E_ERROR, "unsupported return type qlonglong");
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::toLongLong(...) ");
}

/*!
 * method toUpper
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QString, toUpper)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toUpper' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->toUpper());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::toUpper(...) ");
}

/*!
 * method QString
 * 
 * @param: -
 * @param: -
 * 
 * overloaded args:
 * @param	const QChar *unicodes0
 * @param	int sizes1
 * 
 * overloaded args:
 * @param	QChar cs0
 * 
 * overloaded args:
 * @param	int sizes0
 * @param	QChar cs1
 * 
 * overloaded args:
 * @param	const QLatin1String &latin1s0
 * 
 * overloaded args:
 * @param	const QString &s0
 * 
 * overloaded args:
 * @param	const char *chs0
 * 
 * overloaded args:
 * @param	const QByteArray &as0
 * 
 * overloaded args:
 * @param	const Null &s0
 * 
 * overloaded args:
 * @param	const char *ch
 * 
 * overloaded args:
 * @param	const QByteArray &a
 * 
 * overloaded args:
 * @param	Data *dd
 * @param	 int
 * 
 * @access	public
 * @return	
 * @flags	
 */

ZEND_METHOD(QString, __construct)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try 
      QString_php_qt *selfpointer = new QString_php_qt(getThis());

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  ///const QChar *unicodes0,int sizes1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try const QChar *unicodes0,int sizes1,
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (const QChar *)cpp_arg_0, (int)Z_LVAL_P(arg_1));

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  ///QChar cs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try QChar cs0,
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (QChar) * cpp_arg_0);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  ///int sizes0,QChar cs1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_1), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try int sizes0,QChar cs1,
        QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  ///const QLatin1String &latin1s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QLatin1String
      if (inherits(Z_OBJCE_P(arg_0), 40)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try const QLatin1String &latin1s0,
        QLatin1String *cpp_arg_0 = static_cast < QLatin1String * >(php_qt_fetch(arg_0));
        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (const QLatin1String &)*cpp_arg_0);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  ///const QString &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try const QString &s0,
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (const QString &)*cpp_arg_0);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  ///const char *chs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try const char *chs0,
      QString_php_qt *selfpointer = new QString_php_qt(getThis(), (const char *)&Z_STRVAL_P(arg_0)[0]);

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  ///const QByteArray &as0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QByteArray
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try const QByteArray &as0,
        QByteArray *cpp_arg_0 = static_cast < QByteArray * >(php_qt_fetch(arg_0));
        QString_php_qt *selfpointer = new QString_php_qt(getThis(), (const QByteArray &)*cpp_arg_0);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
// notice: unknown argument const Null &s0, skipped

  ///const char *ch
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
/// method is private, skip
      php_error(E_ERROR, "QString::__construct(...) cannot be called with 'const char *ch,'.");
    }
  }
  ///const QByteArray &a
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QByteArray
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
/// method is private, skip
        php_error(E_ERROR, "QString::__construct(...) cannot be called with 'const QByteArray &a,'.");
      }
#endif

    }
  }
// notice: unknown argument Data *dd, skipped
  php_error(E_ERROR, "could not parse argument in QString::QString(...) ");
}

/*!
 * method normalized
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	NormalizationForm modes0
 * 
 * overloaded args:
 * @param	NormalizationForm mode
 * @param	 QChar::UnicodeVersion version
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QString, normalized)
{
// notice: unknown argument NormalizationForm modes0, skipped

// notice: unknown argument NormalizationForm mode, skipped
  php_error(E_ERROR, "could not parse argument in QString::normalized(...) ");
}

/*!
 * method fromUtf16
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const ushort *s0
 * @param	 int size = -1s1
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QString, fromUtf16)
{
  ///const ushort *s0, int size = -1s1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      /// try const ushort *s0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QString::fromUtf16((const ushort *)&Z_LVAL_P(arg_0)));
      } else {
        *return_object = static_cast < QString > (selfpointer->fromUtf16((const ushort *)&Z_LVAL_P(arg_0)));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      /// try const ushort *s0, int size = -1s1,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QString::fromUtf16((const ushort *)&Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      } else {
        *return_object = static_cast < QString > (selfpointer->fromUtf16((const ushort *)&Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::fromUtf16(...) ");
}

/*!
 * method isRightToLeft
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QString, isRightToLeft)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isRightToLeft' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isRightToLeft());
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::isRightToLeft(...) ");
}

/*!
 * method setNum
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	short shorts0
 * @param	 int base=10s1
 * 
 * overloaded args:
 * @param	ushort
 * @param	 int base=10
 * 
 * overloaded args:
 * @param	int
 * @param	 int base=10
 * 
 * overloaded args:
 * @param	uint
 * @param	 int base=10
 * 
 * overloaded args:
 * @param	long
 * @param	 int base=10
 * 
 * overloaded args:
 * @param	ulong
 * @param	 int base=10
 * 
 * overloaded args:
 * @param	qlonglong
 * @param	 int base=10
 * 
 * overloaded args:
 * @param	qulonglong
 * @param	 int base=10
 * 
 * overloaded args:
 * @param	float
 * @param	 char f='g'
 * @param	 int prec=6
 * 
 * overloaded args:
 * @param	double
 * @param	 char f='g'
 * @param	 int prec=6
 * 
 * @access	public
 * @return	QString &
 * @flags	
 */

ZEND_METHOD(QString, setNum)
{
  ///short shorts0, int base=10s1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setNum' is not static");
        RETURN_NULL();
      }
      /// try short shorts0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->setNum((short)Z_LVAL_P(arg_0)));
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setNum' is not static");
        RETURN_NULL();
      }
      /// try short shorts0, int base=10s1,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->setNum((short)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///ushort, int base=10
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setNum' is not static");
        RETURN_NULL();
      }
      /// try ushort,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->setNum((ushort) Z_LVAL_P(arg_0)));
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setNum' is not static");
        RETURN_NULL();
      }
      /// try ushort, int base=10,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->setNum((ushort) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///int, int base=10
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setNum' is not static");
        RETURN_NULL();
      }
      /// try int,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->setNum((int)Z_LVAL_P(arg_0)));
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setNum' is not static");
        RETURN_NULL();
      }
      /// try int, int base=10,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->setNum((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///uint, int base=10
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setNum' is not static");
        RETURN_NULL();
      }
      /// try uint,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->setNum((uint) Z_LVAL_P(arg_0)));
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setNum' is not static");
        RETURN_NULL();
      }
      /// try uint, int base=10,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->setNum((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


// notice: unknown argument long, skipped

// notice: unknown argument ulong, skipped

// notice: unknown argument qlonglong, skipped

// notice: unknown argument qulonglong, skipped

  ///float, char f='g', int prec=6
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setNum' is not static");
        RETURN_NULL();
      }
      /// try float,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->setNum((float)Z_DVAL_P(arg_0)));
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_STRING) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setNum' is not static");
        RETURN_NULL();
      }
      /// try float, char f='g',
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->setNum((float)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0]));
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_STRING && Z_TYPE_P(arg_2) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setNum' is not static");
        RETURN_NULL();
      }
      /// try float, char f='g', int prec=6,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->setNum((float)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0], (int)Z_LVAL_P(arg_2)));
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///double, char f='g', int prec=6
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setNum' is not static");
        RETURN_NULL();
      }
      /// try double,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->setNum((double)Z_DVAL_P(arg_0)));
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_STRING) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setNum' is not static");
        RETURN_NULL();
      }
      /// try double, char f='g',
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->setNum((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0]));
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_STRING && Z_TYPE_P(arg_2) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setNum' is not static");
        RETURN_NULL();
      }
      /// try double, char f='g', int prec=6,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->setNum((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0], (int)Z_LVAL_P(arg_2)));
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::setNum(...) ");
}

/*!
 * method operator[]
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int is0
 * 
 * overloaded args:
 * @param	int i
 * 
 * overloaded args:
 * @param	uint i
 * 
 * overloaded args:
 * @param	uint i
 * 
 * @access	public
 * @return	const QChar
 * @flags	c
 */

/*!
 * method endsWith
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &ss0
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives1
 * 
 * overloaded args:
 * @param	const QLatin1String &s
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
 * 
 * overloaded args:
 * @param	const QChar &c
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QString, endsWith)
{
  ///const QString &ss0, Qt::CaseSensitivity cs = Qt::CaseSensitives1
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'endsWith' is not static");
          RETURN_NULL();
        }
        /// try const QString &ss0,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->endsWith((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'endsWith' is not static");
          RETURN_NULL();
        }
        /// try const QString &ss0, Qt::CaseSensitivity cs = Qt::CaseSensitives1,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->endsWith((const QString &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QLatin1String &s, Qt::CaseSensitivity cs = Qt::CaseSensitive
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QLatin1String
      if (inherits(Z_OBJCE_P(arg_0), 40)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'endsWith' is not static");
          RETURN_NULL();
        }
        /// try const QLatin1String &s,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QLatin1String *cpp_arg_0 = static_cast < QLatin1String * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->endsWith((const QLatin1String &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QLatin1String
      if (inherits(Z_OBJCE_P(arg_0), 40)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'endsWith' is not static");
          RETURN_NULL();
        }
        /// try const QLatin1String &s, Qt::CaseSensitivity cs = Qt::CaseSensitive,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QLatin1String *cpp_arg_0 = static_cast < QLatin1String * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->endsWith((const QLatin1String &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QChar &c, Qt::CaseSensitivity cs = Qt::CaseSensitive
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'endsWith' is not static");
          RETURN_NULL();
        }
        /// try const QChar &c,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->endsWith((const QChar &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'endsWith' is not static");
          RETURN_NULL();
        }
        /// try const QChar &c, Qt::CaseSensitivity cs = Qt::CaseSensitive,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->endsWith((const QChar &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QString::endsWith(...) ");
}

/*!
 * method number
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ints0
 * @param	 int base=10s1
 * 
 * overloaded args:
 * @param	uint
 * @param	 int base=10
 * 
 * overloaded args:
 * @param	long
 * @param	 int base=10
 * 
 * overloaded args:
 * @param	ulong
 * @param	 int base=10
 * 
 * overloaded args:
 * @param	qlonglong
 * @param	 int base=10
 * 
 * overloaded args:
 * @param	qulonglong
 * @param	 int base=10
 * 
 * overloaded args:
 * @param	double
 * @param	 char f='g'
 * @param	 int prec=6
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QString, number)
{
  ///int ints0, int base=10s1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      /// try int ints0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QString::number((int)Z_LVAL_P(arg_0)));
      } else {
        *return_object = static_cast < QString > (selfpointer->number((int)Z_LVAL_P(arg_0)));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      /// try int ints0, int base=10s1,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QString::number((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      } else {
        *return_object = static_cast < QString > (selfpointer->number((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///uint, int base=10
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      /// try uint,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QString::number((uint) Z_LVAL_P(arg_0)));
      } else {
        *return_object = static_cast < QString > (selfpointer->number((uint) Z_LVAL_P(arg_0)));
      }
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      /// try uint, int base=10,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QString::number((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      } else {
        *return_object = static_cast < QString > (selfpointer->number((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


// notice: unknown argument long, skipped

// notice: unknown argument ulong, skipped

// notice: unknown argument qlonglong, skipped

// notice: unknown argument qulonglong, skipped

  ///double, char f='g', int prec=6
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE) {
      /// try double,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QString::number((double)Z_DVAL_P(arg_0)));
      } else {
        *return_object = static_cast < QString > (selfpointer->number((double)Z_DVAL_P(arg_0)));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_STRING) {
      /// try double, char f='g',
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QString::number((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->number((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_STRING && Z_TYPE_P(arg_2) == IS_LONG) {
      /// try double, char f='g', int prec=6,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QString::number((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0], (int)Z_LVAL_P(arg_2)));
      } else {
        *return_object = static_cast < QString > (selfpointer->number((double)Z_DVAL_P(arg_0), (char)Z_STRVAL_P(arg_1)[0], (int)Z_LVAL_P(arg_2)));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::number(...) ");
}

/*!
 * method localeAwareCompare
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString & ss0
 * 
 * overloaded args:
 * @param	const QString& s1
 * @param	 const QString& s2
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QString, localeAwareCompare)
{
  ///const QString & ss0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'localeAwareCompare' is not static");
          RETURN_NULL();
        }
        /// try const QString & ss0,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->localeAwareCompare((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  ///const QString& s1, const QString& s2
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_1 = invokeToQString(arg_1);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QString
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
        /// try const QString& s1, const QString& s2,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));

        if (getThis() == NULL) {
          RETURN_LONG(QString::localeAwareCompare((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
        } else {
          RETURN_LONG(selfpointer->localeAwareCompare((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
      }}
#endif

#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QString::localeAwareCompare(...) ");
}

/*!
 * method section
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QChar seps0
 * @param	 int starts1
 * @param	 int end = -1s2
 * @param	 SectionFlags flags = SectionDefaults3
 * 
 * overloaded args:
 * @param	const QString &in_sep
 * @param	 int start
 * @param	 int end = -1
 * @param	 SectionFlags flags = SectionDefault
 * 
 * overloaded args:
 * @param	const QRegExp &reg
 * @param	 int start
 * @param	 int end = -1
 * @param	 SectionFlags flags = SectionDefault
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QString, section)
{
  ///QChar seps0, int starts1, int end = -1s2, SectionFlags flags = SectionDefaults3
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'section' is not static");
          RETURN_NULL();
        }
        /// try QChar seps0, int starts1,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object = static_cast < QString > (selfpointer->section((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1)));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'section' is not static");
          RETURN_NULL();
        }
        /// try QChar seps0, int starts1, int end = -1s2,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object = static_cast < QString > (selfpointer->section((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
// notice: unknown argument  SectionFlags flags = SectionDefaults3, skipped
#endif // return type


  ///const QString &in_sep, int start, int end = -1, SectionFlags flags = SectionDefault
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'section' is not static");
          RETURN_NULL();
        }
        /// try const QString &in_sep, int start,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object = static_cast < QString > (selfpointer->section((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'section' is not static");
          RETURN_NULL();
        }
        /// try const QString &in_sep, int start, int end = -1,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object = static_cast < QString > (selfpointer->section((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
// notice: unknown argument  SectionFlags flags = SectionDefault, skipped
#endif // return type


  ///const QRegExp &reg, int start, int end = -1, SectionFlags flags = SectionDefault
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QRegExp
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'section' is not static");
          RETURN_NULL();
        }
        /// try const QRegExp &reg, int start,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object = static_cast < QString > (selfpointer->section((const QRegExp &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QRegExp
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'section' is not static");
          RETURN_NULL();
        }
        /// try const QRegExp &reg, int start, int end = -1,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object = static_cast < QString > (selfpointer->section((const QRegExp &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
// notice: unknown argument  SectionFlags flags = SectionDefault, skipped
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::section(...) ");
}

/*!
 * method operator<
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &ss0
 * 
 * overloaded args:
 * @param	const QLatin1String &s
 * 
 * overloaded args:
 * @param	const char *s
 * 
 * overloaded args:
 * @param	const QByteArray &s
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method isSimpleText
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QString, isSimpleText)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isSimpleText' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isSimpleText());
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::isSimpleText(...) ");
}

/*!
 * method operator==
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &ss0
 * 
 * overloaded args:
 * @param	const QLatin1String &s
 * 
 * overloaded args:
 * @param	const char *s
 * 
 * overloaded args:
 * @param	const QByteArray &s
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method size
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QString, size)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'size' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->size());
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::size(...) ");
}

/*!
 * method updateProperties
 * 
 * @param: -
 * @param: -
 * 
 * @access	private
 * @return	void
 * @flags	c
 */

ZEND_METHOD(QString, updateProperties)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
/// method is private, skip
      php_error(E_ERROR, "QString::updateProperties(...) cannot be called with ''.");
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::updateProperties(...) ");
}

/*!
 * method simplified
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QString, simplified)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'simplified' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->simplified());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::simplified(...) ");
}

/*!
 * method toUInt
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool *ok=0s0
 * @param	 int base=10s1
 * 
 * @access	public
 * @return	uint
 * @flags	c
 */

ZEND_METHOD(QString, toUInt)
{
  ///bool *ok=0s0, int base=10s1
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toUInt' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->toUInt());
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toUInt' is not static");
        RETURN_NULL();
      }
      /// try bool *ok=0s0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->toUInt((bool *) & Z_LVAL_P(arg_0)));
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toUInt' is not static");
        RETURN_NULL();
      }
      /// try bool *ok=0s0, int base=10s1,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->toUInt((bool *) & Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::toUInt(...) ");
}

/*!
 * method toUShort
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool *ok=0s0
 * @param	 int base=10s1
 * 
 * @access	public
 * @return	ushort
 * @flags	c
 */

ZEND_METHOD(QString, toUShort)
{
  ///bool *ok=0s0, int base=10s1
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toUShort' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->toUShort());
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toUShort' is not static");
        RETURN_NULL();
      }
      /// try bool *ok=0s0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->toUShort((bool *) & Z_LVAL_P(arg_0)));
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toUShort' is not static");
        RETURN_NULL();
      }
      /// try bool *ok=0s0, int base=10s1,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->toUShort((bool *) & Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::toUShort(...) ");
}

/*!
 * method truncate
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int poss0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QString, truncate)
{
  ///int poss0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'truncate' is not static");
        RETURN_NULL();
      }
      /// try int poss0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->truncate((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::truncate(...) ");
}

/*!
 * method toAscii
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QByteArray
 * @flags	c
 */

ZEND_METHOD(QString, toAscii)
{
  ///
#ifdef PHP_QT_QByteArray        // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toAscii' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QByteArray *return_object = new QByteArray;

      *return_object = static_cast < QByteArray > (selfpointer->toAscii());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::toAscii(...) ");
}

/*!
 * method right
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int lens0
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QString, right)
{
  ///int lens0
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'right' is not static");
        RETURN_NULL();
      }
      /// try int lens0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->right((int)Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::right(...) ");
}

/*!
 * method length
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QString, length)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'length' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->length());
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::length(...) ");
}

/*!
 * method expand
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int is0
 * 
 * @access	private
 * @return	void
 * @flags	
 */

ZEND_METHOD(QString, expand)
{
  ///int is0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
/// method is private, skip
      php_error(E_ERROR, "QString::expand(...) cannot be called with 'int is0,'.");
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::expand(...) ");
}

/*!
 * method push_front
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QChar cs0
 * 
 * overloaded args:
 * @param	const QString &s
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QString, push_front)
{
  ///QChar cs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'push_front' is not static");
          RETURN_NULL();
        }
        /// try QChar cs0,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->push_front((QChar) * cpp_arg_0));
      }
#endif

    }
  }
  ///const QString &s
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'push_front' is not static");
          RETURN_NULL();
        }
        /// try const QString &s,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->push_front((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QString::push_front(...) ");
}

/*!
 * method toUtf8
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QByteArray
 * @flags	c
 */

ZEND_METHOD(QString, toUtf8)
{
  ///
#ifdef PHP_QT_QByteArray        // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toUtf8' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QByteArray *return_object = new QByteArray;

      *return_object = static_cast < QByteArray > (selfpointer->toUtf8());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::toUtf8(...) ");
}

/*!
 * method toULongLong
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool *ok=0s0
 * @param	 int base=10s1
 * 
 * @access	public
 * @return	qulonglong
 * @flags	c
 */

ZEND_METHOD(QString, toULongLong)
{
  ///bool *ok=0s0, int base=10s1
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type qulonglong");
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      php_error(E_ERROR, "unsupported return type qulonglong");
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
      php_error(E_ERROR, "unsupported return type qulonglong");
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::toULongLong(...) ");
}

/*!
 * method indexOf
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QChar cs0
 * @param	 int from = 0s1
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives2
 * 
 * overloaded args:
 * @param	const QString &s
 * @param	 int from = 0
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
 * 
 * overloaded args:
 * @param	const QRegExp &
 * @param	 int from = 0
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QString, indexOf)
{
  ///QChar cs0, int from = 0s1, Qt::CaseSensitivity cs = Qt::CaseSensitives2
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'indexOf' is not static");
          RETURN_NULL();
        }
        /// try QChar cs0,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->indexOf((QChar) * cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'indexOf' is not static");
          RETURN_NULL();
        }
        /// try QChar cs0, int from = 0s1,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->indexOf((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'indexOf' is not static");
          RETURN_NULL();
        }
        /// try QChar cs0, int from = 0s1, Qt::CaseSensitivity cs = Qt::CaseSensitives2,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->indexOf((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
      }
#endif

    }
  }
  ///const QString &s, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'indexOf' is not static");
          RETURN_NULL();
        }
        /// try const QString &s,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->indexOf((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'indexOf' is not static");
          RETURN_NULL();
        }
        /// try const QString &s, int from = 0,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->indexOf((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'indexOf' is not static");
          RETURN_NULL();
        }
        /// try const QString &s, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->indexOf((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
      }
#endif

    }
  }
  ///const QRegExp &, int from = 0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRegExp
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'indexOf' is not static");
          RETURN_NULL();
        }
        /// try const QRegExp &,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->indexOf((const QRegExp &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QRegExp
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'indexOf' is not static");
          RETURN_NULL();
        }
        /// try const QRegExp &, int from = 0,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->indexOf((const QRegExp &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QString::indexOf(...) ");
}

/*!
 * method fromRawData
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QChar *s0
 * @param	 int sizes1
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QString, fromRawData)
{
  ///const QChar *s0, int sizes1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        /// try const QChar *s0, int sizes1,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        if (getThis() == NULL) {
          *return_object = static_cast < QString > (QString::fromRawData((const QChar *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
        } else {
          *return_object = static_cast < QString > (selfpointer->fromRawData((const QChar *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
        } le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::fromRawData(...) ");
}

/*!
 * method constEnd
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const_iterator
 * @flags	c
 */

ZEND_METHOD(QString, constEnd)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type const_iterator");
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::constEnd(...) ");
}

/*!
 * method left
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int lens0
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QString, left)
{
  ///int lens0
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'left' is not static");
        RETURN_NULL();
      }
      /// try int lens0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->left((int)Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::left(...) ");
}

/*!
 * method fromLocal8Bit
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const char *s0
 * @param	 int size = -1s1
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QString, fromLocal8Bit)
{
  ///const char *s0, int size = -1s1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      /// try const char *s0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QString::fromLocal8Bit((const char *)&Z_STRVAL_P(arg_0)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->fromLocal8Bit((const char *)&Z_STRVAL_P(arg_0)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_LONG) {
      /// try const char *s0, int size = -1s1,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QString::fromLocal8Bit((const char *)&Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
      } else {
        *return_object = static_cast < QString > (selfpointer->fromLocal8Bit((const char *)&Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::fromLocal8Bit(...) ");
}

/*!
 * method remove
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int is0
 * @param	 int lens1
 * 
 * overloaded args:
 * @param	QChar c
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
 * 
 * overloaded args:
 * @param	const QString &s
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
 * 
 * overloaded args:
 * @param	const QRegExp &rx
 * 
 * @access	public
 * @return	QString &
 * @flags	
 */

ZEND_METHOD(QString, remove)
{
  ///int is0, int lens1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'remove' is not static");
        RETURN_NULL();
      }
      /// try int is0, int lens1,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->remove((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'remove' is not static");
          RETURN_NULL();
        }
        /// try QChar c,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->remove((QChar) * cpp_arg_0));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'remove' is not static");
          RETURN_NULL();
        }
        /// try QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->remove((QChar) * cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'remove' is not static");
          RETURN_NULL();
        }
        /// try const QString &s,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->remove((const QString &)*cpp_arg_0));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'remove' is not static");
          RETURN_NULL();
        }
        /// try const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->remove((const QString &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///const QRegExp &rx
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRegExp
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'remove' is not static");
          RETURN_NULL();
        }
        /// try const QRegExp &rx,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->remove((const QRegExp &)*cpp_arg_0));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::remove(...) ");
}

/*!
 * method startsWith
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &ss0
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives1
 * 
 * overloaded args:
 * @param	const QLatin1String &s
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
 * 
 * overloaded args:
 * @param	const QChar &c
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QString, startsWith)
{
  ///const QString &ss0, Qt::CaseSensitivity cs = Qt::CaseSensitives1
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'startsWith' is not static");
          RETURN_NULL();
        }
        /// try const QString &ss0,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->startsWith((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'startsWith' is not static");
          RETURN_NULL();
        }
        /// try const QString &ss0, Qt::CaseSensitivity cs = Qt::CaseSensitives1,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->startsWith((const QString &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QLatin1String &s, Qt::CaseSensitivity cs = Qt::CaseSensitive
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QLatin1String
      if (inherits(Z_OBJCE_P(arg_0), 40)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'startsWith' is not static");
          RETURN_NULL();
        }
        /// try const QLatin1String &s,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QLatin1String *cpp_arg_0 = static_cast < QLatin1String * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->startsWith((const QLatin1String &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QLatin1String
      if (inherits(Z_OBJCE_P(arg_0), 40)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'startsWith' is not static");
          RETURN_NULL();
        }
        /// try const QLatin1String &s, Qt::CaseSensitivity cs = Qt::CaseSensitive,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QLatin1String *cpp_arg_0 = static_cast < QLatin1String * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->startsWith((const QLatin1String &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///const QChar &c, Qt::CaseSensitivity cs = Qt::CaseSensitive
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'startsWith' is not static");
          RETURN_NULL();
        }
        /// try const QChar &c,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->startsWith((const QChar &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'startsWith' is not static");
          RETURN_NULL();
        }
        /// try const QChar &c, Qt::CaseSensitivity cs = Qt::CaseSensitive,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->startsWith((const QChar &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QString::startsWith(...) ");
}

/*!
 * method operator!=
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &ss0
 * 
 * overloaded args:
 * @param	const QLatin1String &s
 * 
 * overloaded args:
 * @param	const char *s
 * 
 * overloaded args:
 * @param	const QByteArray &s
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method arg
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	qlonglong as0
 * @param	 int fieldwidth=0s1
 * @param	 int base=10s2
 * @param	 const QChar &fillChar = QLatin1Char(' ')s3
 * 
 * overloaded args:
 * @param	qulonglong a
 * @param	 int fieldwidth=0
 * @param	 int base=10
 * @param	 const QChar &fillChar = QLatin1Char(' ')
 * 
 * overloaded args:
 * @param	long a
 * @param	 int fieldwidth=0
 * @param	 int base=10
 * @param	 const QChar &fillChar = QLatin1Char(' ')
 * 
 * overloaded args:
 * @param	ulong a
 * @param	 int fieldwidth=0
 * @param	 int base=10
 * @param	 const QChar &fillChar = QLatin1Char(' ')
 * 
 * overloaded args:
 * @param	int a
 * @param	 int fieldWidth = 0
 * @param	 int base = 10
 * @param	 const QChar &fillChar = QLatin1Char(' ')
 * 
 * overloaded args:
 * @param	uint a
 * @param	 int fieldWidth = 0
 * @param	 int base = 10
 * @param	 const QChar &fillChar = QLatin1Char(' ')
 * 
 * overloaded args:
 * @param	short a
 * @param	 int fieldWidth = 0
 * @param	 int base = 10
 * @param	 const QChar &fillChar = QLatin1Char(' ')
 * 
 * overloaded args:
 * @param	ushort a
 * @param	 int fieldWidth = 0
 * @param	 int base = 10
 * @param	 const QChar &fillChar = QLatin1Char(' ')
 * 
 * overloaded args:
 * @param	double a
 * @param	 int fieldWidth = 0
 * @param	 char fmt = 'g'
 * @param	 int prec = -1
 * @param	 const QChar &fillChar = QLatin1Char(' ')
 * 
 * overloaded args:
 * @param	char a
 * @param	 int fieldWidth = 0
 * @param	 const QChar &fillChar = QLatin1Char(' ')
 * 
 * overloaded args:
 * @param	QChar a
 * @param	 int fieldWidth = 0
 * @param	 const QChar &fillChar = QLatin1Char(' ')
 * 
 * overloaded args:
 * @param	const QString &a
 * @param	 int fieldWidth = 0
 * @param	 const QChar &fillChar = QLatin1Char(' ')
 * 
 * overloaded args:
 * @param	const QString &a1
 * @param	 const QString &a2
 * 
 * overloaded args:
 * @param	const QString &a1
 * @param	 const QString &a2
 * @param	 const QString &a3
 * 
 * overloaded args:
 * @param	const QString &a1
 * @param	 const QString &a2
 * @param	 const QString &a3
 * @param	 const QString &a4
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QString, arg)
{
// notice: unknown argument qlonglong as0, skipped

// notice: unknown argument qulonglong a, skipped

// notice: unknown argument long a, skipped

// notice: unknown argument ulong a, skipped

  ///int a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try int a,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((int)Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try int a, int fieldWidth = 0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try int a, int fieldWidth = 0, int base = 10,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_OBJECT) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try int a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' '),
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      QChar *cpp_arg_3 = static_cast < QChar * >(php_qt_fetch(arg_3));
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (const QChar &)*cpp_arg_3));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///uint a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try uint a,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((uint) Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try uint a, int fieldWidth = 0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try uint a, int fieldWidth = 0, int base = 10,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_OBJECT) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try uint a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' '),
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      QChar *cpp_arg_3 = static_cast < QChar * >(php_qt_fetch(arg_3));
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object =
        static_cast < QString > (selfpointer->arg((uint) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (const QChar &)*cpp_arg_3));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///short a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try short a,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((short)Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try short a, int fieldWidth = 0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((short)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try short a, int fieldWidth = 0, int base = 10,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((short)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_OBJECT) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try short a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' '),
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      QChar *cpp_arg_3 = static_cast < QChar * >(php_qt_fetch(arg_3));
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object =
        static_cast < QString > (selfpointer->arg((short)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (const QChar &)*cpp_arg_3));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///ushort a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try ushort a,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((ushort) Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try ushort a, int fieldWidth = 0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((ushort) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try ushort a, int fieldWidth = 0, int base = 10,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((ushort) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG && Z_TYPE_P(arg_3) == IS_OBJECT) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try ushort a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' '),
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      QChar *cpp_arg_3 = static_cast < QChar * >(php_qt_fetch(arg_3));
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object =
        static_cast < QString > (selfpointer->arg((ushort) Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (int)Z_LVAL_P(arg_2), (const QChar &)*cpp_arg_3));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///double a, int fieldWidth = 0, char fmt = 'g', int prec = -1, const QChar &fillChar = QLatin1Char(' ')
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try double a,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((double)Z_DVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try double a, int fieldWidth = 0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((double)Z_DVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_STRING) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try double a, int fieldWidth = 0, char fmt = 'g',
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((double)Z_DVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (char)Z_STRVAL_P(arg_2)[0]));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_STRING && Z_TYPE_P(arg_3) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try double a, int fieldWidth = 0, char fmt = 'g', int prec = -1,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object =
        static_cast < QString > (selfpointer->arg((double)Z_DVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (char)Z_STRVAL_P(arg_2)[0], (int)Z_LVAL_P(arg_3)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 5) {
    PHP_QT_FETCH_5_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_DOUBLE && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_STRING && Z_TYPE_P(arg_3) == IS_LONG &&
        Z_TYPE_P(arg_4) == IS_OBJECT) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try double a, int fieldWidth = 0, char fmt = 'g', int prec = -1, const QChar &fillChar = QLatin1Char(' '),
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      QChar *cpp_arg_4 = static_cast < QChar * >(php_qt_fetch(arg_4));
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object =
        static_cast < QString >
        (selfpointer->arg((double)Z_DVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (char)Z_STRVAL_P(arg_2)[0], (int)Z_LVAL_P(arg_3), (const QChar &)*cpp_arg_4));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///char a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' ')
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try char a,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((char)Z_STRVAL_P(arg_0)[0]));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try char a, int fieldWidth = 0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((char)Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'arg' is not static");
        RETURN_NULL();
      }
      /// try char a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' '),
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      QChar *cpp_arg_2 = static_cast < QChar * >(php_qt_fetch(arg_2));
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->arg((char)Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1), (const QChar &)*cpp_arg_2));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///QChar a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' ')
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'arg' is not static");
          RETURN_NULL();
        }
        /// try QChar a,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object = static_cast < QString > (selfpointer->arg((QChar) * cpp_arg_0));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'arg' is not static");
          RETURN_NULL();
        }
        /// try QChar a, int fieldWidth = 0,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object = static_cast < QString > (selfpointer->arg((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1)));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'arg' is not static");
          RETURN_NULL();
        }
        /// try QChar a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' '),
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        QChar *cpp_arg_2 = static_cast < QChar * >(php_qt_fetch(arg_2));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object = static_cast < QString > (selfpointer->arg((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QChar &)*cpp_arg_2));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///const QString &a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' ')
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'arg' is not static");
          RETURN_NULL();
        }
        /// try const QString &a,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object = static_cast < QString > (selfpointer->arg((const QString &)*cpp_arg_0));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'arg' is not static");
          RETURN_NULL();
        }
        /// try const QString &a, int fieldWidth = 0,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object = static_cast < QString > (selfpointer->arg((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'arg' is not static");
          RETURN_NULL();
        }
        /// try const QString &a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' '),
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QChar *cpp_arg_2 = static_cast < QChar * >(php_qt_fetch(arg_2));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object = static_cast < QString > (selfpointer->arg((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (const QChar &)*cpp_arg_2));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///const QString &a1, const QString &a2
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_1 = invokeToQString(arg_1);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QString
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'arg' is not static");
          RETURN_NULL();
        }
        /// try const QString &a1, const QString &a2,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object = static_cast < QString > (selfpointer->arg((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
#endif // return type


  ///const QString &a1, const QString &a2, const QString &a3
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    arg_2 = invokeToQString(arg_2);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QString
#ifdef PHP_QT_QString
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59) && inherits(Z_OBJCE_P(arg_2), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'arg' is not static");
          RETURN_NULL();
        }
        /// try const QString &a1, const QString &a2, const QString &a3,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
        QString *cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object = static_cast < QString > (selfpointer->arg((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1, (const QString &)*cpp_arg_2));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

#endif

    }
  }
#endif // return type


  ///const QString &a1, const QString &a2, const QString &a3, const QString &a4
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    arg_3 = invokeToQString(arg_3);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_OBJECT) {
#ifdef PHP_QT_QString
#ifdef PHP_QT_QString
#ifdef PHP_QT_QString
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59) && inherits(Z_OBJCE_P(arg_2), 59) && inherits(Z_OBJCE_P(arg_3), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'arg' is not static");
          RETURN_NULL();
        }
        /// try const QString &a1, const QString &a2, const QString &a3, const QString &a4,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
        QString *cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));
        QString *cpp_arg_3 = static_cast < QString * >(php_qt_fetch(arg_3));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object =
          static_cast < QString >
          (selfpointer->arg((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1, (const QString &)*cpp_arg_2, (const QString &)*cpp_arg_3));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

#endif

#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::arg(...) ");
}

/*!
 * method isEmpty
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QString, isEmpty)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isEmpty' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isEmpty());
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::isEmpty(...) ");
}

/*!
 * method vsprintf
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const char *formats0
 * @param	 va_list aps1
 * 
 * @access	public
 * @return	QString &
 * @flags	
 */

ZEND_METHOD(QString, vsprintf)
{
// notice: unknown argument  va_list aps1, skipped
  php_error(E_ERROR, "could not parse argument in QString::vsprintf(...) ");
}

/*!
 * method toFloat
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool *ok=0s0
 * 
 * @access	public
 * @return	float
 * @flags	c
 */

ZEND_METHOD(QString, toFloat)
{
  ///bool *ok=0s0
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toFloat' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_DOUBLE(selfpointer->toFloat());
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toFloat' is not static");
        RETURN_NULL();
      }
      /// try bool *ok=0s0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_DOUBLE(selfpointer->toFloat((bool *) & Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::toFloat(...) ");
}

/*!
 * method operator>
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &ss0
 * 
 * overloaded args:
 * @param	const QLatin1String &s
 * 
 * overloaded args:
 * @param	const char *s2
 * 
 * overloaded args:
 * @param	const QByteArray &s
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method isDetached
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QString, isDetached)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isDetached' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isDetached());
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::isDetached(...) ");
}

/*!
 * method toULong
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool *ok=0s0
 * @param	 int base=10s1
 * 
 * @access	public
 * @return	ulong
 * @flags	c
 */

ZEND_METHOD(QString, toULong)
{
  ///bool *ok=0s0, int base=10s1
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type ulong");
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      php_error(E_ERROR, "unsupported return type ulong");
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
      php_error(E_ERROR, "unsupported return type ulong");
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::toULong(...) ");
}

/*!
 * method reserve
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int sizes0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QString, reserve)
{
  ///int sizes0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'reserve' is not static");
        RETURN_NULL();
      }
      /// try int sizes0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->reserve((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::reserve(...) ");
}

/*!
 * method toShort
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool *ok=0s0
 * @param	 int base=10s1
 * 
 * @access	public
 * @return	short
 * @flags	c
 */

ZEND_METHOD(QString, toShort)
{
  ///bool *ok=0s0, int base=10s1
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toShort' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->toShort());
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toShort' is not static");
        RETURN_NULL();
      }
      /// try bool *ok=0s0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->toShort((bool *) & Z_LVAL_P(arg_0)));
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toShort' is not static");
        RETURN_NULL();
      }
      /// try bool *ok=0s0, int base=10s1,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->toShort((bool *) & Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::toShort(...) ");
}

/*!
 * method split
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &seps0
 * @param	 SplitBehavior behavior = KeepEmptyPartss1
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives2
 * 
 * overloaded args:
 * @param	const QChar &sep
 * @param	 SplitBehavior behavior = KeepEmptyParts
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
 * 
 * overloaded args:
 * @param	const QRegExp &sep
 * @param	 SplitBehavior behavior = KeepEmptyParts
 * 
 * @access	public
 * @return	QStringList
 * @flags	c
 */

ZEND_METHOD(QString, split)
{
  ///const QString &seps0, SplitBehavior behavior = KeepEmptyPartss1, Qt::CaseSensitivity cs = Qt::CaseSensitives2
#ifdef PHP_QT_QStringList       // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'split' is not static");
          RETURN_NULL();
        }
        /// try const QString &seps0,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QStringList *return_object = new QStringList;

        *return_object = static_cast < QStringList > (selfpointer->split((const QString &)*cpp_arg_0));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
// notice: unknown argument  SplitBehavior behavior = KeepEmptyPartss1, skipped
#endif // return type


  ///const QChar &sep, SplitBehavior behavior = KeepEmptyParts, Qt::CaseSensitivity cs = Qt::CaseSensitive
#ifdef PHP_QT_QStringList       // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'split' is not static");
          RETURN_NULL();
        }
        /// try const QChar &sep,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QStringList *return_object = new QStringList;

        *return_object = static_cast < QStringList > (selfpointer->split((const QChar &)*cpp_arg_0));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
// notice: unknown argument  SplitBehavior behavior = KeepEmptyParts, skipped
#endif // return type


  ///const QRegExp &sep, SplitBehavior behavior = KeepEmptyParts
#ifdef PHP_QT_QStringList       // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRegExp
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'split' is not static");
          RETURN_NULL();
        }
        /// try const QRegExp &sep,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QStringList *return_object = new QStringList;

        *return_object = static_cast < QStringList > (selfpointer->split((const QRegExp &)*cpp_arg_0));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
// notice: unknown argument  SplitBehavior behavior = KeepEmptyParts, skipped
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::split(...) ");
}

/*!
 * method setUnicode
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QChar *unicodes0
 * @param	 int sizes1
 * 
 * @access	public
 * @return	QString &
 * @flags	
 */

ZEND_METHOD(QString, setUnicode)
{
  ///const QChar *unicodes0, int sizes1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setUnicode' is not static");
          RETURN_NULL();
        }
        /// try const QChar *unicodes0, int sizes1,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->setUnicode((const QChar *)cpp_arg_0, (int)Z_LVAL_P(arg_1)));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::setUnicode(...) ");
}

/*!
 * method fromLatin1
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const char *s0
 * @param	 int size = -1s1
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QString, fromLatin1)
{
  ///const char *s0, int size = -1s1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      /// try const char *s0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QString::fromLatin1((const char *)&Z_STRVAL_P(arg_0)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->fromLatin1((const char *)&Z_STRVAL_P(arg_0)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_LONG) {
      /// try const char *s0, int size = -1s1,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QString::fromLatin1((const char *)&Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
      } else {
        *return_object = static_cast < QString > (selfpointer->fromLatin1((const char *)&Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::fromLatin1(...) ");
}

/*!
 * method toLatin1
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QByteArray
 * @flags	c
 */

ZEND_METHOD(QString, toLatin1)
{
  ///
#ifdef PHP_QT_QByteArray        // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toLatin1' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QByteArray *return_object = new QByteArray;

      *return_object = static_cast < QByteArray > (selfpointer->toLatin1());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::toLatin1(...) ");
}

/*!
 * method data
 * 
 * @param: -
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QChar *
 * @flags	
 */

ZEND_METHOD(QString, data)
{
  ///
#ifdef PHP_QT_QChar             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'data' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = static_cast < QChar * >(selfpointer->data());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///
#ifdef PHP_QT_QChar             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'data' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = const_cast < QChar * >(selfpointer->data());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::data(...) ");
}

/*!
 * method end
 * 
 * @param: -
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	iterator
 * @flags	
 */

ZEND_METHOD(QString, end)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type iterator");
    }
  }
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type const_iterator");
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::end(...) ");
}

/*!
 * method contains
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QChar cs0
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives1
 * 
 * overloaded args:
 * @param	const QString &s
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
 * 
 * overloaded args:
 * @param	const QRegExp &rx
 * 
 * @access	public
 * @return	QBool
 * @flags	c
 */

ZEND_METHOD(QString, contains)
{
  ///QChar cs0, Qt::CaseSensitivity cs = Qt::CaseSensitives1
#ifdef PHP_QT_QBool             // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'contains' is not static");
          RETURN_NULL();
        }
        /// try QChar cs0,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QBool *return_object = new QBool;

        *return_object = static_cast < QBool > (selfpointer->contains((QChar) * cpp_arg_0));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'contains' is not static");
          RETURN_NULL();
        }
        /// try QChar cs0, Qt::CaseSensitivity cs = Qt::CaseSensitives1,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QBool *return_object = new QBool;

        *return_object = static_cast < QBool > (selfpointer->contains((QChar) * cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive
#ifdef PHP_QT_QBool             // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'contains' is not static");
          RETURN_NULL();
        }
        /// try const QString &s,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QBool *return_object = new QBool;

        *return_object = static_cast < QBool > (selfpointer->contains((const QString &)*cpp_arg_0));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'contains' is not static");
          RETURN_NULL();
        }
        /// try const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QBool *return_object = new QBool;

        *return_object = static_cast < QBool > (selfpointer->contains((const QString &)*cpp_arg_0, (Qt::CaseSensitivity) Z_LVAL_P(arg_1)));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///const QRegExp &rx
#ifdef PHP_QT_QBool             // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRegExp
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'contains' is not static");
          RETURN_NULL();
        }
        /// try const QRegExp &rx,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QBool *return_object = new QBool;

        *return_object = static_cast < QBool > (selfpointer->contains((const QRegExp &)*cpp_arg_0));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::contains(...) ");
}

/*!
 * method replace
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int is0
 * @param	 int lens1
 * @param	 QChar afters2
 * 
 * overloaded args:
 * @param	int i
 * @param	 int len
 * @param	 const QChar *s
 * @param	 int slen
 * 
 * overloaded args:
 * @param	int i
 * @param	 int len
 * @param	 const QString &after
 * 
 * overloaded args:
 * @param	QChar before
 * @param	 QChar after
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
 * 
 * overloaded args:
 * @param	QChar c
 * @param	 const QString &after
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
 * 
 * overloaded args:
 * @param	const QString &before
 * @param	 const QString &after
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
 * 
 * overloaded args:
 * @param	const QRegExp &rx
 * @param	 const QString &after
 * 
 * @access	public
 * @return	QString &
 * @flags	
 */

ZEND_METHOD(QString, replace)
{
  ///int is0, int lens1, QChar afters2
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_2), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'replace' is not static");
          RETURN_NULL();
        }
        /// try int is0, int lens1, QChar afters2,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_2 = static_cast < QChar * >(php_qt_fetch(arg_2));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->replace((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (QChar) * cpp_arg_2));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///int i, int len, const QChar *s, int slen
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 4) {
    PHP_QT_FETCH_4_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT && Z_TYPE_P(arg_3) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_2), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'replace' is not static");
          RETURN_NULL();
        }
        /// try int i, int len, const QChar *s, int slen,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_2 = static_cast < QChar * >(php_qt_fetch(arg_2));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->replace((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QChar *)cpp_arg_2, (int)Z_LVAL_P(arg_3)));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///int i, int len, const QString &after
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    arg_2 = invokeToQString(arg_2);

    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_2), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'replace' is not static");
          RETURN_NULL();
        }
        /// try int i, int len, const QString &after,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_2 = static_cast < QString * >(php_qt_fetch(arg_2));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->replace((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1), (const QString &)*cpp_arg_2));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///QChar before, QChar after, Qt::CaseSensitivity cs = Qt::CaseSensitive
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QChar
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6) && inherits(Z_OBJCE_P(arg_1), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'replace' is not static");
          RETURN_NULL();
        }
        /// try QChar before, QChar after,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->replace((QChar) * cpp_arg_0, (QChar) * cpp_arg_1));
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QChar
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6) && inherits(Z_OBJCE_P(arg_1), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'replace' is not static");
          RETURN_NULL();
        }
        /// try QChar before, QChar after, Qt::CaseSensitivity cs = Qt::CaseSensitive,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->replace((QChar) * cpp_arg_0, (QChar) * cpp_arg_1, (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
#endif // return type


  ///QChar c, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_1 = invokeToQString(arg_1);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QChar
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 6) && inherits(Z_OBJCE_P(arg_1), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'replace' is not static");
          RETURN_NULL();
        }
        /// try QChar c, const QString &after,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->replace((QChar) * cpp_arg_0, (const QString &)*cpp_arg_1));
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    arg_1 = invokeToQString(arg_1);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QChar
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 6) && inherits(Z_OBJCE_P(arg_1), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'replace' is not static");
          RETURN_NULL();
        }
        /// try QChar c, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->replace((QChar) * cpp_arg_0, (const QString &)*cpp_arg_1, (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
#endif // return type


  ///const QString &before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_1 = invokeToQString(arg_1);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QString
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'replace' is not static");
          RETURN_NULL();
        }
        /// try const QString &before, const QString &after,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->replace((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    arg_1 = invokeToQString(arg_1);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QString
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'replace' is not static");
          RETURN_NULL();
        }
        /// try const QString &before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr =
          &static_cast < QString & >(selfpointer->replace((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1, (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
#endif // return type


  ///const QRegExp &rx, const QString &after
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_1 = invokeToQString(arg_1);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QRegExp
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'replace' is not static");
          RETURN_NULL();
        }
        /// try const QRegExp &rx, const QString &after,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));
        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->replace((const QRegExp &)*cpp_arg_0, (const QString &)*cpp_arg_1));
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::replace(...) ");
}

/*!
 * method operator+=
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QChar cs0
 * 
 * overloaded args:
 * @param	QChar::SpecialCharacter c
 * 
 * overloaded args:
 * @param	const QString &s
 * 
 * overloaded args:
 * @param	const QLatin1String &s
 * 
 * overloaded args:
 * @param	const char *s
 * 
 * overloaded args:
 * @param	const QByteArray &s
 * 
 * overloaded args:
 * @param	char c
 * 
 * overloaded args:
 * @param	const char *s
 * 
 * overloaded args:
 * @param	const QByteArray &s
 * 
 * @access	public
 * @return	QString &
 * @flags	
 */

/*!
 * method resize
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int sizes0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QString, resize)
{
  ///int sizes0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'resize' is not static");
        RETURN_NULL();
      }
      /// try int sizes0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->resize((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::resize(...) ");
}

/*!
 * method fromUtf8
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const char *s0
 * @param	 int size = -1s1
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QString, fromUtf8)
{
  ///const char *s0, int size = -1s1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      /// try const char *s0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QString::fromUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->fromUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_LONG) {
      /// try const char *s0, int size = -1s1,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QString::fromUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
      } else {
        *return_object = static_cast < QString > (selfpointer->fromUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (int)Z_LVAL_P(arg_1)));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::fromUtf8(...) ");
}

/*!
 * method toLong
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool *ok=0s0
 * @param	 int base=10s1
 * 
 * @access	public
 * @return	long
 * @flags	c
 */

ZEND_METHOD(QString, toLong)
{
  ///bool *ok=0s0, int base=10s1
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type long");
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      php_error(E_ERROR, "unsupported return type long");
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
      php_error(E_ERROR, "unsupported return type long");
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::toLong(...) ");
}

/*!
 * method realloc
 * 
 * @param: -
 * @param: -
 * 
 * overloaded args:
 * @param	int alloc
 * 
 * @access	private
 * @return	void
 * @flags	
 */

ZEND_METHOD(QString, realloc)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
/// method is private, skip
      php_error(E_ERROR, "QString::realloc(...) cannot be called with ''.");
    }
  }
  ///int alloc
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
/// method is private, skip
      php_error(E_ERROR, "QString::realloc(...) cannot be called with 'int alloc,'.");
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::realloc(...) ");
}

/*!
 * method detach
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QString, detach)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'detach' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->detach());
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::detach(...) ");
}

/*!
 * method append
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QChar cs0
 * 
 * overloaded args:
 * @param	const QString &s
 * 
 * overloaded args:
 * @param	const QLatin1String &s
 * 
 * overloaded args:
 * @param	const char *s
 * 
 * overloaded args:
 * @param	const QByteArray &s
 * 
 * @access	public
 * @return	QString &
 * @flags	
 */

ZEND_METHOD(QString, append)
{
  ///QChar cs0
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'append' is not static");
          RETURN_NULL();
        }
        /// try QChar cs0,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->append((QChar) * cpp_arg_0));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///const QString &s
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'append' is not static");
          RETURN_NULL();
        }
        /// try const QString &s,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->append((const QString &)*cpp_arg_0));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///const QLatin1String &s
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QLatin1String
      if (inherits(Z_OBJCE_P(arg_0), 40)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'append' is not static");
          RETURN_NULL();
        }
        /// try const QLatin1String &s,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QLatin1String *cpp_arg_0 = static_cast < QLatin1String * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->append((const QLatin1String &)*cpp_arg_0));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///const char *s
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'append' is not static");
        RETURN_NULL();
      }
      /// try const char *s,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = &static_cast < QString & >(selfpointer->append((const char *)&Z_STRVAL_P(arg_0)[0]));
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///const QByteArray &s
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QByteArray
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'append' is not static");
          RETURN_NULL();
        }
        /// try const QByteArray &s,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QByteArray *cpp_arg_0 = static_cast < QByteArray * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->append((const QByteArray &)*cpp_arg_0));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::append(...) ");
}

/*!
 * method operator<=
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &ss0
 * 
 * overloaded args:
 * @param	const QLatin1String &s
 * 
 * overloaded args:
 * @param	const char *s2
 * 
 * overloaded args:
 * @param	const QByteArray &s
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method multiArg
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int numArgss0
 * @param	 const QString **argss1
 * 
 * @access	private
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QString, multiArg)
{
  ///int numArgss0, const QString **argss1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_1 = invokeToQString(arg_1);

    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_1), 59)) {
/// method is private, skip
        php_error(E_ERROR, "QString::multiArg(...) cannot be called with 'int numArgss0, const QString **argss1,'.");
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::multiArg(...) ");
}

/*!
 * method toDouble
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool *ok=0s0
 * 
 * @access	public
 * @return	double
 * @flags	c
 */

ZEND_METHOD(QString, toDouble)
{
  ///bool *ok=0s0
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toDouble' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_DOUBLE(selfpointer->toDouble());
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toDouble' is not static");
        RETURN_NULL();
      }
      /// try bool *ok=0s0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_DOUBLE(selfpointer->toDouble((bool *) & Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::toDouble(...) ");
}

/*!
 * method mid
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int is0
 * @param	 int len = -1s1
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QString, mid)
{
  ///int is0, int len = -1s1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'mid' is not static");
        RETURN_NULL();
      }
      /// try int is0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->mid((int)Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'mid' is not static");
        RETURN_NULL();
      }
      /// try int is0, int len = -1s1,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->mid((int)Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::mid(...) ");
}

/*!
 * method fill
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QChar cs0
 * @param	 int size = -1s1
 * 
 * @access	public
 * @return	QString &
 * @flags	
 */

ZEND_METHOD(QString, fill)
{
  ///QChar cs0, int size = -1s1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'fill' is not static");
          RETURN_NULL();
        }
        /// try QChar cs0,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->fill((QChar) * cpp_arg_0));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'fill' is not static");
          RETURN_NULL();
        }
        /// try QChar cs0, int size = -1s1,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;

        le.ptr = &static_cast < QString & >(selfpointer->fill((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1)));
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::fill(...) ");
}

/*!
 * method free
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Data *s0
 * 
 * @access	private
 * @return	void
 * @flags	s
 */

ZEND_METHOD(QString, free)
{
// notice: unknown argument Data *s0, skipped
  php_error(E_ERROR, "could not parse argument in QString::free(...) ");
}

/*!
 * method toLower
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QString, toLower)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toLower' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->toLower());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::toLower(...) ");
}

/*!
 * method rightJustified
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int widths0
 * @param	 QChar fill = QLatin1Char(' ')s1
 * @param	 bool trunc = falses2
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QString, rightJustified)
{
  ///int widths0, QChar fill = QLatin1Char(' ')s1, bool trunc = falses2
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'rightJustified' is not static");
        RETURN_NULL();
      }
      /// try int widths0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->rightJustified((int)Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'rightJustified' is not static");
        RETURN_NULL();
      }
      /// try int widths0, QChar fill = QLatin1Char(' ')s1,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->rightJustified((int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'rightJustified' is not static");
        RETURN_NULL();
      }
      /// try int widths0, QChar fill = QLatin1Char(' ')s1, bool trunc = falses2,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      QChar *cpp_arg_1 = static_cast < QChar * >(php_qt_fetch(arg_1));
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->rightJustified((int)Z_LVAL_P(arg_0), (QChar) * cpp_arg_1, (bool) Z_LVAL_P(arg_2)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::rightJustified(...) ");
}

/*!
 * method lastIndexOf
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QChar cs0
 * @param	 int from = -1s1
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitives2
 * 
 * overloaded args:
 * @param	const QString &s
 * @param	 int from = -1
 * @param	 Qt::CaseSensitivity cs = Qt::CaseSensitive
 * 
 * overloaded args:
 * @param	const QRegExp &
 * @param	 int from = -1
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QString, lastIndexOf)
{
  ///QChar cs0, int from = -1s1, Qt::CaseSensitivity cs = Qt::CaseSensitives2
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'lastIndexOf' is not static");
          RETURN_NULL();
        }
        /// try QChar cs0,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->lastIndexOf((QChar) * cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'lastIndexOf' is not static");
          RETURN_NULL();
        }
        /// try QChar cs0, int from = -1s1,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->lastIndexOf((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'lastIndexOf' is not static");
          RETURN_NULL();
        }
        /// try QChar cs0, int from = -1s1, Qt::CaseSensitivity cs = Qt::CaseSensitives2,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->lastIndexOf((QChar) * cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
      }
#endif

    }
  }
  ///const QString &s, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'lastIndexOf' is not static");
          RETURN_NULL();
        }
        /// try const QString &s,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->lastIndexOf((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'lastIndexOf' is not static");
          RETURN_NULL();
        }
        /// try const QString &s, int from = -1,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->lastIndexOf((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'lastIndexOf' is not static");
          RETURN_NULL();
        }
        /// try const QString &s, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->lastIndexOf((const QString &)*cpp_arg_0, (int)Z_LVAL_P(arg_1), (Qt::CaseSensitivity) Z_LVAL_P(arg_2)));
      }
#endif

    }
  }
  ///const QRegExp &, int from = -1
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRegExp
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'lastIndexOf' is not static");
          RETURN_NULL();
        }
        /// try const QRegExp &,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->lastIndexOf((const QRegExp &)*cpp_arg_0));
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QRegExp
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'lastIndexOf' is not static");
          RETURN_NULL();
        }
        /// try const QRegExp &, int from = -1,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QRegExp *cpp_arg_0 = static_cast < QRegExp * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->lastIndexOf((const QRegExp &)*cpp_arg_0, (int)Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QString::lastIndexOf(...) ");
}

/*!
 * method unicode
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const QChar *
 * @flags	c
 */

ZEND_METHOD(QString, unicode)
{
  ///
#ifdef PHP_QT_QChar             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'unicode' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = const_cast < QChar * >(selfpointer->unicode());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::unicode(...) ");
}

/*!
 * method at
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int is0
 * 
 * @access	public
 * @return	const QChar
 * @flags	c
 */

ZEND_METHOD(QString, at)
{
  ///int is0
#ifdef PHP_QT_QChar             // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'at' is not static");
        RETURN_NULL();
      }
      /// try int is0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QChar *return_object = new QChar;

      *return_object = const_cast < QChar > (selfpointer->at((int)Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::at(...) ");
}

/*!
 * method begin
 * 
 * @param: -
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	iterator
 * @flags	
 */

ZEND_METHOD(QString, begin)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type iterator");
    }
  }
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type const_iterator");
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::begin(...) ");
}

/*!
 * method sprintf
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const char *formats0
 * @param	 ...  ...s1
 * 
 * @access	public
 * @return	QString &
 * @flags	
 */

ZEND_METHOD(QString, sprintf)
{
// notice: unknown argument  ...  ...s1, skipped
  php_error(E_ERROR, "could not parse argument in QString::sprintf(...) ");
}

/*!
 * method push_back
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QChar cs0
 * 
 * overloaded args:
 * @param	const QString &s
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QString, push_back)
{
  ///QChar cs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QChar
      if (inherits(Z_OBJCE_P(arg_0), 6)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'push_back' is not static");
          RETURN_NULL();
        }
        /// try QChar cs0,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QChar *cpp_arg_0 = static_cast < QChar * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->push_back((QChar) * cpp_arg_0));
      }
#endif

    }
  }
  ///const QString &s
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'push_back' is not static");
          RETURN_NULL();
        }
        /// try const QString &s,
        QString *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QString * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->push_back((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QString::push_back(...) ");
}

/*!
 * method capacity
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QString, capacity)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'capacity' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->capacity());
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::capacity(...) ");
}

/*!
 * method constBegin
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const_iterator
 * @flags	c
 */

ZEND_METHOD(QString, constBegin)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type const_iterator");
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::constBegin(...) ");
}

/*!
 * method toInt
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool *ok=0s0
 * @param	 int base=10s1
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QString, toInt)
{
  ///bool *ok=0s0, int base=10s1
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toInt' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->toInt());
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toInt' is not static");
        RETURN_NULL();
      }
      /// try bool *ok=0s0,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->toInt((bool *) & Z_LVAL_P(arg_0)));
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL && Z_TYPE_P(arg_1) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toInt' is not static");
        RETURN_NULL();
      }
      /// try bool *ok=0s0, int base=10s1,
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->toInt((bool *) & Z_LVAL_P(arg_0), (int)Z_LVAL_P(arg_1)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::toInt(...) ");
}

/*!
 * method toLocal8Bit
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QByteArray
 * @flags	c
 */

ZEND_METHOD(QString, toLocal8Bit)
{
  ///
#ifdef PHP_QT_QByteArray        // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toLocal8Bit' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QByteArray *return_object = new QByteArray;

      *return_object = static_cast < QByteArray > (selfpointer->toLocal8Bit());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QString::toLocal8Bit(...) ");
}

/*!
 * method isNull
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QString, isNull)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isNull' is not static");
        RETURN_NULL();
      }
      /// try 
      QString *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QString * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isNull());
    }
  }
  php_error(E_ERROR, "could not parse argument in QString::isNull(...) ");
}

/*!
 * method operator=
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QChar cs0
 * 
 * overloaded args:
 * @param	const QString &
 * 
 * overloaded args:
 * @param	const QLatin1String &
 * 
 * overloaded args:
 * @param	const char *ch
 * 
 * overloaded args:
 * @param	const QByteArray &a
 * 
 * overloaded args:
 * @param	char c
 * 
 * overloaded args:
 * @param	const Null &
 * 
 * overloaded args:
 * @param	const char *ch
 * 
 * overloaded args:
 * @param	const QByteArray &a
 * 
 * @access	public
 * @return	QString &
 * @flags	
 */

/*!
 * method operator>=
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &ss0
 * 
 * overloaded args:
 * @param	const QLatin1String &s
 * 
 * overloaded args:
 * @param	const char *s2
 * 
 * overloaded args:
 * @param	const QByteArray &s
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */
