/*
 * PHP-Qt - The PHP language bindings for Qt
 *
 * Copyright (C) 2006
 * Thomas Moenicke <tm@ippfp.org>,
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * QChar.cpp - QChar PHP implementation.
 * begin           : Tue Jun  6 22:42:56 2006
 * generated by    : moni using kalyptus 0.9.
 */

#include <iostream>
using namespace std;

#include "../php_qt.h"


#include <QChar>
#include <QMetaMethod>
class QChar_php_qt:public QChar
{

public:
  QChar_php_qt(zval * zend_ptr);
  QChar_php_qt(zval * zend_ptr, char cs0);
    QChar_php_qt(zval * zend_ptr, uchar cs0);
    QChar_php_qt(zval * zend_ptr, QLatin1Char chs0);
    QChar_php_qt(zval * zend_ptr, uchar cs0, uchar rs1);
    QChar_php_qt(zval * zend_ptr, ushort rcs0);
    QChar_php_qt(zval * zend_ptr, short rcs0);
    QChar_php_qt(zval * zend_ptr, uint rcs0);
    QChar_php_qt(zval * zend_ptr, int rcs0);
    QChar_php_qt(zval * zend_ptr, SpecialCharacter scs0);


  zval *zend_ptr;
};

QChar_php_qt::QChar_php_qt(zval * zend_ptr):QChar()
{
  this->zend_ptr = zend_ptr;
}
QChar_php_qt::QChar_php_qt(zval * zend_ptr, char cs0):
QChar(cs0)
{
  this->zend_ptr = zend_ptr;
}

QChar_php_qt::QChar_php_qt(zval * zend_ptr, uchar cs0):QChar(cs0)
{
  this->zend_ptr = zend_ptr;
}

QChar_php_qt::QChar_php_qt(zval * zend_ptr, QLatin1Char chs0):QChar(chs0)
{
  this->zend_ptr = zend_ptr;
}

QChar_php_qt::QChar_php_qt(zval * zend_ptr, uchar cs0, uchar rs1):QChar(cs0, rs1)
{
  this->zend_ptr = zend_ptr;
}

QChar_php_qt::QChar_php_qt(zval * zend_ptr, ushort rcs0):QChar(rcs0)
{
  this->zend_ptr = zend_ptr;
}
QChar_php_qt::QChar_php_qt(zval * zend_ptr, short rcs0):
QChar(rcs0)
{
  this->zend_ptr = zend_ptr;
}

QChar_php_qt::QChar_php_qt(zval * zend_ptr, uint rcs0):QChar(rcs0)
{
  this->zend_ptr = zend_ptr;
}
QChar_php_qt::QChar_php_qt(zval * zend_ptr, int rcs0):
QChar(rcs0)
{
  this->zend_ptr = zend_ptr;
}

QChar_php_qt::QChar_php_qt(zval * zend_ptr, SpecialCharacter scs0):QChar(scs0)
{
  this->zend_ptr = zend_ptr;
}

/*!
 * method row
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	uchar
 * @flags	c
 */

ZEND_METHOD(QChar, row)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type uchar");
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::row(...) ");
}

/*!
 * method isSymbol
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QChar, isSymbol)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isSymbol' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isSymbol());
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::isSymbol(...) ");
}

/*!
 * method category
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Category
 * @flags	c
 */

ZEND_METHOD(QChar, category)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type Category");
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::category(...) ");
}

/*!
 * method isPrint
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QChar, isPrint)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isPrint' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isPrint());
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::isPrint(...) ");
}

/*!
 * method digitValue
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QChar, digitValue)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'digitValue' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->digitValue());
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::digitValue(...) ");
}

/*!
 * method mirroredChar
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QChar
 * @flags	c
 */

ZEND_METHOD(QChar, mirroredChar)
{
  ///
#ifdef PHP_QT_QChar             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'mirroredChar' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QChar *
        return_object = new QChar;

      *return_object = static_cast < QChar > (selfpointer->mirroredChar());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QChar::mirroredChar(...) ");
}

/*!
 * method fromAscii
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	char cs0
 * 
 * @access	public
 * @return	QChar
 * @flags	s
 */

ZEND_METHOD(QChar, fromAscii)
{
  ///char cs0
#ifdef PHP_QT_QChar             // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      /// try char cs0,
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QChar *
        return_object = new QChar;

      if (getThis() == NULL) {
        *return_object = static_cast < QChar > (QChar::fromAscii((char)Z_STRVAL_P(arg_0)[0]));
      } else {
        *return_object = static_cast < QChar > (selfpointer->fromAscii((char)Z_STRVAL_P(arg_0)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QChar::fromAscii(...) ");
}

/*!
 * method isSpace
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QChar, isSpace)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isSpace' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isSpace());
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::isSpace(...) ");
}

/*!
 * method decomposition
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QChar, decomposition)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'decomposition' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QString *
        return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->decomposition());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QChar::decomposition(...) ");
}

/*!
 * method toUpper
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QChar
 * @flags	c
 */

ZEND_METHOD(QChar, toUpper)
{
  ///
#ifdef PHP_QT_QChar             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toUpper' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QChar *
        return_object = new QChar;

      *return_object = static_cast < QChar > (selfpointer->toUpper());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QChar::toUpper(...) ");
}

/*!
 * method isPunct
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QChar, isPunct)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isPunct' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isPunct());
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::isPunct(...) ");
}

/*!
 * method direction
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Direction
 * @flags	c
 */

ZEND_METHOD(QChar, direction)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type Direction");
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::direction(...) ");
}

/*!
 * method hasMirrored
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QChar, hasMirrored)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'hasMirrored' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->hasMirrored());
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::hasMirrored(...) ");
}

/*!
 * method setRow
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	uchar rows0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QChar, setRow)
{
// notice: unknown argument uchar rows0, skipped
  php_error(E_ERROR, "could not parse argument in QChar::setRow(...) ");
}

/*!
 * method isLetter
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QChar, isLetter)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isLetter' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isLetter());
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::isLetter(...) ");
}

/*!
 * method unicodeVersion
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	UnicodeVersion
 * @flags	c
 */

ZEND_METHOD(QChar, unicodeVersion)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type UnicodeVersion");
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::unicodeVersion(...) ");
}

/*!
 * method toAscii
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const char
 * @flags	c
 */

ZEND_METHOD(QChar, toAscii)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toAscii' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_STRING((char *)selfpointer->toAscii(), 1);
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::toAscii(...) ");
}

/*!
 * method combiningClass
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	unsigned char
 * @flags	c
 */

ZEND_METHOD(QChar, combiningClass)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'combiningClass' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_STRING((char *)selfpointer->combiningClass(), 1);
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::combiningClass(...) ");
}

/*!
 * method isUpper
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QChar, isUpper)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isUpper' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isUpper());
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::isUpper(...) ");
}

/*!
 * method joining
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Joining
 * @flags	c
 */

ZEND_METHOD(QChar, joining)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type Joining");
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::joining(...) ");
}

/*!
 * method QChar
 * 
 * @param: -
 * @param: -
 * 
 * overloaded args:
 * @param	char cs0
 * 
 * overloaded args:
 * @param	uchar cs0
 * 
 * overloaded args:
 * @param	QLatin1Char chs0
 * 
 * overloaded args:
 * @param	uchar cs0
 * @param	uchar rs1
 * 
 * overloaded args:
 * @param	ushort rcs0
 * 
 * overloaded args:
 * @param	short rcs0
 * 
 * overloaded args:
 * @param	uint rcs0
 * 
 * overloaded args:
 * @param	int rcs0
 * 
 * overloaded args:
 * @param	SpecialCharacter scs0
 * 
 * overloaded args:
 * @param	char c
 * 
 * overloaded args:
 * @param	uchar c
 * 
 * @access	public
 * @return	
 * @flags	
 */

ZEND_METHOD(QChar, __construct)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar_php_qt *
        selfpointer = new QChar_php_qt(getThis());

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  ///char cs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try char cs0,
      QChar_php_qt *
        selfpointer = new QChar_php_qt(getThis(), (char)Z_STRVAL_P(arg_0)[0]);

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
// notice: unknown argument uchar cs0, skipped

  ///QLatin1Char chs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QLatin1Char
      if (inherits(Z_OBJCE_P(arg_0), 39)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try QLatin1Char chs0,
        QLatin1Char *
          cpp_arg_0 = static_cast < QLatin1Char * >(php_qt_fetch(arg_0));
        QChar_php_qt *
          selfpointer = new QChar_php_qt(getThis(), (QLatin1Char) * cpp_arg_0);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
// notice: unknown argument uchar cs0, skipped

  ///ushort rcs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try ushort rcs0,
      QChar_php_qt *
        selfpointer = new QChar_php_qt(getThis(), (ushort) Z_LVAL_P(arg_0));

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  ///short rcs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try short rcs0,
      QChar_php_qt *
        selfpointer = new QChar_php_qt(getThis(), (short)Z_LVAL_P(arg_0));

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  ///uint rcs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try uint rcs0,
      QChar_php_qt *
        selfpointer = new QChar_php_qt(getThis(), (uint) Z_LVAL_P(arg_0));

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  ///int rcs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try int rcs0,
      QChar_php_qt *
        selfpointer = new QChar_php_qt(getThis(), (int)Z_LVAL_P(arg_0));

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
// notice: unknown argument SpecialCharacter scs0, skipped

  ///char c
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
/// method is private, skip
      php_error(E_ERROR, "QChar::__construct(...) cannot be called with 'char c,'.");
    }
  }
// notice: unknown argument uchar c, skipped
  php_error(E_ERROR, "could not parse argument in QChar::QChar(...) ");
}

/*!
 * method fromLatin1
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	char cs0
 * 
 * @access	public
 * @return	QChar
 * @flags	s
 */

ZEND_METHOD(QChar, fromLatin1)
{
  ///char cs0
#ifdef PHP_QT_QChar             // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      /// try char cs0,
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QChar *
        return_object = new QChar;

      if (getThis() == NULL) {
        *return_object = static_cast < QChar > (QChar::fromLatin1((char)Z_STRVAL_P(arg_0)[0]));
      } else {
        *return_object = static_cast < QChar > (selfpointer->fromLatin1((char)Z_STRVAL_P(arg_0)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QChar::fromLatin1(...) ");
}

/*!
 * method toLatin1
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const char
 * @flags	c
 */

ZEND_METHOD(QChar, toLatin1)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toLatin1' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_STRING((char *)selfpointer->toLatin1(), 1);
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::toLatin1(...) ");
}

/*!
 * method isDigit
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QChar, isDigit)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isDigit' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isDigit());
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::isDigit(...) ");
}

/*!
 * method decompositionTag
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Decomposition
 * @flags	c
 */

ZEND_METHOD(QChar, decompositionTag)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type Decomposition");
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::decompositionTag(...) ");
}

/*!
 * method isLower
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QChar, isLower)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isLower' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isLower());
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::isLower(...) ");
}

/*!
 * method toLower
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QChar
 * @flags	c
 */

ZEND_METHOD(QChar, toLower)
{
  ///
#ifdef PHP_QT_QChar             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toLower' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      zend_class_entry *
        ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry
        le;
      QChar *
        return_object = new QChar;

      *return_object = static_cast < QChar > (selfpointer->toLower());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QChar::toLower(...) ");
}

/*!
 * method unicode
 * 
 * @param: -
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const ushort
 * @flags	c
 */

ZEND_METHOD(QChar, unicode)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'unicode' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->unicode());
    }
  }
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'unicode' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->unicode());
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::unicode(...) ");
}

/*!
 * method cell
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	uchar
 * @flags	c
 */

ZEND_METHOD(QChar, cell)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type uchar");
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::cell(...) ");
}

/*!
 * method isLetterOrNumber
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QChar, isLetterOrNumber)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isLetterOrNumber' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isLetterOrNumber());
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::isLetterOrNumber(...) ");
}

/*!
 * method setCell
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	uchar cells0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QChar, setCell)
{
// notice: unknown argument uchar cells0, skipped
  php_error(E_ERROR, "could not parse argument in QChar::setCell(...) ");
}

/*!
 * method isNumber
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QChar, isNumber)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isNumber' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isNumber());
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::isNumber(...) ");
}

/*!
 * method isMark
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QChar, isMark)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isMark' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isMark());
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::isMark(...) ");
}

/*!
 * method isNull
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QChar, isNull)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isNull' is not static");
        RETURN_NULL();
      }
      /// try 
      QChar *
        selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QChar * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isNull());
    }
  }
  php_error(E_ERROR, "could not parse argument in QChar::isNull(...) ");
}
