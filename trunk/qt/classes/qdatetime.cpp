/*
 * PHP-Qt - The PHP language bindings for Qt
 *
 * Copyright (C) 2006
 * Thomas Moenicke <tm@ippfp.org>,
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * QDateTime.cpp - QDateTime PHP implementation.
 * begin           : Tue Jun  6 22:42:56 2006
 * generated by    : moni using kalyptus 0.9.
 */

#include <iostream>
using namespace std;

#include "../php_qt.h"


#include <QDateTime>
/// DEBUG:destructor skipped.
#include <QMetaMethod>
class QDateTime_php_qt:public QDateTime
{

public:
  QDateTime_php_qt(zval * zend_ptr);
  QDateTime_php_qt(zval * zend_ptr, const QDate & s0);
    QDateTime_php_qt(zval * zend_ptr, const QDate & s0, const QTime & s1, Qt::TimeSpec spec = Qt::LocalTime);
    QDateTime_php_qt(zval * zend_ptr, const QDateTime & others0);


  zval *zend_ptr;
};

QDateTime_php_qt::QDateTime_php_qt(zval * zend_ptr):QDateTime()
{
  this->zend_ptr = zend_ptr;
}
QDateTime_php_qt::QDateTime_php_qt(zval * zend_ptr, const QDate & s0):
QDateTime(s0)
{
  this->zend_ptr = zend_ptr;
}
QDateTime_php_qt::QDateTime_php_qt(zval * zend_ptr, const QDate & s0, const QTime & s1, Qt::TimeSpec spec):
QDateTime(s0, s1, spec)
{
  this->zend_ptr = zend_ptr;
}
QDateTime_php_qt::QDateTime_php_qt(zval * zend_ptr, const QDateTime & others0):
QDateTime(others0)
{
  this->zend_ptr = zend_ptr;
}

/*!
 * method date
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QDate
 * @flags	c
 */

ZEND_METHOD(QDateTime, date)
{
  ///
#ifdef PHP_QT_QDate             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'date' is not static");
        RETURN_NULL();
      }
      /// try 
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QDate *return_object = new QDate;

      *return_object = static_cast < QDate > (selfpointer->date());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDateTime::date(...) ");
}

/*!
 * method isValid
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QDateTime, isValid)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isValid' is not static");
        RETURN_NULL();
      }
      /// try 
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isValid());
    }
  }
  php_error(E_ERROR, "could not parse argument in QDateTime::isValid(...) ");
}

/*!
 * method toTime_t
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	uint
 * @flags	c
 */

ZEND_METHOD(QDateTime, toTime_t)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toTime_t' is not static");
        RETURN_NULL();
      }
      /// try 
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->toTime_t());
    }
  }
  php_error(E_ERROR, "could not parse argument in QDateTime::toTime_t(...) ");
}

/*!
 * method addDays
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int dayss0
 * 
 * @access	public
 * @return	QDateTime
 * @flags	c
 */

ZEND_METHOD(QDateTime, addDays)
{
  ///int dayss0
#ifdef PHP_QT_QDateTime         // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'addDays' is not static");
        RETURN_NULL();
      }
      /// try int dayss0,
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QDateTime *return_object = new QDateTime;

      *return_object = static_cast < QDateTime > (selfpointer->addDays((int)Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDateTime::addDays(...) ");
}

/*!
 * method fromString
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &ss0
 * @param	 Qt::DateFormat f = Qt::TextDates1
 * 
 * overloaded args:
 * @param	const QString &s
 * @param	 const QString &format
 * 
 * @access	public
 * @return	QDateTime
 * @flags	s
 */

ZEND_METHOD(QDateTime, fromString)
{
  ///const QString &ss0, Qt::DateFormat f = Qt::TextDates1
#ifdef PHP_QT_QDateTime         // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        /// try const QString &ss0,
        QDateTime *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QDateTime *return_object = new QDateTime;

        if (getThis() == NULL) {
          *return_object = static_cast < QDateTime > (QDateTime::fromString((const QString &)*cpp_arg_0));
        } else {
          *return_object = static_cast < QDateTime > (selfpointer->fromString((const QString &)*cpp_arg_0));
        } le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_0 = invokeToQString(arg_0);
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        /// try const QString &ss0, Qt::DateFormat f = Qt::TextDates1,
        QDateTime *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QDateTime *return_object = new QDateTime;

        if (getThis() == NULL) {
          *return_object = static_cast < QDateTime > (QDateTime::fromString((const QString &)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
        } else {
          *return_object = static_cast < QDateTime > (selfpointer->fromString((const QString &)*cpp_arg_0, (Qt::DateFormat) Z_LVAL_P(arg_1)));
        } le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type


  ///const QString &s, const QString &format
#ifdef PHP_QT_QDateTime         // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    arg_1 = invokeToQString(arg_1);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QString
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59) && inherits(Z_OBJCE_P(arg_1), 59)) {
        /// try const QString &s, const QString &format,
        QDateTime *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        QString *cpp_arg_1 = static_cast < QString * >(php_qt_fetch(arg_1));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QDateTime *return_object = new QDateTime;

        if (getThis() == NULL) {
          *return_object = static_cast < QDateTime > (QDateTime::fromString((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
        } else {
          *return_object = static_cast < QDateTime > (selfpointer->fromString((const QString &)*cpp_arg_0, (const QString &)*cpp_arg_1));
        } le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDateTime::fromString(...) ");
}

/*!
 * method setDate
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QDate &dates0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QDateTime, setDate)
{
  ///const QDate &dates0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QDate
      if (inherits(Z_OBJCE_P(arg_0), 13)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setDate' is not static");
          RETURN_NULL();
        }
        /// try const QDate &dates0,
        QDateTime *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
        }
        QDate *cpp_arg_0 = static_cast < QDate * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setDate((const QDate &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QDateTime::setDate(...) ");
}

/*!
 * method currentDateTime
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QDateTime
 * @flags	s
 */

ZEND_METHOD(QDateTime, currentDateTime)
{
  ///
#ifdef PHP_QT_QDateTime         // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      /// try 
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QDateTime *return_object = new QDateTime;

      if (getThis() == NULL) {
        *return_object = static_cast < QDateTime > (QDateTime::currentDateTime());
      } else {
        *return_object = static_cast < QDateTime > (selfpointer->currentDateTime());
      }
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDateTime::currentDateTime(...) ");
}

/*!
 * method daysTo
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QDateTime &s0
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QDateTime, daysTo)
{
  ///const QDateTime &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QDateTime
      if (inherits(Z_OBJCE_P(arg_0), 14)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'daysTo' is not static");
          RETURN_NULL();
        }
        /// try const QDateTime &s0,
        QDateTime *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
        }
        QDateTime *cpp_arg_0 = static_cast < QDateTime * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->daysTo((const QDateTime &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QDateTime::daysTo(...) ");
}

/*!
 * method toUTC
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QDateTime
 * @flags	c
 */

ZEND_METHOD(QDateTime, toUTC)
{
  ///
#ifdef PHP_QT_QDateTime         // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toUTC' is not static");
        RETURN_NULL();
      }
      /// try 
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QDateTime *return_object = new QDateTime;

      *return_object = static_cast < QDateTime > (selfpointer->toUTC());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDateTime::toUTC(...) ");
}

/*!
 * method setTimeSpec
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::TimeSpec specs0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QDateTime, setTimeSpec)
{
  ///Qt::TimeSpec specs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setTimeSpec' is not static");
        RETURN_NULL();
      }
      /// try Qt::TimeSpec specs0,
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setTimeSpec((Qt::TimeSpec) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QDateTime::setTimeSpec(...) ");
}

/*!
 * method time
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QTime
 * @flags	c
 */

ZEND_METHOD(QDateTime, time)
{
  ///
#ifdef PHP_QT_QTime             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'time' is not static");
        RETURN_NULL();
      }
      /// try 
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QTime *return_object = new QTime;

      *return_object = static_cast < QTime > (selfpointer->time());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDateTime::time(...) ");
}

/*!
 * method operator<
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QDateTime &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method operator==
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QDateTime &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method addMonths
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int monthss0
 * 
 * @access	public
 * @return	QDateTime
 * @flags	c
 */

ZEND_METHOD(QDateTime, addMonths)
{
  ///int monthss0
#ifdef PHP_QT_QDateTime         // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'addMonths' is not static");
        RETURN_NULL();
      }
      /// try int monthss0,
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QDateTime *return_object = new QDateTime;

      *return_object = static_cast < QDateTime > (selfpointer->addMonths((int)Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDateTime::addMonths(...) ");
}

/*!
 * method addSecs
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int secss0
 * 
 * @access	public
 * @return	QDateTime
 * @flags	c
 */

ZEND_METHOD(QDateTime, addSecs)
{
  ///int secss0
#ifdef PHP_QT_QDateTime         // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'addSecs' is not static");
        RETURN_NULL();
      }
      /// try int secss0,
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QDateTime *return_object = new QDateTime;

      *return_object = static_cast < QDateTime > (selfpointer->addSecs((int)Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDateTime::addSecs(...) ");
}

/*!
 * method operator!=
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QDateTime &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method operator>
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QDateTime &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method secsTo
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QDateTime &s0
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QDateTime, secsTo)
{
  ///const QDateTime &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QDateTime
      if (inherits(Z_OBJCE_P(arg_0), 14)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'secsTo' is not static");
          RETURN_NULL();
        }
        /// try const QDateTime &s0,
        QDateTime *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
        }
        QDateTime *cpp_arg_0 = static_cast < QDateTime * >(php_qt_fetch(arg_0));

        RETURN_LONG(selfpointer->secsTo((const QDateTime &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QDateTime::secsTo(...) ");
}

/*!
 * method toTimeSpec
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::TimeSpec specs0
 * 
 * @access	public
 * @return	QDateTime
 * @flags	c
 */

ZEND_METHOD(QDateTime, toTimeSpec)
{
  ///Qt::TimeSpec specs0
#ifdef PHP_QT_QDateTime         // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toTimeSpec' is not static");
        RETURN_NULL();
      }
      /// try Qt::TimeSpec specs0,
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QDateTime *return_object = new QDateTime;

      *return_object = static_cast < QDateTime > (selfpointer->toTimeSpec((Qt::TimeSpec) Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDateTime::toTimeSpec(...) ");
}

/*!
 * method setTime
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QTime &times0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QDateTime, setTime)
{
  ///const QTime &times0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QTime
      if (inherits(Z_OBJCE_P(arg_0), 63)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setTime' is not static");
          RETURN_NULL();
        }
        /// try const QTime &times0,
        QDateTime *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
        }
        QTime *cpp_arg_0 = static_cast < QTime * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setTime((const QTime &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QDateTime::setTime(...) ");
}

/*!
 * method addYears
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int yearss0
 * 
 * @access	public
 * @return	QDateTime
 * @flags	c
 */

ZEND_METHOD(QDateTime, addYears)
{
  ///int yearss0
#ifdef PHP_QT_QDateTime         // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'addYears' is not static");
        RETURN_NULL();
      }
      /// try int yearss0,
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QDateTime *return_object = new QDateTime;

      *return_object = static_cast < QDateTime > (selfpointer->addYears((int)Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDateTime::addYears(...) ");
}

/*!
 * method detach
 * 
 * @param: -
 * @param: -
 * 
 * @access	private
 * @return	void
 * @flags	
 */

ZEND_METHOD(QDateTime, detach)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
/// method is private, skip
      php_error(E_ERROR, "QDateTime::detach(...) cannot be called with ''.");
    }
  }
  php_error(E_ERROR, "could not parse argument in QDateTime::detach(...) ");
}

/*!
 * method operator<=
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QDateTime &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method toString
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	Qt::DateFormat f = Qt::TextDates0
 * 
 * overloaded args:
 * @param	const QString &format
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QDateTime, toString)
{
  ///Qt::DateFormat f = Qt::TextDates0
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toString' is not static");
        RETURN_NULL();
      }
      /// try 
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->toString());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toString' is not static");
        RETURN_NULL();
      }
      /// try Qt::DateFormat f = Qt::TextDates0,
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->toString((Qt::DateFormat) Z_LVAL_P(arg_0)));
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type


  ///const QString &format
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'toString' is not static");
          RETURN_NULL();
        }
        /// try const QString &format,
        QDateTime *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QString *return_object = new QString;

        *return_object = static_cast < QString > (selfpointer->toString((const QString &)*cpp_arg_0));
        le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDateTime::toString(...) ");
}

/*!
 * method setTime_t
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	uint secsSince1Jan1970UTCs0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QDateTime, setTime_t)
{
  ///uint secsSince1Jan1970UTCs0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setTime_t' is not static");
        RETURN_NULL();
      }
      /// try uint secsSince1Jan1970UTCs0,
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setTime_t((uint) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QDateTime::setTime_t(...) ");
}

/*!
 * method timeSpec
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Qt::TimeSpec
 * @flags	c
 */

ZEND_METHOD(QDateTime, timeSpec)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'timeSpec' is not static");
        RETURN_NULL();
      }
      /// try 
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->timeSpec());
    }
  }
  php_error(E_ERROR, "could not parse argument in QDateTime::timeSpec(...) ");
}

/*!
 * method QDateTime
 * 
 * @param: -
 * @param: -
 * 
 * overloaded args:
 * @param	const QDate &s0
 * 
 * overloaded args:
 * @param	const QDate &s0
 * @param	const QTime &s1
 * @param	 Qt::TimeSpec spec = Qt::LocalTime
 * 
 * overloaded args:
 * @param	const QDateTime &others0
 * 
 * @access	public
 * @return	
 * @flags	
 */

ZEND_METHOD(QDateTime, __construct)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try 
      QDateTime_php_qt *selfpointer = new QDateTime_php_qt(getThis());

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  ///const QDate &s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QDate
      if (inherits(Z_OBJCE_P(arg_0), 13)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try const QDate &s0,
        QDate *cpp_arg_0 = static_cast < QDate * >(php_qt_fetch(arg_0));
        QDateTime_php_qt *selfpointer = new QDateTime_php_qt(getThis(), (const QDate &)*cpp_arg_0);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  ///const QDate &s0,const QTime &s1, Qt::TimeSpec spec = Qt::LocalTime
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QDate
#ifdef PHP_QT_QTime
      if (inherits(Z_OBJCE_P(arg_0), 13) && inherits(Z_OBJCE_P(arg_1), 63)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try const QDate &s0,const QTime &s1,
        QDate *cpp_arg_0 = static_cast < QDate * >(php_qt_fetch(arg_0));
        QTime *cpp_arg_1 = static_cast < QTime * >(php_qt_fetch(arg_1));
        QDateTime_php_qt *selfpointer = new QDateTime_php_qt(getThis(), (const QDate &)*cpp_arg_0, (const QTime &)*cpp_arg_1);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

#endif

    }
  }
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_LONG) {
#ifdef PHP_QT_QDate
#ifdef PHP_QT_QTime
      if (inherits(Z_OBJCE_P(arg_0), 13) && inherits(Z_OBJCE_P(arg_1), 63)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try const QDate &s0,const QTime &s1, Qt::TimeSpec spec = Qt::LocalTime,
        QDate *cpp_arg_0 = static_cast < QDate * >(php_qt_fetch(arg_0));
        QTime *cpp_arg_1 = static_cast < QTime * >(php_qt_fetch(arg_1));
        QDateTime_php_qt *selfpointer = new QDateTime_php_qt(getThis(), (const QDate &)*cpp_arg_0, (const QTime &)*cpp_arg_1, (Qt::TimeSpec) Z_LVAL_P(arg_2));

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

#endif

    }
  }
  ///const QDateTime &others0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QDateTime
      if (inherits(Z_OBJCE_P(arg_0), 14)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try const QDateTime &others0,
        QDateTime *cpp_arg_0 = static_cast < QDateTime * >(php_qt_fetch(arg_0));
        QDateTime_php_qt *selfpointer = new QDateTime_php_qt(getThis(), (const QDateTime &)*cpp_arg_0);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QDateTime::QDateTime(...) ");
}

/*!
 * method isNull
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QDateTime, isNull)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isNull' is not static");
        RETURN_NULL();
      }
      /// try 
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isNull());
    }
  }
  php_error(E_ERROR, "could not parse argument in QDateTime::isNull(...) ");
}

/*!
 * method operator=
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QDateTime &others0
 * 
 * @access	public
 * @return	QDateTime &
 * @flags	
 */

/*!
 * method operator>=
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QDateTime &others0
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

/*!
 * method toLocalTime
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QDateTime
 * @flags	c
 */

ZEND_METHOD(QDateTime, toLocalTime)
{
  ///
#ifdef PHP_QT_QDateTime         // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toLocalTime' is not static");
        RETURN_NULL();
      }
      /// try 
      QDateTime *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QDateTime * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QDateTime *return_object = new QDateTime;

      *return_object = static_cast < QDateTime > (selfpointer->toLocalTime());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QDateTime::toLocalTime(...) ");
}
