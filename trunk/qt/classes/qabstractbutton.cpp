/*
 * PHP-Qt - The PHP language bindings for Qt
 *
 * Copyright (C) 2006
 * Thomas Moenicke <tm@ippfp.org>,
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * QAbstractButton.cpp - QAbstractButton PHP implementation.
 * begin           : Tue Jun  6 22:42:56 2006
 * generated by    : moni using kalyptus 0.9.
 */

#include <iostream>
using namespace std;

#include "../php_qt.h"


#include <QAbstractButton>
/// DEBUG:destructor skipped.
/*!
 * method paintEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QPaintEvent *e
 * 
 * @access	protected
 * @return	void
 * @flags	pv
 */

#include <QPaintEvent>
#include <QMetaMethod>
class QAbstractButton_php_qt:public QAbstractButton
{

public:
  QAbstractButton_php_qt(zval * zend_ptr, QWidget * parent = 0);


  zval *zend_ptr;
  const QMetaObject *metaObject() const;
  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
  virtual void paintEvent(QPaintEvent * es0);   // pure 
};

QAbstractButton_php_qt::QAbstractButton_php_qt(zval * zend_ptr, QWidget * parent):QAbstractButton(parent)
{
  this->zend_ptr = zend_ptr;
// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QAbstractButton",&staticMetaObject));
}

// virtual, pure 

void
QAbstractButton_php_qt::paintEvent(QPaintEvent * es0)
{
}

PHP_QT_MOC(QAbstractButton);

/*!
 * method tr
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 const char *s0
 * @param	 const char * = 0 s1
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QAbstractButton, tr)
{
  /// const char *s0, const char * = 0 s1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      /// try  const char *s0,
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QAbstractButton::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
      /// try  const char *s0, const char * = 0 s1,
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QAbstractButton::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QAbstractButton::tr(...) ");
}

/*!
 * method mouseMoveEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QMouseEvent *es0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method setAutoRepeat
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QAbstractButton, setAutoRepeat)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setAutoRepeat' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setAutoRepeat((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::setAutoRepeat(...) ");
}

/*!
 * method isDown
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QAbstractButton, isDown)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isDown' is not static");
        RETURN_NULL();
      }
      /// try 
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isDown());
    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::isDown(...) ");
}

/*!
 * method qt_invoke
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 int  ints0
 * @param	 QUObject * s1
 * 
 * @access	public
 * @return	bool
 * @flags	v
 */

/*!
 * method setAutoExclusive
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QAbstractButton, setAutoExclusive)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setAutoExclusive' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setAutoExclusive((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::setAutoExclusive(...) ");
}

/*!
 * method setIconSize
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QSize &sizes0
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QAbstractButton, setIconSize)
{
  ///const QSize &sizes0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QSize
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setIconSize' is not static");
          RETURN_NULL();
        }
        /// try const QSize &sizes0,
        QAbstractButton *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
        }
        QSize *cpp_arg_0 = static_cast < QSize * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setIconSize((const QSize &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::setIconSize(...) ");
}

/*!
 * method qt_cast
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 const char * s0
 * 
 * @access	public
 * @return	void*
 * @flags	v
 */

/*!
 * method metaObject
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QMetaObject *
 * @flags	cv
 */

/*!
 * method toggled
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool checkeds0
 * 
 * @access	signals
 * @return	void
 * @flags	n
 */

/*!
 * method setIcon
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QIcon &icons0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QAbstractButton, setIcon)
{
  ///const QIcon &icons0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QIcon
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setIcon' is not static");
          RETURN_NULL();
        }
        /// try const QIcon &icons0,
        QAbstractButton *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
        }
        QIcon *cpp_arg_0 = static_cast < QIcon * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setIcon((const QIcon &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::setIcon(...) ");
}

/*!
 * method focusOutEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QFocusEvent *es0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method nextCheckState
 * 
 * @param: -
 * @param: -
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */

/*!
 * method released
 * 
 * @param: -
 * @param: -
 * 
 * @access	signals
 * @return	void
 * @flags	n
 */

/*!
 * method event
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QEvent *es0
 * 
 * @access	protected
 * @return	bool
 * @flags	
 */

/*!
 * method qt_emit
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 int  ints0
 * @param	 QUObject * s1
 * 
 * @access	public
 * @return	bool
 * @flags	v
 */

/*!
 * method autoExclusive
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QAbstractButton, autoExclusive)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'autoExclusive' is not static");
        RETURN_NULL();
      }
      /// try 
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->autoExclusive());
    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::autoExclusive(...) ");
}

/*!
 * method className
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const char *
 * @flags	cv
 */

/*!
 * method toggle
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QAbstractButton, toggle)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'toggle' is not static");
        RETURN_NULL();
      }
      /// try 
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->toggle());
    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::toggle(...) ");
}

/*!
 * method setCheckable
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QAbstractButton, setCheckable)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setCheckable' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setCheckable((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::setCheckable(...) ");
}

/*!
 * method paintEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QPaintEvent *es0s0
 * 
 * @access	protected
 * @return	void
 * @flags	pv
 */

/*!
 * method setDown
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QAbstractButton, setDown)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setDown' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setDown((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::setDown(...) ");
}

/*!
 * method shortcut
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QKeySequence
 * @flags	c
 */

ZEND_METHOD(QAbstractButton, shortcut)
{
  ///
#ifdef PHP_QT_QKeySequence      // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'shortcut' is not static");
        RETURN_NULL();
      }
      /// try 
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QKeySequence *return_object = new QKeySequence;

      *return_object = static_cast < QKeySequence > (selfpointer->shortcut());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QAbstractButton::shortcut(...) ");
}

/*!
 * method icon
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QIcon
 * @flags	c
 */

ZEND_METHOD(QAbstractButton, icon)
{
  ///
#ifdef PHP_QT_QIcon             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'icon' is not static");
        RETURN_NULL();
      }
      /// try 
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QIcon *return_object = new QIcon;

      *return_object = static_cast < QIcon > (selfpointer->icon());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QAbstractButton::icon(...) ");
}

/*!
 * method setChecked
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QAbstractButton, setChecked)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setChecked' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setChecked((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::setChecked(...) ");
}

/*!
 * method changeEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QEvent *es0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method timerEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QTimerEvent *es0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method setShortcut
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QKeySequence &keys0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QAbstractButton, setShortcut)
{
  ///const QKeySequence &keys0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QKeySequence
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setShortcut' is not static");
          RETURN_NULL();
        }
        /// try const QKeySequence &keys0,
        QAbstractButton *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
        }
        QKeySequence *cpp_arg_0 = static_cast < QKeySequence * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setShortcut((const QKeySequence &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::setShortcut(...) ");
}

/*!
 * method animateClick
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int msec = 100s0
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QAbstractButton, animateClick)
{
  ///int msec = 100s0
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'animateClick' is not static");
        RETURN_NULL();
      }
      /// try 
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->animateClick());
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'animateClick' is not static");
        RETURN_NULL();
      }
      /// try int msec = 100s0,
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->animateClick((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::animateClick(...) ");
}

/*!
 * method staticMetaObject
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QMetaObject*
 * @flags	s
 */

ZEND_METHOD(QAbstractButton, staticMetaObject)
{
  ///
#ifdef PHP_QT_QMetaObject       // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      /// try 
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      if (getThis() == NULL) {
        le.ptr = static_cast < QMetaObject * >(QAbstractButton::staticMetaObject());
      } else {
        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
      }
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QAbstractButton::staticMetaObject(...) ");
}

/*!
 * method mouseReleaseEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QMouseEvent *es0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method autoRepeat
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QAbstractButton, autoRepeat)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'autoRepeat' is not static");
        RETURN_NULL();
      }
      /// try 
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->autoRepeat());
    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::autoRepeat(...) ");
}

/*!
 * method mousePressEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QMouseEvent *es0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method qObject
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QObject*
 * @flags	
 */

/*!
 * method group
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QButtonGroup *
 * @flags	c
 */

ZEND_METHOD(QAbstractButton, group)
{
  ///
#ifdef PHP_QT_QButtonGroup      // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'group' is not static");
        RETURN_NULL();
      }
      /// try 
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = static_cast < QButtonGroup * >(selfpointer->group());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QAbstractButton::group(...) ");
}

/*!
 * method setText
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QString &texts0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QAbstractButton, setText)
{
  ///const QString &texts0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    arg_0 = invokeToQString(arg_0);

    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QString
      if (inherits(Z_OBJCE_P(arg_0), 59)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setText' is not static");
          RETURN_NULL();
        }
        /// try const QString &texts0,
        QAbstractButton *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
        }
        QString *cpp_arg_0 = static_cast < QString * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setText((const QString &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::setText(...) ");
}

/*!
 * method hitButton
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QPoint &poss0
 * 
 * @access	protected
 * @return	bool
 * @flags	cv
 */

/*!
 * method text
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QString
 * @flags	c
 */

ZEND_METHOD(QAbstractButton, text)
{
  ///
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'text' is not static");
        RETURN_NULL();
      }
      /// try 
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      *return_object = static_cast < QString > (selfpointer->text());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QAbstractButton::text(...) ");
}

/*!
 * method isChecked
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QAbstractButton, isChecked)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isChecked' is not static");
        RETURN_NULL();
      }
      /// try 
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isChecked());
    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::isChecked(...) ");
}

/*!
 * method clicked
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool checked = falses0
 * 
 * @access	signals
 * @return	void
 * @flags	n
 */

/*!
 * method keyPressEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QKeyEvent *es0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method keyReleaseEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QKeyEvent *es0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method focusInEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QFocusEvent *es0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method iconSize
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QSize
 * @flags	c
 */

ZEND_METHOD(QAbstractButton, iconSize)
{
  ///
#ifdef PHP_QT_QSize             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'iconSize' is not static");
        RETURN_NULL();
      }
      /// try 
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QSize *return_object = new QSize;

      *return_object = static_cast < QSize > (selfpointer->iconSize());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QAbstractButton::iconSize(...) ");
}

/*!
 * method pressed
 * 
 * @param: -
 * @param: -
 * 
 * @access	signals
 * @return	void
 * @flags	n
 */

/*!
 * method QAbstractButton
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget * parent=0s0
 * 
 * overloaded args:
 * @param	QAbstractButtonPrivate &dd
 * @param	 QWidget* parent = 0
 * 
 * @access	public
 * @return	
 * @flags	t
 */

ZEND_METHOD(QAbstractButton, __construct)
{
  ///QWidget * parent=0s0
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try 
      QAbstractButton_php_qt *selfpointer = new QAbstractButton_php_qt(getThis());

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try QWidget * parent=0s0,
      QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
      QAbstractButton_php_qt *selfpointer = new QAbstractButton_php_qt(getThis(), (QWidget *) cpp_arg_0);

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  ///QAbstractButtonPrivate &dd, QWidget* parent = 0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QAbstractButtonPrivate
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
/// overloaded method is protected, skipped.
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try QAbstractButtonPrivate &dd,
        QAbstractButtonPrivate *cpp_arg_0 = static_cast < QAbstractButtonPrivate * >(php_qt_fetch(arg_0));
        QAbstractButton_php_qt *selfpointer = new QAbstractButton_php_qt(getThis(), (QAbstractButtonPrivate &) * cpp_arg_0);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QAbstractButtonPrivate
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
/// overloaded method is protected, skipped.
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try QAbstractButtonPrivate &dd, QWidget* parent = 0,
        QAbstractButtonPrivate *cpp_arg_0 = static_cast < QAbstractButtonPrivate * >(php_qt_fetch(arg_0));
        QWidget *cpp_arg_1 = static_cast < QWidget * >(php_qt_fetch(arg_1));
        QAbstractButton_php_qt *selfpointer = new QAbstractButton_php_qt(getThis(), (QAbstractButtonPrivate &) * cpp_arg_0, (QWidget *) cpp_arg_1);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::QAbstractButton(...) ");
}

/*!
 * method isCheckable
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QAbstractButton, isCheckable)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isCheckable' is not static");
        RETURN_NULL();
      }
      /// try 
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isCheckable());
    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::isCheckable(...) ");
}

/*!
 * method click
 * 
 * @param: -
 * @param: -
 * 
 * @access	public_slots
 * @return	void
 * @flags	l
 */

ZEND_METHOD(QAbstractButton, click)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'click' is not static");
        RETURN_NULL();
      }
      /// try 
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->click());
    }
  }
  php_error(E_ERROR, "could not parse argument in QAbstractButton::click(...) ");
}

/*!
 * method trUtf8
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 const char *s0
 * @param	 const char * = 0 s1
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QAbstractButton, trUtf8)
{
  /// const char *s0, const char * = 0 s1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      /// try  const char *s0,
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QAbstractButton::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
      /// try  const char *s0, const char * = 0 s1,
      QAbstractButton *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QAbstractButton * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QAbstractButton::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QAbstractButton::trUtf8(...) ");
}

/*!
 * method qt_property
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 int  ints0
 * @param	 int  ints1
 * @param	 QVariant * s2
 * 
 * @access	public
 * @return	bool
 * @flags	v
 */

/*!
 * method checkStateSet
 * 
 * @param: -
 * @param: -
 * 
 * @access	protected
 * @return	void
 * @flags	v
 */
