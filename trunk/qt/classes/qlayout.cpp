/*
 * PHP-Qt - The PHP language bindings for Qt
 *
 * Copyright (C) 2006
 * Thomas Moenicke <tm@ippfp.org>,
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * QLayout.cpp - QLayout PHP implementation.
 * begin           : Tue Jun  6 22:42:56 2006
 * generated by    : moni using kalyptus 0.9.
 */

#include <iostream>
using namespace std;

#include "../php_qt.h"


#include <QLayout>
/// DEBUG:destructor skipped.
/*!
 * method addItem
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QLayoutItem *
 * 
 * @access	public
 * @return	void
 * @flags	pv
 */

/*!
 * method count
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	cpv
 */

/*!
 * method itemAt
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int index
 * 
 * @access	public
 * @return	QLayoutItem *
 * @flags	cpv
 */

/*!
 * method setGeometry
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRect&
 * 
 * @access	public
 * @return	void
 * @flags	p
 */

/*!
 * method takeAt
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int index
 * 
 * @access	public
 * @return	QLayoutItem *
 * @flags	pv
 */

#include <QLayoutItem>
#include <QRect>
#include <QMetaMethod>
class QLayout_php_qt:public QLayout
{

public:
  QLayout_php_qt(zval * zend_ptr, QWidget * parents0);
  QLayout_php_qt(zval * zend_ptr);


  zval *zend_ptr;
  const QMetaObject *metaObject() const;
  int qt_metacall(QMetaObject::Call _c, int _id, void **_a);
  virtual void addItem(QLayoutItem * s0);       // pure 

  virtual int count() const;    // pure 

  virtual QLayoutItem *itemAt(int indexs0) const;       // pure 

  virtual QLayoutItem *takeAt(int indexs0);     // pure 
protected:
  void protected_setGeometry(const QRect & s0); // pure 
};

QLayout_php_qt::QLayout_php_qt(zval * zend_ptr, QWidget * parents0):QLayout(parents0)
{
  this->zend_ptr = zend_ptr;
// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QLayout",&staticMetaObject));
}

QLayout_php_qt::QLayout_php_qt(zval * zend_ptr):QLayout()
{
  this->zend_ptr = zend_ptr;
// for future use:                   PHP_QT_REGISTER_MOC(php_qt_getMocData(this->zend_ptr,"QLayout",&staticMetaObject));
}

// virtual, pure 

void
QLayout_php_qt::addItem(QLayoutItem * s0)
{
}

// virtual, pure 

int
QLayout_php_qt::count() const
{
}

// virtual, pure 

QLayoutItem *
QLayout_php_qt::itemAt(int indexs0) const
{
}

// virtual, pure 

QLayoutItem *
QLayout_php_qt::takeAt(int indexs0)
{
}
void
QLayout_php_qt::protected_setGeometry(const QRect & s0)
{
  this->setGeometry(s0);
}

PHP_QT_MOC(QLayout);

/*!
 * method totalHeightForWidth
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ws0
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QLayout, totalHeightForWidth)
{
  ///int ws0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'totalHeightForWidth' is not static");
        RETURN_NULL();
      }
      /// try int ws0,
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->totalHeightForWidth((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::totalHeightForWidth(...) ");
}

/*!
 * method tr
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 const char *s0
 * @param	 const char * = 0 s1
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QLayout, tr)
{
  /// const char *s0, const char * = 0 s1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      /// try  const char *s0,
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QLayout::tr((const char *)&Z_STRVAL_P(arg_0)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
      /// try  const char *s0, const char * = 0 s1,
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QLayout::tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->tr((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLayout::tr(...) ");
}

/*!
 * method setMargin
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ints0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLayout, setMargin)
{
  ///int ints0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setMargin' is not static");
        RETURN_NULL();
      }
      /// try int ints0,
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setMargin((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::setMargin(...) ");
}

/*!
 * method qt_invoke
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 int  ints0
 * @param	 QUObject * s1
 * 
 * @access	public
 * @return	bool
 * @flags	v
 */

/*!
 * method addItem
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QLayoutItem *s0s0
 * 
 * @access	public
 * @return	void
 * @flags	pv
 */

/*!
 * method activate
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	
 */

ZEND_METHOD(QLayout, activate)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'activate' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->activate());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::activate(...) ");
}

/*!
 * method setMenuBar
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget *ws0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLayout, setMenuBar)
{
  ///QWidget *ws0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QWidget
      if (inherits(Z_OBJCE_P(arg_0), 71)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setMenuBar' is not static");
          RETURN_NULL();
        }
        /// try QWidget *ws0,
        QLayout *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
        }
        QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setMenuBar((QWidget *) cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::setMenuBar(...) ");
}

/*!
 * method layout
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QLayout *
 * @flags	
 */

ZEND_METHOD(QLayout, layout)
{
  ///
#ifdef PHP_QT_QLayout           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'layout' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = static_cast < QLayout * >(selfpointer->layout());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLayout::layout(...) ");
}

/*!
 * method totalMaximumSize
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QSize
 * @flags	c
 */

ZEND_METHOD(QLayout, totalMaximumSize)
{
  ///
#ifdef PHP_QT_QSize             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'totalMaximumSize' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QSize *return_object = new QSize;

      *return_object = static_cast < QSize > (selfpointer->totalMaximumSize());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLayout::totalMaximumSize(...) ");
}

/*!
 * method sizeConstraint
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	SizeConstraint
 * @flags	c
 */

ZEND_METHOD(QLayout, sizeConstraint)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      php_error(E_ERROR, "unsupported return type SizeConstraint");
    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::sizeConstraint(...) ");
}

/*!
 * method qt_cast
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 const char * s0
 * 
 * @access	public
 * @return	void*
 * @flags	v
 */

/*!
 * method metaObject
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QMetaObject *
 * @flags	cv
 */

/*!
 * method count
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	cpv
 */

/*!
 * method widgetEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QEvent *s0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method qt_emit
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 int  ints0
 * @param	 QUObject * s1
 * 
 * @access	public
 * @return	bool
 * @flags	v
 */

/*!
 * method setAlignment
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget *ws0
 * @param	 Qt::Alignment alignments1
 * 
 * overloaded args:
 * @param	QLayout *l
 * @param	 Qt::Alignment alignment
 * 
 * overloaded args:
 * @param	Qt::Alignment alignment
 * 
 * @access	public
 * @return	bool
 * @flags	
 */

ZEND_METHOD(QLayout, setAlignment)
{
  ///QWidget *ws0, Qt::Alignment alignments1
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QWidget
      if (inherits(Z_OBJCE_P(arg_0), 71)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setAlignment' is not static");
          RETURN_NULL();
        }
        /// try QWidget *ws0, Qt::Alignment alignments1,
        QLayout *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
        }
        QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->setAlignment((QWidget *) cpp_arg_0, (Qt::Alignment) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///QLayout *l, Qt::Alignment alignment
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_LONG) {
#ifdef PHP_QT_QLayout
      if (inherits(Z_OBJCE_P(arg_0), 41)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setAlignment' is not static");
          RETURN_NULL();
        }
        /// try QLayout *l, Qt::Alignment alignment,
        QLayout *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
        }
        QLayout *cpp_arg_0 = static_cast < QLayout * >(php_qt_fetch(arg_0));

        RETURN_BOOL(selfpointer->setAlignment((QLayout *) cpp_arg_0, (Qt::Alignment) Z_LVAL_P(arg_1)));
      }
#endif

    }
  }
  ///Qt::Alignment alignment
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setAlignment' is not static");
        RETURN_NULL();
      }
      /// try Qt::Alignment alignment,
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setAlignment((Qt::Alignment) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::setAlignment(...) ");
}

/*!
 * method className
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	const char *
 * @flags	cv
 */

/*!
 * method removeWidget
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget *ws0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLayout, removeWidget)
{
  ///QWidget *ws0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QWidget
      if (inherits(Z_OBJCE_P(arg_0), 71)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'removeWidget' is not static");
          RETURN_NULL();
        }
        /// try QWidget *ws0,
        QLayout *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
        }
        QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->removeWidget((QWidget *) cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::removeWidget(...) ");
}

/*!
 * method staticMetaObject
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QMetaObject*
 * @flags	s
 */

ZEND_METHOD(QLayout, staticMetaObject)
{
  ///
#ifdef PHP_QT_QMetaObject       // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      if (getThis() == NULL) {
        le.ptr = static_cast < QMetaObject * >(QLayout::staticMetaObject());
      } else {
        le.ptr = static_cast < QMetaObject * >(selfpointer->staticMetaObject());
      }
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLayout::staticMetaObject(...) ");
}

/*!
 * method itemAt
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int indexs0s0
 * 
 * @access	public
 * @return	QLayoutItem *
 * @flags	cpv
 */

/*!
 * method qObject
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QObject*
 * @flags	
 */

/*!
 * method totalMinimumSize
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QSize
 * @flags	c
 */

ZEND_METHOD(QLayout, totalMinimumSize)
{
  ///
#ifdef PHP_QT_QSize             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'totalMinimumSize' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QSize *return_object = new QSize;

      *return_object = static_cast < QSize > (selfpointer->totalMinimumSize());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLayout::totalMinimumSize(...) ");
}

/*!
 * method childEvent
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QChildEvent *es0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method QLayout
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget *parents0s0
 * @param: -
 * 
 * overloaded args:
 * @param	QLayoutPrivate &d
 * @param	 QLayout*
 * @param	 QWidget*
 * 
 * overloaded args:
 * @param	const QLayout &
 * 
 * @access	public
 * @return	
 * @flags	
 */

ZEND_METHOD(QLayout, __construct)
{
  ///QWidget *parents0s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QWidget
      if (inherits(Z_OBJCE_P(arg_0), 71)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try QWidget *parents0s0,
        QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
        QLayout_php_qt *selfpointer = new QLayout_php_qt(getThis(), (QWidget *) cpp_arg_0);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

    }
  }
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method '__construct' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout_php_qt *selfpointer = new QLayout_php_qt(getThis());

      PHP_QT_REGISTER(selfpointer);
      RETURN_NULL();
    }
  }
  ///QLayoutPrivate &d, QLayout*, QWidget*
  if (ZEND_NUM_ARGS() == 3) {
    PHP_QT_FETCH_3_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT && Z_TYPE_P(arg_2) == IS_OBJECT) {
#ifdef PHP_QT_QLayoutPrivate
#ifdef PHP_QT_QLayout
#ifdef PHP_QT_QWidget
      if (inherits(Z_OBJCE_P(arg_0), 0) && inherits(Z_OBJCE_P(arg_1), 41) && inherits(Z_OBJCE_P(arg_2), 71)) {
/// overloaded method is protected, skipped.
        if (getThis() == NULL) {
          php_error(E_ERROR, "method '__construct' is not static");
          RETURN_NULL();
        }
        /// try QLayoutPrivate &d, QLayout*, QWidget*,
        QLayoutPrivate *cpp_arg_0 = static_cast < QLayoutPrivate * >(php_qt_fetch(arg_0));
        QLayout *cpp_arg_1 = static_cast < QLayout * >(php_qt_fetch(arg_1));
        QWidget *cpp_arg_2 = static_cast < QWidget * >(php_qt_fetch(arg_2));
        QLayout_php_qt *selfpointer = new QLayout_php_qt(getThis(), (QLayoutPrivate &) * cpp_arg_0, (QLayout *) cpp_arg_1, (QWidget *) cpp_arg_2);

        PHP_QT_REGISTER(selfpointer);
        RETURN_NULL();
      }
#endif

#endif

#endif

    }
  }
  ///const QLayout &
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QLayout
      if (inherits(Z_OBJCE_P(arg_0), 41)) {
/// method is private, skip
        php_error(E_ERROR, "QLayout::__construct(...) cannot be called with 'const QLayout &,'.");
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::QLayout(...) ");
}

/*!
 * method setSpacing
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int ints0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLayout, setSpacing)
{
  ///int ints0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_LONG) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setSpacing' is not static");
        RETURN_NULL();
      }
      /// try int ints0,
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setSpacing((int)Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::setSpacing(...) ");
}

/*!
 * method setSizeConstraint
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	SizeConstraint SizeConstraints0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLayout, setSizeConstraint)
{
// notice: unknown argument SizeConstraint SizeConstraints0, skipped
  php_error(E_ERROR, "could not parse argument in QLayout::setSizeConstraint(...) ");
}

/*!
 * method menuBar
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QWidget *
 * @flags	c
 */

ZEND_METHOD(QLayout, menuBar)
{
  ///
#ifdef PHP_QT_QWidget           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'menuBar' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = static_cast < QWidget * >(selfpointer->menuBar());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLayout::menuBar(...) ");
}

/*!
 * method totalSizeHint
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QSize
 * @flags	c
 */

ZEND_METHOD(QLayout, totalSizeHint)
{
  ///
#ifdef PHP_QT_QSize             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'totalSizeHint' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QSize *return_object = new QSize;

      *return_object = static_cast < QSize > (selfpointer->totalSizeHint());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLayout::totalSizeHint(...) ");
}

/*!
 * method qt_property
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 int  ints0
 * @param	 int  ints1
 * @param	 QVariant * s2
 * 
 * @access	public
 * @return	bool
 * @flags	v
 */

/*!
 * method expandingDirections
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	Qt::Orientations
 * @flags	c
 */

ZEND_METHOD(QLayout, expandingDirections)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'expandingDirections' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->expandingDirections());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::expandingDirections(...) ");
}

/*!
 * method indexOf
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget *s0
 * 
 * @access	public
 * @return	int
 * @flags	cv
 */

/*!
 * method update
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLayout, update)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'update' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->update());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::update(...) ");
}

/*!
 * method addChildWidget
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget *ws0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method alignmentRect
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRect &s0
 * 
 * @access	protected
 * @return	QRect
 * @flags	c
 */

/*!
 * method isEmpty
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QLayout, isEmpty)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isEmpty' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isEmpty());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::isEmpty(...) ");
}

/*!
 * method geometry
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QRect
 * @flags	c
 */

ZEND_METHOD(QLayout, geometry)
{
  ///
#ifdef PHP_QT_QRect             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'geometry' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QRect *return_object = new QRect;

      *return_object = static_cast < QRect > (selfpointer->geometry());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLayout::geometry(...) ");
}

/*!
 * method invalidate
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLayout, invalidate)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'invalidate' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->invalidate());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::invalidate(...) ");
}

/*!
 * method setGeometry
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QRect &s0s0
 * 
 * @access	public
 * @return	void
 * @flags	p
 */

ZEND_METHOD(QLayout, setGeometry)
{
  ///const QRect &s0s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QRect
      if (inherits(Z_OBJCE_P(arg_0), 0)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'setGeometry' is not static");
          RETURN_NULL();
        }
        /// try const QRect &s0s0,
        QLayout *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
        }
        QRect *cpp_arg_0 = static_cast < QRect * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->setGeometry((const QRect &)*cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::setGeometry(...) ");
}

/*!
 * method addChildLayout
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QLayout *ls0
 * 
 * @access	protected
 * @return	void
 * @flags	
 */

/*!
 * method setEnabled
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	bool bools0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLayout, setEnabled)
{
  ///bool bools0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_BOOL) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'setEnabled' is not static");
        RETURN_NULL();
      }
      /// try bool bools0,
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      RETURN_VOID(selfpointer->setEnabled((bool) Z_LVAL_P(arg_0)));
    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::setEnabled(...) ");
}

/*!
 * method takeAt
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	int indexs0s0
 * 
 * @access	public
 * @return	QLayoutItem *
 * @flags	pv
 */

/*!
 * method removeItem
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QLayoutItem *s0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLayout, removeItem)
{
  ///QLayoutItem *s0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QLayoutItem
      if (inherits(Z_OBJCE_P(arg_0), 42)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'removeItem' is not static");
          RETURN_NULL();
        }
        /// try QLayoutItem *s0,
        QLayout *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
        }
        QLayoutItem *cpp_arg_0 = static_cast < QLayoutItem * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->removeItem((QLayoutItem *) cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::removeItem(...) ");
}

/*!
 * method addWidget
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QWidget *ws0
 * 
 * @access	public
 * @return	void
 * @flags	
 */

ZEND_METHOD(QLayout, addWidget)
{
  ///QWidget *ws0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QWidget
      if (inherits(Z_OBJCE_P(arg_0), 71)) {
        if (getThis() == NULL) {
          php_error(E_ERROR, "method 'addWidget' is not static");
          RETURN_NULL();
        }
        /// try QWidget *ws0,
        QLayout *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
        }
        QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));

        RETURN_VOID(selfpointer->addWidget((QWidget *) cpp_arg_0));
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::addWidget(...) ");
}

/*!
 * method minimumSize
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QSize
 * @flags	c
 */

ZEND_METHOD(QLayout, minimumSize)
{
  ///
#ifdef PHP_QT_QSize             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'minimumSize' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QSize *return_object = new QSize;

      *return_object = static_cast < QSize > (selfpointer->minimumSize());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLayout::minimumSize(...) ");
}

/*!
 * method isEnabled
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	bool
 * @flags	c
 */

ZEND_METHOD(QLayout, isEnabled)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'isEnabled' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      RETURN_BOOL(selfpointer->isEnabled());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::isEnabled(...) ");
}

/*!
 * method closestAcceptableSize
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	const QWidget *ws0
 * @param	 const QSize  &ss1
 * 
 * @access	public
 * @return	QSize
 * @flags	s
 */

ZEND_METHOD(QLayout, closestAcceptableSize)
{
  ///const QWidget *ws0, const QSize  &ss1
#ifdef PHP_QT_QSize             // return type

  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT && Z_TYPE_P(arg_1) == IS_OBJECT) {
#ifdef PHP_QT_QWidget
#ifdef PHP_QT_QSize
      if (inherits(Z_OBJCE_P(arg_0), 71) && inherits(Z_OBJCE_P(arg_1), 0)) {
        /// try const QWidget *ws0, const QSize  &ss1,
        QLayout *selfpointer;

        if (getThis() != NULL) {
          selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
        }
        QWidget *cpp_arg_0 = static_cast < QWidget * >(php_qt_fetch(arg_0));
        QSize *cpp_arg_1 = static_cast < QSize * >(php_qt_fetch(arg_1));
        zend_class_entry *ce;

        object_init_ex(return_value, QString_ce_ptr);
        zend_rsrc_list_entry le;
        QSize *return_object = new QSize;

        if (getThis() == NULL) {
          *return_object = static_cast < QSize > (QLayout::closestAcceptableSize((const QWidget *)cpp_arg_0, (const QSize &)*cpp_arg_1));
        } else {
          *return_object = static_cast < QSize > (selfpointer->closestAcceptableSize((const QWidget *)cpp_arg_0, (const QSize &)*cpp_arg_1));
        } le.ptr = (void *)return_object;
        php_qt_register(return_value, le);
        return;
      }
#endif

#endif

    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLayout::closestAcceptableSize(...) ");
}

/*!
 * method parentWidget
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QWidget *
 * @flags	c
 */

ZEND_METHOD(QLayout, parentWidget)
{
  ///
#ifdef PHP_QT_QWidget           // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'parentWidget' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;

      le.ptr = static_cast < QWidget * >(selfpointer->parentWidget());
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLayout::parentWidget(...) ");
}

/*!
 * method trUtf8
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	 const char *s0
 * @param	 const char * = 0 s1
 * 
 * @access	public
 * @return	QString
 * @flags	s
 */

ZEND_METHOD(QLayout, trUtf8)
{
  /// const char *s0, const char * = 0 s1
#ifdef PHP_QT_QString           // return type

  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING) {
      /// try  const char *s0,
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QLayout::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
  if (ZEND_NUM_ARGS() == 2) {
    PHP_QT_FETCH_2_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_STRING && Z_TYPE_P(arg_1) == IS_STRING) {
      /// try  const char *s0, const char * = 0 s1,
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QString *return_object = new QString;

      if (getThis() == NULL) {
        *return_object = static_cast < QString > (QLayout::trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
      } else {
        *return_object = static_cast < QString > (selfpointer->trUtf8((const char *)&Z_STRVAL_P(arg_0)[0], (const char *)&Z_STRVAL_P(arg_1)[0]));
      } le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLayout::trUtf8(...) ");
}

/*!
 * method maximumSize
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	QSize
 * @flags	c
 */

ZEND_METHOD(QLayout, maximumSize)
{
  ///
#ifdef PHP_QT_QSize             // return type

  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'maximumSize' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      zend_class_entry *ce;

      object_init_ex(return_value, QString_ce_ptr);
      zend_rsrc_list_entry le;
      QSize *return_object = new QSize;

      *return_object = static_cast < QSize > (selfpointer->maximumSize());
      le.ptr = (void *)return_object;
      php_qt_register(return_value, le);
      return;
    }
  }
#endif // return type

  php_error(E_ERROR, "could not parse argument in QLayout::maximumSize(...) ");
}

/*!
 * method margin
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QLayout, margin)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'margin' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->margin());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::margin(...) ");
}

/*!
 * method spacing
 * 
 * @param: -
 * @param: -
 * 
 * @access	public
 * @return	int
 * @flags	c
 */

ZEND_METHOD(QLayout, spacing)
{
  ///
  if (ZEND_NUM_ARGS() == 0) {
    PHP_QT_FETCH_0_ARGS();
    if (1) {
      if (getThis() == NULL) {
        php_error(E_ERROR, "method 'spacing' is not static");
        RETURN_NULL();
      }
      /// try 
      QLayout *selfpointer;

      if (getThis() != NULL) {
        selfpointer = static_cast < QLayout * >(PHP_QT_FETCH());
      }
      RETURN_LONG(selfpointer->spacing());
    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::spacing(...) ");
}

/*!
 * method activateRecursiveHelper
 * 
 * @param: -
 * 
 * overloaded args:
 * @param	QLayoutItem *items0
 * 
 * @access	private
 * @return	void
 * @flags	s
 */

ZEND_METHOD(QLayout, activateRecursiveHelper)
{
  ///QLayoutItem *items0
  if (ZEND_NUM_ARGS() == 1) {
    PHP_QT_FETCH_1_ARGS();
    if (1 && Z_TYPE_P(arg_0) == IS_OBJECT) {
#ifdef PHP_QT_QLayoutItem
      if (inherits(Z_OBJCE_P(arg_0), 42)) {
/// method is private, skip
        php_error(E_ERROR, "QLayout::activateRecursiveHelper(...) cannot be called with 'QLayoutItem *items0,'.");
      }
#endif

    }
  }
  php_error(E_ERROR, "could not parse argument in QLayout::activateRecursiveHelper(...) ");
}
